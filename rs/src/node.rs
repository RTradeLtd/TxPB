// This file is generated by rust-protobuf 2.10.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `node.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_2;

#[derive(PartialEq,Clone,Default)]
pub struct P2PRequest {
    // message fields
    pub requestType: P2PREQTYPE,
    pub all: bool,
    pub verbose: bool,
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub remoteAddress: ::std::string::String,
    pub allowCustomProtocols: bool,
    pub reportPeerID: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PRequest {
    fn default() -> &'a P2PRequest {
        <P2PRequest as ::protobuf::Message>::default_instance()
    }
}

impl P2PRequest {
    pub fn new() -> P2PRequest {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // bool verbose = 3;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }

    // string protocolName = 4;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 5;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 6;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // string remoteAddress = 7;


    pub fn get_remoteAddress(&self) -> &str {
        &self.remoteAddress
    }
    pub fn clear_remoteAddress(&mut self) {
        self.remoteAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_remoteAddress(&mut self, v: ::std::string::String) {
        self.remoteAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteAddress(&mut self) -> &mut ::std::string::String {
        &mut self.remoteAddress
    }

    // Take field
    pub fn take_remoteAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remoteAddress, ::std::string::String::new())
    }

    // bool allowCustomProtocols = 8;


    pub fn get_allowCustomProtocols(&self) -> bool {
        self.allowCustomProtocols
    }
    pub fn clear_allowCustomProtocols(&mut self) {
        self.allowCustomProtocols = false;
    }

    // Param is passed by value, moved
    pub fn set_allowCustomProtocols(&mut self, v: bool) {
        self.allowCustomProtocols = v;
    }

    // bool reportPeerID = 9;


    pub fn get_reportPeerID(&self) -> bool {
        self.reportPeerID
    }
    pub fn clear_reportPeerID(&mut self) {
        self.reportPeerID = false;
    }

    // Param is passed by value, moved
    pub fn set_reportPeerID(&mut self, v: bool) {
        self.reportPeerID = v;
    }
}

impl ::protobuf::Message for P2PRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remoteAddress)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowCustomProtocols = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reportPeerID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.all != false {
            my_size += 2;
        }
        if self.verbose != false {
            my_size += 2;
        }
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.targetAddress);
        }
        if !self.remoteAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.remoteAddress);
        }
        if self.allowCustomProtocols != false {
            my_size += 2;
        }
        if self.reportPeerID != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, self.requestType.value())?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        if self.verbose != false {
            os.write_bool(3, self.verbose)?;
        }
        if !self.protocolName.is_empty() {
            os.write_string(4, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(5, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(6, &self.targetAddress)?;
        }
        if !self.remoteAddress.is_empty() {
            os.write_string(7, &self.remoteAddress)?;
        }
        if self.allowCustomProtocols != false {
            os.write_bool(8, self.allowCustomProtocols)?;
        }
        if self.reportPeerID != false {
            os.write_bool(9, self.reportPeerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PRequest {
        P2PRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                    "requestType",
                    |m: &P2PRequest| { &m.requestType },
                    |m: &mut P2PRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &P2PRequest| { &m.all },
                    |m: &mut P2PRequest| { &mut m.all },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "verbose",
                    |m: &P2PRequest| { &m.verbose },
                    |m: &mut P2PRequest| { &mut m.verbose },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocolName",
                    |m: &P2PRequest| { &m.protocolName },
                    |m: &mut P2PRequest| { &mut m.protocolName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listenAddress",
                    |m: &P2PRequest| { &m.listenAddress },
                    |m: &mut P2PRequest| { &mut m.listenAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetAddress",
                    |m: &P2PRequest| { &m.targetAddress },
                    |m: &mut P2PRequest| { &mut m.targetAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remoteAddress",
                    |m: &P2PRequest| { &m.remoteAddress },
                    |m: &mut P2PRequest| { &mut m.remoteAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allowCustomProtocols",
                    |m: &P2PRequest| { &m.allowCustomProtocols },
                    |m: &mut P2PRequest| { &mut m.allowCustomProtocols },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reportPeerID",
                    |m: &P2PRequest| { &m.reportPeerID },
                    |m: &mut P2PRequest| { &mut m.reportPeerID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<P2PRequest>(
                    "P2PRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PRequest {
        static mut instance: ::protobuf::lazy::Lazy<P2PRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const P2PRequest,
        };
        unsafe {
            instance.get(P2PRequest::new)
        }
    }
}

impl ::protobuf::Clear for P2PRequest {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.all = false;
        self.verbose = false;
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.remoteAddress.clear();
        self.allowCustomProtocols = false;
        self.reportPeerID = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PResponse {
    // message fields
    pub requestType: P2PREQTYPE,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    pub connsClosed: i32,
    pub streamInfos: ::protobuf::RepeatedField<P2PLsInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PResponse {
    fn default() -> &'a P2PResponse {
        <P2PResponse as ::protobuf::Message>::default_instance()
    }
}

impl P2PResponse {
    pub fn new() -> P2PResponse {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // repeated string names = 2;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    // int32 connsClosed = 3;


    pub fn get_connsClosed(&self) -> i32 {
        self.connsClosed
    }
    pub fn clear_connsClosed(&mut self) {
        self.connsClosed = 0;
    }

    // Param is passed by value, moved
    pub fn set_connsClosed(&mut self, v: i32) {
        self.connsClosed = v;
    }

    // repeated .pb.P2PLsInfo streamInfos = 4;


    pub fn get_streamInfos(&self) -> &[P2PLsInfo] {
        &self.streamInfos
    }
    pub fn clear_streamInfos(&mut self) {
        self.streamInfos.clear();
    }

    // Param is passed by value, moved
    pub fn set_streamInfos(&mut self, v: ::protobuf::RepeatedField<P2PLsInfo>) {
        self.streamInfos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streamInfos(&mut self) -> &mut ::protobuf::RepeatedField<P2PLsInfo> {
        &mut self.streamInfos
    }

    // Take field
    pub fn take_streamInfos(&mut self) -> ::protobuf::RepeatedField<P2PLsInfo> {
        ::std::mem::replace(&mut self.streamInfos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P2PResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.streamInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connsClosed = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streamInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.connsClosed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.connsClosed, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.streamInfos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        if self.connsClosed != 0 {
            os.write_int32(3, self.connsClosed)?;
        }
        for v in &self.streamInfos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PResponse {
        P2PResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                    "requestType",
                    |m: &P2PResponse| { &m.requestType },
                    |m: &mut P2PResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "names",
                    |m: &P2PResponse| { &m.names },
                    |m: &mut P2PResponse| { &mut m.names },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "connsClosed",
                    |m: &P2PResponse| { &m.connsClosed },
                    |m: &mut P2PResponse| { &mut m.connsClosed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P2PLsInfo>>(
                    "streamInfos",
                    |m: &P2PResponse| { &m.streamInfos },
                    |m: &mut P2PResponse| { &mut m.streamInfos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<P2PResponse>(
                    "P2PResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PResponse {
        static mut instance: ::protobuf::lazy::Lazy<P2PResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const P2PResponse,
        };
        unsafe {
            instance.get(P2PResponse::new)
        }
    }
}

impl ::protobuf::Clear for P2PResponse {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.names.clear();
        self.connsClosed = 0;
        self.streamInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PLsInfo {
    // message fields
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PLsInfo {
    fn default() -> &'a P2PLsInfo {
        <P2PLsInfo as ::protobuf::Message>::default_instance()
    }
}

impl P2PLsInfo {
    pub fn new() -> P2PLsInfo {
        ::std::default::Default::default()
    }

    // string protocolName = 1;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 2;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 3;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for P2PLsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.targetAddress);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.protocolName.is_empty() {
            os.write_string(1, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(2, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(3, &self.targetAddress)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PLsInfo {
        P2PLsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocolName",
                    |m: &P2PLsInfo| { &m.protocolName },
                    |m: &mut P2PLsInfo| { &mut m.protocolName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listenAddress",
                    |m: &P2PLsInfo| { &m.listenAddress },
                    |m: &mut P2PLsInfo| { &mut m.listenAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetAddress",
                    |m: &P2PLsInfo| { &m.targetAddress },
                    |m: &mut P2PLsInfo| { &mut m.targetAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &P2PLsInfo| { &m.local },
                    |m: &mut P2PLsInfo| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<P2PLsInfo>(
                    "P2PLsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static P2PLsInfo {
        static mut instance: ::protobuf::lazy::Lazy<P2PLsInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const P2PLsInfo,
        };
        unsafe {
            instance.get(P2PLsInfo::new)
        }
    }
}

impl ::protobuf::Clear for P2PLsInfo {
    fn clear(&mut self) {
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PLsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PLsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeersResponse {
    // message fields
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeersResponse {
    fn default() -> &'a GetPeersResponse {
        <GetPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeersResponse {
    pub fn new() -> GetPeersResponse {
        ::std::default::Default::default()
    }

    // repeated string peerIDs = 1;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peerIDs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersResponse {
        GetPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &GetPeersResponse| { &m.peerIDs },
                    |m: &mut GetPeersResponse| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeersResponse>(
                    "GetPeersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeersResponse,
        };
        unsafe {
            instance.get(GetPeersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeersResponse {
    fn clear(&mut self) {
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtRequest {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub multiAddrs: ::protobuf::RepeatedField<::std::string::String>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtRequest {
    fn default() -> &'a ConnMgmtRequest {
        <ConnMgmtRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtRequest {
    pub fn new() -> ConnMgmtRequest {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated string multiAddrs = 2;


    pub fn get_multiAddrs(&self) -> &[::std::string::String] {
        &self.multiAddrs
    }
    pub fn clear_multiAddrs(&mut self) {
        self.multiAddrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_multiAddrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.multiAddrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_multiAddrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.multiAddrs
    }

    // Take field
    pub fn take_multiAddrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.multiAddrs, ::protobuf::RepeatedField::new())
    }

    // repeated string peerIDs = 3;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.multiAddrs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.multiAddrs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.multiAddrs {
            os.write_string(2, &v)?;
        };
        for v in &self.peerIDs {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtRequest {
        ConnMgmtRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                    "requestType",
                    |m: &ConnMgmtRequest| { &m.requestType },
                    |m: &mut ConnMgmtRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "multiAddrs",
                    |m: &ConnMgmtRequest| { &m.multiAddrs },
                    |m: &mut ConnMgmtRequest| { &mut m.multiAddrs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &ConnMgmtRequest| { &m.peerIDs },
                    |m: &mut ConnMgmtRequest| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnMgmtRequest>(
                    "ConnMgmtRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnMgmtRequest,
        };
        unsafe {
            instance.get(ConnMgmtRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtRequest {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.multiAddrs.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtResponse {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub connected: ::std::collections::HashMap<::std::string::String, bool>,
    pub status: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtResponse {
    fn default() -> &'a ConnMgmtResponse {
        <ConnMgmtResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtResponse {
    pub fn new() -> ConnMgmtResponse {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.ConnMgmtResponse.ConnectedEntry connected = 2;


    pub fn get_connected(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.connected
    }
    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.connected = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connected(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.connected
    }

    // Take field
    pub fn take_connected(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.connected, ::std::collections::HashMap::new())
    }

    // repeated .pb.ConnMgmtResponse.StatusEntry status = 3;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated string peerIDs = 4;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.connected)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status);
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, self.requestType.value())?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status, os)?;
        for v in &self.peerIDs {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtResponse {
        ConnMgmtResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                    "requestType",
                    |m: &ConnMgmtResponse| { &m.requestType },
                    |m: &mut ConnMgmtResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                    "connected",
                    |m: &ConnMgmtResponse| { &m.connected },
                    |m: &mut ConnMgmtResponse| { &mut m.connected },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(
                    "status",
                    |m: &ConnMgmtResponse| { &m.status },
                    |m: &mut ConnMgmtResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerIDs",
                    |m: &ConnMgmtResponse| { &m.peerIDs },
                    |m: &mut ConnMgmtResponse| { &mut m.peerIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnMgmtResponse>(
                    "ConnMgmtResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnMgmtResponse,
        };
        unsafe {
            instance.get(ConnMgmtResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtResponse {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.connected.clear();
        self.status.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtStatus {
    // message fields
    pub disconnected: bool,
    pub reason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtStatus {
    fn default() -> &'a ConnMgmtStatus {
        <ConnMgmtStatus as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtStatus {
    pub fn new() -> ConnMgmtStatus {
        ::std::default::Default::default()
    }

    // bool disconnected = 1;


    pub fn get_disconnected(&self) -> bool {
        self.disconnected
    }
    pub fn clear_disconnected(&mut self) {
        self.disconnected = false;
    }

    // Param is passed by value, moved
    pub fn set_disconnected(&mut self, v: bool) {
        self.disconnected = v;
    }

    // string reason = 2;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnMgmtStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disconnected = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disconnected != false {
            my_size += 2;
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disconnected != false {
            os.write_bool(1, self.disconnected)?;
        }
        if !self.reason.is_empty() {
            os.write_string(2, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtStatus {
        ConnMgmtStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disconnected",
                    |m: &ConnMgmtStatus| { &m.disconnected },
                    |m: &mut ConnMgmtStatus| { &mut m.disconnected },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    |m: &ConnMgmtStatus| { &m.reason },
                    |m: &mut ConnMgmtStatus| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnMgmtStatus>(
                    "ConnMgmtStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnMgmtStatus {
        static mut instance: ::protobuf::lazy::Lazy<ConnMgmtStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnMgmtStatus,
        };
        unsafe {
            instance.get(ConnMgmtStatus::new)
        }
    }
}

impl ::protobuf::Clear for ConnMgmtStatus {
    fn clear(&mut self) {
        self.disconnected = false;
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtrasRequest {
    // message fields
    pub requestType: EXTRASREQTYPE,
    pub extrasFeature: EXTRASTYPE,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtrasRequest {
    fn default() -> &'a ExtrasRequest {
        <ExtrasRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtrasRequest {
    pub fn new() -> ExtrasRequest {
        ::std::default::Default::default()
    }

    // .pb.EXTRASREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> EXTRASREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: EXTRASREQTYPE) {
        self.requestType = v;
    }

    // .pb.EXTRASTYPE extrasFeature = 2;


    pub fn get_extrasFeature(&self) -> EXTRASTYPE {
        self.extrasFeature
    }
    pub fn clear_extrasFeature(&mut self) {
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
    }

    // Param is passed by value, moved
    pub fn set_extrasFeature(&mut self, v: EXTRASTYPE) {
        self.extrasFeature = v;
    }
}

impl ::protobuf::Message for ExtrasRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.extrasFeature, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            my_size += ::protobuf::rt::enum_size(2, self.extrasFeature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            os.write_enum(1, self.requestType.value())?;
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            os.write_enum(2, self.extrasFeature.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtrasRequest {
        ExtrasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASREQTYPE>>(
                    "requestType",
                    |m: &ExtrasRequest| { &m.requestType },
                    |m: &mut ExtrasRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASTYPE>>(
                    "extrasFeature",
                    |m: &ExtrasRequest| { &m.extrasFeature },
                    |m: &mut ExtrasRequest| { &mut m.extrasFeature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtrasRequest>(
                    "ExtrasRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtrasRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExtrasRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtrasRequest,
        };
        unsafe {
            instance.get(ExtrasRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExtrasRequest {
    fn clear(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtrasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtrasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreRequest {
    // message fields
    pub requestType: BSREQTYPE,
    pub reqOpts: ::std::vec::Vec<BSREQOPTS>,
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub cidVersion: ::std::string::String,
    pub hashFunc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreRequest {
    fn default() -> &'a BlockstoreRequest {
        <BlockstoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreRequest {
    pub fn new() -> BlockstoreRequest {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.BSREQOPTS reqOpts = 2;


    pub fn get_reqOpts(&self) -> &[BSREQOPTS] {
        &self.reqOpts
    }
    pub fn clear_reqOpts(&mut self) {
        self.reqOpts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reqOpts(&mut self, v: ::std::vec::Vec<BSREQOPTS>) {
        self.reqOpts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reqOpts(&mut self) -> &mut ::std::vec::Vec<BSREQOPTS> {
        &mut self.reqOpts
    }

    // Take field
    pub fn take_reqOpts(&mut self) -> ::std::vec::Vec<BSREQOPTS> {
        ::std::mem::replace(&mut self.reqOpts, ::std::vec::Vec::new())
    }

    // repeated string cids = 3;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes data = 4;


    pub fn get_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // string cidVersion = 5;


    pub fn get_cidVersion(&self) -> &str {
        &self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: ::std::string::String) {
        self.cidVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidVersion(&mut self) -> &mut ::std::string::String {
        &mut self.cidVersion
    }

    // Take field
    pub fn take_cidVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cidVersion, ::std::string::String::new())
    }

    // string hashFunc = 7;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlockstoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.reqOpts, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cidVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.reqOpts {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.data {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.cidVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cidVersion);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hashFunc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.reqOpts {
            os.write_enum(2, v.value())?;
        };
        for v in &self.cids {
            os.write_string(3, &v)?;
        };
        for v in &self.data {
            os.write_bytes(4, &v)?;
        };
        if !self.cidVersion.is_empty() {
            os.write_string(5, &self.cidVersion)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(7, &self.hashFunc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreRequest {
        BlockstoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                    "requestType",
                    |m: &BlockstoreRequest| { &m.requestType },
                    |m: &mut BlockstoreRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQOPTS>>(
                    "reqOpts",
                    |m: &BlockstoreRequest| { &m.reqOpts },
                    |m: &mut BlockstoreRequest| { &mut m.reqOpts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cids",
                    |m: &BlockstoreRequest| { &m.cids },
                    |m: &mut BlockstoreRequest| { &mut m.cids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &BlockstoreRequest| { &m.data },
                    |m: &mut BlockstoreRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cidVersion",
                    |m: &BlockstoreRequest| { &m.cidVersion },
                    |m: &mut BlockstoreRequest| { &mut m.cidVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashFunc",
                    |m: &BlockstoreRequest| { &m.hashFunc },
                    |m: &mut BlockstoreRequest| { &mut m.hashFunc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockstoreRequest>(
                    "BlockstoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockstoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<BlockstoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockstoreRequest,
        };
        unsafe {
            instance.get(BlockstoreRequest::new)
        }
    }
}

impl ::protobuf::Clear for BlockstoreRequest {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.reqOpts.clear();
        self.cids.clear();
        self.data.clear();
        self.cidVersion.clear();
        self.hashFunc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreResponse {
    // message fields
    pub requestType: BSREQTYPE,
    pub blocks: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreResponse {
    fn default() -> &'a BlockstoreResponse {
        <BlockstoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreResponse {
    pub fn new() -> BlockstoreResponse {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockstoreResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreResponse {
        BlockstoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                    "requestType",
                    |m: &BlockstoreResponse| { &m.requestType },
                    |m: &mut BlockstoreResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "blocks",
                    |m: &BlockstoreResponse| { &m.blocks },
                    |m: &mut BlockstoreResponse| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockstoreResponse>(
                    "BlockstoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockstoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<BlockstoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockstoreResponse,
        };
        unsafe {
            instance.get(BlockstoreResponse::new)
        }
    }
}

impl ::protobuf::Clear for BlockstoreResponse {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub cid: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    pub size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // string cid = 1;


    pub fn get_cid(&self) -> &str {
        &self.cid
    }
    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: ::std::string::String) {
        self.cid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut ::std::string::String {
        &mut self.cid
    }

    // Take field
    pub fn take_cid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cid, ::std::string::String::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cid);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cid.is_empty() {
            os.write_string(1, &self.cid)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cid",
                    |m: &Block| { &m.cid },
                    |m: &mut Block| { &mut m.cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Block| { &m.data },
                    |m: &mut Block| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "size",
                    |m: &Block| { &m.size },
                    |m: &mut Block| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.cid.clear();
        self.data.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagRequest {
    // message fields
    pub requestType: DAGREQTYPE,
    pub data: ::std::vec::Vec<u8>,
    pub objectEncoding: ::std::string::String,
    pub serializationFormat: ::std::string::String,
    pub hashFunc: ::std::string::String,
    pub cidVersion: i64,
    pub hash: ::std::string::String,
    pub links: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagRequest {
    fn default() -> &'a DagRequest {
        <DagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DagRequest {
    pub fn new() -> DagRequest {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string objectEncoding = 3;


    pub fn get_objectEncoding(&self) -> &str {
        &self.objectEncoding
    }
    pub fn clear_objectEncoding(&mut self) {
        self.objectEncoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectEncoding(&mut self, v: ::std::string::String) {
        self.objectEncoding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectEncoding(&mut self) -> &mut ::std::string::String {
        &mut self.objectEncoding
    }

    // Take field
    pub fn take_objectEncoding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.objectEncoding, ::std::string::String::new())
    }

    // string serializationFormat = 4;


    pub fn get_serializationFormat(&self) -> &str {
        &self.serializationFormat
    }
    pub fn clear_serializationFormat(&mut self) {
        self.serializationFormat.clear();
    }

    // Param is passed by value, moved
    pub fn set_serializationFormat(&mut self, v: ::std::string::String) {
        self.serializationFormat = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serializationFormat(&mut self) -> &mut ::std::string::String {
        &mut self.serializationFormat
    }

    // Take field
    pub fn take_serializationFormat(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serializationFormat, ::std::string::String::new())
    }

    // string hashFunc = 5;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }

    // int64 cidVersion = 6;


    pub fn get_cidVersion(&self) -> i64 {
        self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: i64) {
        self.cidVersion = v;
    }

    // string hash = 7;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // repeated .pb.DagRequest.LinksEntry links = 8;


    pub fn get_links(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.links, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.objectEncoding)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serializationFormat)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cidVersion = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.objectEncoding.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.objectEncoding);
        }
        if !self.serializationFormat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.serializationFormat);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hashFunc);
        }
        if self.cidVersion != 0 {
            my_size += ::protobuf::rt::value_size(6, self.cidVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hash);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.objectEncoding.is_empty() {
            os.write_string(3, &self.objectEncoding)?;
        }
        if !self.serializationFormat.is_empty() {
            os.write_string(4, &self.serializationFormat)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(5, &self.hashFunc)?;
        }
        if self.cidVersion != 0 {
            os.write_int64(6, self.cidVersion)?;
        }
        if !self.hash.is_empty() {
            os.write_string(7, &self.hash)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagRequest {
        DagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                    "requestType",
                    |m: &DagRequest| { &m.requestType },
                    |m: &mut DagRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DagRequest| { &m.data },
                    |m: &mut DagRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "objectEncoding",
                    |m: &DagRequest| { &m.objectEncoding },
                    |m: &mut DagRequest| { &mut m.objectEncoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serializationFormat",
                    |m: &DagRequest| { &m.serializationFormat },
                    |m: &mut DagRequest| { &mut m.serializationFormat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashFunc",
                    |m: &DagRequest| { &m.hashFunc },
                    |m: &mut DagRequest| { &mut m.hashFunc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cidVersion",
                    |m: &DagRequest| { &m.cidVersion },
                    |m: &mut DagRequest| { &mut m.cidVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &DagRequest| { &m.hash },
                    |m: &mut DagRequest| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "links",
                    |m: &DagRequest| { &m.links },
                    |m: &mut DagRequest| { &mut m.links },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DagRequest>(
                    "DagRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DagRequest {
        static mut instance: ::protobuf::lazy::Lazy<DagRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DagRequest,
        };
        unsafe {
            instance.get(DagRequest::new)
        }
    }
}

impl ::protobuf::Clear for DagRequest {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.data.clear();
        self.objectEncoding.clear();
        self.serializationFormat.clear();
        self.hashFunc.clear();
        self.cidVersion = 0;
        self.hash.clear();
        self.links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagResponse {
    // message fields
    pub requestType: DAGREQTYPE,
    pub hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub rawData: ::std::vec::Vec<u8>,
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub nodeStats: ::std::collections::HashMap<::std::string::String, IPLDStat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagResponse {
    fn default() -> &'a DagResponse {
        <DagResponse as ::protobuf::Message>::default_instance()
    }
}

impl DagResponse {
    pub fn new() -> DagResponse {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // repeated string hashes = 2;


    pub fn get_hashes(&self) -> &[::std::string::String] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    // bytes rawData = 3;


    pub fn get_rawData(&self) -> &[u8] {
        &self.rawData
    }
    pub fn clear_rawData(&mut self) {
        self.rawData.clear();
    }

    // Param is passed by value, moved
    pub fn set_rawData(&mut self, v: ::std::vec::Vec<u8>) {
        self.rawData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rawData
    }

    // Take field
    pub fn take_rawData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rawData, ::std::vec::Vec::new())
    }

    // repeated .pb.IPLDLink links = 4;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.DagResponse.NodeStatsEntry nodeStats = 5;


    pub fn get_nodeStats(&self) -> &::std::collections::HashMap<::std::string::String, IPLDStat> {
        &self.nodeStats
    }
    pub fn clear_nodeStats(&mut self) {
        self.nodeStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeStats(&mut self, v: ::std::collections::HashMap<::std::string::String, IPLDStat>) {
        self.nodeStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeStats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, IPLDStat> {
        &mut self.nodeStats
    }

    // Take field
    pub fn take_nodeStats(&mut self) -> ::std::collections::HashMap<::std::string::String, IPLDStat> {
        ::std::mem::replace(&mut self.nodeStats, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DagResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hashes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rawData)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(wire_type, is, &mut self.nodeStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.rawData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.rawData);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, self.requestType.value())?;
        }
        for v in &self.hashes {
            os.write_string(2, &v)?;
        };
        if !self.rawData.is_empty() {
            os.write_bytes(3, &self.rawData)?;
        }
        for v in &self.links {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagResponse {
        DagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                    "requestType",
                    |m: &DagResponse| { &m.requestType },
                    |m: &mut DagResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hashes",
                    |m: &DagResponse| { &m.hashes },
                    |m: &mut DagResponse| { &mut m.hashes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "rawData",
                    |m: &DagResponse| { &m.rawData },
                    |m: &mut DagResponse| { &mut m.rawData },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                    "links",
                    |m: &DagResponse| { &m.links },
                    |m: &mut DagResponse| { &mut m.links },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(
                    "nodeStats",
                    |m: &DagResponse| { &m.nodeStats },
                    |m: &mut DagResponse| { &mut m.nodeStats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DagResponse>(
                    "DagResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DagResponse {
        static mut instance: ::protobuf::lazy::Lazy<DagResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DagResponse,
        };
        unsafe {
            instance.get(DagResponse::new)
        }
    }
}

impl ::protobuf::Clear for DagResponse {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.hashes.clear();
        self.rawData.clear();
        self.links.clear();
        self.nodeStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDStat {
    // message fields
    pub numLinks: i64,
    pub blockSize: i64,
    pub linkSize: i64,
    pub cumulativeSize: i64,
    pub dataSize: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDStat {
    fn default() -> &'a IPLDStat {
        <IPLDStat as ::protobuf::Message>::default_instance()
    }
}

impl IPLDStat {
    pub fn new() -> IPLDStat {
        ::std::default::Default::default()
    }

    // int64 numLinks = 1;


    pub fn get_numLinks(&self) -> i64 {
        self.numLinks
    }
    pub fn clear_numLinks(&mut self) {
        self.numLinks = 0;
    }

    // Param is passed by value, moved
    pub fn set_numLinks(&mut self, v: i64) {
        self.numLinks = v;
    }

    // int64 blockSize = 2;


    pub fn get_blockSize(&self) -> i64 {
        self.blockSize
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: i64) {
        self.blockSize = v;
    }

    // int64 linkSize = 3;


    pub fn get_linkSize(&self) -> i64 {
        self.linkSize
    }
    pub fn clear_linkSize(&mut self) {
        self.linkSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_linkSize(&mut self, v: i64) {
        self.linkSize = v;
    }

    // int64 cumulativeSize = 4;


    pub fn get_cumulativeSize(&self) -> i64 {
        self.cumulativeSize
    }
    pub fn clear_cumulativeSize(&mut self) {
        self.cumulativeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_cumulativeSize(&mut self, v: i64) {
        self.cumulativeSize = v;
    }

    // int64 dataSize = 5;


    pub fn get_dataSize(&self) -> i64 {
        self.dataSize
    }
    pub fn clear_dataSize(&mut self) {
        self.dataSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_dataSize(&mut self, v: i64) {
        self.dataSize = v;
    }
}

impl ::protobuf::Message for IPLDStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numLinks = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockSize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.linkSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cumulativeSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dataSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.numLinks != 0 {
            my_size += ::protobuf::rt::value_size(1, self.numLinks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.linkSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.linkSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cumulativeSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.cumulativeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dataSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dataSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.numLinks != 0 {
            os.write_int64(1, self.numLinks)?;
        }
        if self.blockSize != 0 {
            os.write_int64(2, self.blockSize)?;
        }
        if self.linkSize != 0 {
            os.write_int64(3, self.linkSize)?;
        }
        if self.cumulativeSize != 0 {
            os.write_int64(4, self.cumulativeSize)?;
        }
        if self.dataSize != 0 {
            os.write_int64(5, self.dataSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDStat {
        IPLDStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "numLinks",
                    |m: &IPLDStat| { &m.numLinks },
                    |m: &mut IPLDStat| { &mut m.numLinks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "blockSize",
                    |m: &IPLDStat| { &m.blockSize },
                    |m: &mut IPLDStat| { &mut m.blockSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "linkSize",
                    |m: &IPLDStat| { &m.linkSize },
                    |m: &mut IPLDStat| { &mut m.linkSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cumulativeSize",
                    |m: &IPLDStat| { &m.cumulativeSize },
                    |m: &mut IPLDStat| { &mut m.cumulativeSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dataSize",
                    |m: &IPLDStat| { &m.dataSize },
                    |m: &mut IPLDStat| { &mut m.dataSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPLDStat>(
                    "IPLDStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDStat {
        static mut instance: ::protobuf::lazy::Lazy<IPLDStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPLDStat,
        };
        unsafe {
            instance.get(IPLDStat::new)
        }
    }
}

impl ::protobuf::Clear for IPLDStat {
    fn clear(&mut self) {
        self.numLinks = 0;
        self.blockSize = 0;
        self.linkSize = 0;
        self.cumulativeSize = 0;
        self.dataSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDLink {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDLink {
    fn default() -> &'a IPLDLink {
        <IPLDLink as ::protobuf::Message>::default_instance()
    }
}

impl IPLDLink {
    pub fn new() -> IPLDLink {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 size = 3;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for IPLDLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.size != 0 {
            os.write_uint64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDLink {
        IPLDLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &IPLDLink| { &m.hash },
                    |m: &mut IPLDLink| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &IPLDLink| { &m.name },
                    |m: &mut IPLDLink| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    |m: &IPLDLink| { &m.size },
                    |m: &mut IPLDLink| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPLDLink>(
                    "IPLDLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDLink {
        static mut instance: ::protobuf::lazy::Lazy<IPLDLink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPLDLink,
        };
        unsafe {
            instance.get(IPLDLink::new)
        }
    }
}

impl ::protobuf::Clear for IPLDLink {
    fn clear(&mut self) {
        self.hash.clear();
        self.name.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDLink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDNode {
    // message fields
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDNode {
    fn default() -> &'a IPLDNode {
        <IPLDNode as ::protobuf::Message>::default_instance()
    }
}

impl IPLDNode {
    pub fn new() -> IPLDNode {
        ::std::default::Default::default()
    }

    // repeated .pb.IPLDLink links = 2;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IPLDNode {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.links {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDNode {
        IPLDNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                    "links",
                    |m: &IPLDNode| { &m.links },
                    |m: &mut IPLDNode| { &mut m.links },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &IPLDNode| { &m.data },
                    |m: &mut IPLDNode| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPLDNode>(
                    "IPLDNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPLDNode {
        static mut instance: ::protobuf::lazy::Lazy<IPLDNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPLDNode,
        };
        unsafe {
            instance.get(IPLDNode::new)
        }
    }
}

impl ::protobuf::Clear for IPLDNode {
    fn clear(&mut self) {
        self.links.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreRequest {
    // message fields
    pub requestType: KSREQTYPE,
    pub name: ::std::string::String,
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreRequest {
    fn default() -> &'a KeystoreRequest {
        <KeystoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreRequest {
    pub fn new() -> KeystoreRequest {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes privateKey = 3;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeystoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(3, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreRequest {
        KeystoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                    "requestType",
                    |m: &KeystoreRequest| { &m.requestType },
                    |m: &mut KeystoreRequest| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &KeystoreRequest| { &m.name },
                    |m: &mut KeystoreRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &KeystoreRequest| { &m.privateKey },
                    |m: &mut KeystoreRequest| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeystoreRequest>(
                    "KeystoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeystoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeystoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeystoreRequest,
        };
        unsafe {
            instance.get(KeystoreRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeystoreRequest {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.name.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreResponse {
    // message fields
    pub requestType: KSREQTYPE,
    pub privateKey: ::std::vec::Vec<u8>,
    pub keyNames: ::protobuf::RepeatedField<::std::string::String>,
    pub has: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreResponse {
    fn default() -> &'a KeystoreResponse {
        <KeystoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreResponse {
    pub fn new() -> KeystoreResponse {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // bytes privateKey = 2;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // repeated string keyNames = 3;


    pub fn get_keyNames(&self) -> &[::std::string::String] {
        &self.keyNames
    }
    pub fn clear_keyNames(&mut self) {
        self.keyNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keyNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keyNames
    }

    // Take field
    pub fn take_keyNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keyNames, ::protobuf::RepeatedField::new())
    }

    // bool has = 4;


    pub fn get_has(&self) -> bool {
        self.has
    }
    pub fn clear_has(&mut self) {
        self.has = false;
    }

    // Param is passed by value, moved
    pub fn set_has(&mut self, v: bool) {
        self.has = v;
    }
}

impl ::protobuf::Message for KeystoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keyNames)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        for value in &self.keyNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.has != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, self.requestType.value())?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        for v in &self.keyNames {
            os.write_string(3, &v)?;
        };
        if self.has != false {
            os.write_bool(4, self.has)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreResponse {
        KeystoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                    "requestType",
                    |m: &KeystoreResponse| { &m.requestType },
                    |m: &mut KeystoreResponse| { &mut m.requestType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &KeystoreResponse| { &m.privateKey },
                    |m: &mut KeystoreResponse| { &mut m.privateKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyNames",
                    |m: &KeystoreResponse| { &m.keyNames },
                    |m: &mut KeystoreResponse| { &mut m.keyNames },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has",
                    |m: &KeystoreResponse| { &m.has },
                    |m: &mut KeystoreResponse| { &mut m.has },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeystoreResponse>(
                    "KeystoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeystoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeystoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeystoreResponse,
        };
        unsafe {
            instance.get(KeystoreResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeystoreResponse {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.privateKey.clear();
        self.keyNames.clear();
        self.has = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistRequest {
    // message fields
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistRequest {
    fn default() -> &'a PersistRequest {
        <PersistRequest as ::protobuf::Message>::default_instance()
    }
}

impl PersistRequest {
    pub fn new() -> PersistRequest {
        ::std::default::Default::default()
    }

    // repeated string cids = 1;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistRequest {
        PersistRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cids",
                    |m: &PersistRequest| { &m.cids },
                    |m: &mut PersistRequest| { &mut m.cids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistRequest>(
                    "PersistRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistRequest {
        static mut instance: ::protobuf::lazy::Lazy<PersistRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistRequest,
        };
        unsafe {
            instance.get(PersistRequest::new)
        }
    }
}

impl ::protobuf::Clear for PersistRequest {
    fn clear(&mut self) {
        self.cids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistResponse {
    // message fields
    pub status: ::std::collections::HashMap<::std::string::String, bool>,
    pub errors: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistResponse {
    fn default() -> &'a PersistResponse {
        <PersistResponse as ::protobuf::Message>::default_instance()
    }
}

impl PersistResponse {
    pub fn new() -> PersistResponse {
        ::std::default::Default::default()
    }

    // repeated .pb.PersistResponse.StatusEntry status = 1;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated .pb.PersistResponse.ErrorsEntry errors = 2;


    pub fn get_errors(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.errors, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PersistResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistResponse {
        PersistResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                    "status",
                    |m: &PersistResponse| { &m.status },
                    |m: &mut PersistResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "errors",
                    |m: &PersistResponse| { &m.errors },
                    |m: &mut PersistResponse| { &mut m.errors },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistResponse>(
                    "PersistResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PersistResponse {
        static mut instance: ::protobuf::lazy::Lazy<PersistResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistResponse,
        };
        unsafe {
            instance.get(PersistResponse::new)
        }
    }
}

impl ::protobuf::Clear for PersistResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum P2PREQTYPE {
    CLOSE = 0,
    FORWARD = 1,
    LISTEN = 2,
    LS = 3,
}

impl ::protobuf::ProtobufEnum for P2PREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<P2PREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(P2PREQTYPE::CLOSE),
            1 => ::std::option::Option::Some(P2PREQTYPE::FORWARD),
            2 => ::std::option::Option::Some(P2PREQTYPE::LISTEN),
            3 => ::std::option::Option::Some(P2PREQTYPE::LS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [P2PREQTYPE] = &[
            P2PREQTYPE::CLOSE,
            P2PREQTYPE::FORWARD,
            P2PREQTYPE::LISTEN,
            P2PREQTYPE::LS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("P2PREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for P2PREQTYPE {
}

impl ::std::default::Default for P2PREQTYPE {
    fn default() -> Self {
        P2PREQTYPE::CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CONNMGMTREQTYPE {
    CM_CONNECT = 0,
    CM_DISCONNECT = 1,
    CM_STATUS = 2,
    CM_GET_PEERS = 3,
}

impl ::protobuf::ProtobufEnum for CONNMGMTREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CONNMGMTREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_CONNECT),
            1 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_DISCONNECT),
            2 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_STATUS),
            3 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_GET_PEERS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CONNMGMTREQTYPE] = &[
            CONNMGMTREQTYPE::CM_CONNECT,
            CONNMGMTREQTYPE::CM_DISCONNECT,
            CONNMGMTREQTYPE::CM_STATUS,
            CONNMGMTREQTYPE::CM_GET_PEERS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CONNMGMTREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CONNMGMTREQTYPE {
}

impl ::std::default::Default for CONNMGMTREQTYPE {
    fn default() -> Self {
        CONNMGMTREQTYPE::CM_CONNECT
    }
}

impl ::protobuf::reflect::ProtobufValue for CONNMGMTREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASREQTYPE {
    EX_ENABLE = 0,
    EX_DISABLE = 1,
}

impl ::protobuf::ProtobufEnum for EXTRASREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASREQTYPE::EX_ENABLE),
            1 => ::std::option::Option::Some(EXTRASREQTYPE::EX_DISABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASREQTYPE] = &[
            EXTRASREQTYPE::EX_ENABLE,
            EXTRASREQTYPE::EX_DISABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EXTRASREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EXTRASREQTYPE {
}

impl ::std::default::Default for EXTRASREQTYPE {
    fn default() -> Self {
        EXTRASREQTYPE::EX_ENABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASTYPE {
    IDENTIFY = 0,
    PUBSUB = 1,
    DISCOVERY = 2,
    MDNS = 3,
}

impl ::protobuf::ProtobufEnum for EXTRASTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASTYPE::IDENTIFY),
            1 => ::std::option::Option::Some(EXTRASTYPE::PUBSUB),
            2 => ::std::option::Option::Some(EXTRASTYPE::DISCOVERY),
            3 => ::std::option::Option::Some(EXTRASTYPE::MDNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASTYPE] = &[
            EXTRASTYPE::IDENTIFY,
            EXTRASTYPE::PUBSUB,
            EXTRASTYPE::DISCOVERY,
            EXTRASTYPE::MDNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EXTRASTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EXTRASTYPE {
}

impl ::std::default::Default for EXTRASTYPE {
    fn default() -> Self {
        EXTRASTYPE::IDENTIFY
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQTYPE {
    BS_DELETE = 0,
    BS_PUT = 1,
    BS_PUT_MANY = 2,
    BS_GET = 3,
    BS_GET_MANY = 4,
    BS_GET_ALL = 5,
    BS_GET_STATS = 6,
}

impl ::protobuf::ProtobufEnum for BSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(BSREQTYPE::BS_DELETE),
            1 => ::std::option::Option::Some(BSREQTYPE::BS_PUT),
            2 => ::std::option::Option::Some(BSREQTYPE::BS_PUT_MANY),
            3 => ::std::option::Option::Some(BSREQTYPE::BS_GET),
            4 => ::std::option::Option::Some(BSREQTYPE::BS_GET_MANY),
            5 => ::std::option::Option::Some(BSREQTYPE::BS_GET_ALL),
            6 => ::std::option::Option::Some(BSREQTYPE::BS_GET_STATS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQTYPE] = &[
            BSREQTYPE::BS_DELETE,
            BSREQTYPE::BS_PUT,
            BSREQTYPE::BS_PUT_MANY,
            BSREQTYPE::BS_GET,
            BSREQTYPE::BS_GET_MANY,
            BSREQTYPE::BS_GET_ALL,
            BSREQTYPE::BS_GET_STATS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BSREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BSREQTYPE {
}

impl ::std::default::Default for BSREQTYPE {
    fn default() -> Self {
        BSREQTYPE::BS_DELETE
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQOPTS {
    DEFAULT = 0,
    BS_FORCE = 1,
}

impl ::protobuf::ProtobufEnum for BSREQOPTS {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQOPTS> {
        match value {
            0 => ::std::option::Option::Some(BSREQOPTS::DEFAULT),
            1 => ::std::option::Option::Some(BSREQOPTS::BS_FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQOPTS] = &[
            BSREQOPTS::DEFAULT,
            BSREQOPTS::BS_FORCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BSREQOPTS", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BSREQOPTS {
}

impl ::std::default::Default for BSREQOPTS {
    fn default() -> Self {
        BSREQOPTS::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQOPTS {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DAGREQTYPE {
    DAG_PUT = 0,
    DAG_GET = 1,
    DAG_NEW_NODE = 2,
    DAG_ADD_LINKS = 3,
    DAG_GET_LINKS = 4,
    DAG_STAT = 5,
}

impl ::protobuf::ProtobufEnum for DAGREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DAGREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(DAGREQTYPE::DAG_PUT),
            1 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET),
            2 => ::std::option::Option::Some(DAGREQTYPE::DAG_NEW_NODE),
            3 => ::std::option::Option::Some(DAGREQTYPE::DAG_ADD_LINKS),
            4 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET_LINKS),
            5 => ::std::option::Option::Some(DAGREQTYPE::DAG_STAT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DAGREQTYPE] = &[
            DAGREQTYPE::DAG_PUT,
            DAGREQTYPE::DAG_GET,
            DAGREQTYPE::DAG_NEW_NODE,
            DAGREQTYPE::DAG_ADD_LINKS,
            DAGREQTYPE::DAG_GET_LINKS,
            DAGREQTYPE::DAG_STAT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DAGREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DAGREQTYPE {
}

impl ::std::default::Default for DAGREQTYPE {
    fn default() -> Self {
        DAGREQTYPE::DAG_PUT
    }
}

impl ::protobuf::reflect::ProtobufValue for DAGREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KSREQTYPE {
    KS_HAS = 0,
    KS_GET = 1,
    KS_PUT = 2,
    KS_DELETE = 3,
    KS_LIST = 4,
}

impl ::protobuf::ProtobufEnum for KSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(KSREQTYPE::KS_HAS),
            1 => ::std::option::Option::Some(KSREQTYPE::KS_GET),
            2 => ::std::option::Option::Some(KSREQTYPE::KS_PUT),
            3 => ::std::option::Option::Some(KSREQTYPE::KS_DELETE),
            4 => ::std::option::Option::Some(KSREQTYPE::KS_LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KSREQTYPE] = &[
            KSREQTYPE::KS_HAS,
            KSREQTYPE::KS_GET,
            KSREQTYPE::KS_PUT,
            KSREQTYPE::KS_DELETE,
            KSREQTYPE::KS_LIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("KSREQTYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for KSREQTYPE {
}

impl ::std::default::Default for KSREQTYPE {
    fn default() -> Self {
        KSREQTYPE::KS_HAS
    }
}

impl ::protobuf::reflect::ProtobufValue for KSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nnode.proto\x12\x02pb\x1a\nutil.proto\"\xd8\x02\n\nP2PRequest\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\x12\x18\n\x07verbose\x18\
    \x03\x20\x01(\x08R\x07verbose\x12\"\n\x0cprotocolName\x18\x04\x20\x01(\t\
    R\x0cprotocolName\x12$\n\rlistenAddress\x18\x05\x20\x01(\tR\rlistenAddre\
    ss\x12$\n\rtargetAddress\x18\x06\x20\x01(\tR\rtargetAddress\x12$\n\rremo\
    teAddress\x18\x07\x20\x01(\tR\rremoteAddress\x122\n\x14allowCustomProtoc\
    ols\x18\x08\x20\x01(\x08R\x14allowCustomProtocols\x12\"\n\x0creportPeerI\
    D\x18\t\x20\x01(\x08R\x0creportPeerID\"\xa8\x01\n\x0bP2PResponse\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05names\x12\x20\n\x0bconnsClose\
    d\x18\x03\x20\x01(\x05R\x0bconnsClosed\x12/\n\x0bstreamInfos\x18\x04\x20\
    \x03(\x0b2\r.pb.P2PLsInfoR\x0bstreamInfos\"\x91\x01\n\tP2PLsInfo\x12\"\n\
    \x0cprotocolName\x18\x01\x20\x01(\tR\x0cprotocolName\x12$\n\rlistenAddre\
    ss\x18\x02\x20\x01(\tR\rlistenAddress\x12$\n\rtargetAddress\x18\x03\x20\
    \x01(\tR\rtargetAddress\x12\x14\n\x05local\x18\x04\x20\x01(\x08R\x05loca\
    l\",\n\x10GetPeersResponse\x12\x18\n\x07peerIDs\x18\x01\x20\x03(\tR\x07p\
    eerIDs\"\x82\x01\n\x0fConnMgmtRequest\x125\n\x0brequestType\x18\x01\x20\
    \x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12\x1e\n\nmultiAddrs\
    \x18\x02\x20\x03(\tR\nmultiAddrs\x12\x18\n\x07peerIDs\x18\x03\x20\x03(\t\
    R\x07peerIDs\"\xed\x02\n\x10ConnMgmtResponse\x125\n\x0brequestType\x18\
    \x01\x20\x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12A\n\tconnec\
    ted\x18\x02\x20\x03(\x0b2#.pb.ConnMgmtResponse.ConnectedEntryR\tconnecte\
    d\x128\n\x06status\x18\x03\x20\x03(\x0b2\x20.pb.ConnMgmtResponse.StatusE\
    ntryR\x06status\x12\x18\n\x07peerIDs\x18\x04\x20\x03(\tR\x07peerIDs\x1a<\
    \n\x0eConnectedEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1aM\n\x0bStatusEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12(\n\x05value\x18\x02\
    \x20\x01(\x0b2\x12.pb.ConnMgmtStatusR\x05value:\x028\x01\"L\n\x0eConnMgm\
    tStatus\x12\"\n\x0cdisconnected\x18\x01\x20\x01(\x08R\x0cdisconnected\
    \x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reason\"z\n\rExtrasRequest\
    \x123\n\x0brequestType\x18\x01\x20\x01(\x0e2\x11.pb.EXTRASREQTYPER\x0bre\
    questType\x124\n\rextrasFeature\x18\x02\x20\x01(\x0e2\x0e.pb.EXTRASTYPER\
    \rextrasFeature\"\xd1\x01\n\x11BlockstoreRequest\x12/\n\x0brequestType\
    \x18\x01\x20\x01(\x0e2\r.pb.BSREQTYPER\x0brequestType\x12'\n\x07reqOpts\
    \x18\x02\x20\x03(\x0e2\r.pb.BSREQOPTSR\x07reqOpts\x12\x12\n\x04cids\x18\
    \x03\x20\x03(\tR\x04cids\x12\x12\n\x04data\x18\x04\x20\x03(\x0cR\x04data\
    \x12\x1e\n\ncidVersion\x18\x05\x20\x01(\tR\ncidVersion\x12\x1a\n\x08hash\
    Func\x18\x07\x20\x01(\tR\x08hashFunc\"h\n\x12BlockstoreResponse\x12/\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\r.pb.BSREQTYPER\x0brequestType\x12\
    !\n\x06blocks\x18\x02\x20\x03(\x0b2\t.pb.BlockR\x06blocks\"A\n\x05Block\
    \x12\x10\n\x03cid\x18\x01\x20\x01(\tR\x03cid\x12\x12\n\x04data\x18\x02\
    \x20\x01(\x0cR\x04data\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\x04size\"\
    \xe7\x02\n\nDagRequest\x120\n\x0brequestType\x18\x01\x20\x01(\x0e2\x0e.p\
    b.DAGREQTYPER\x0brequestType\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04\
    data\x12&\n\x0eobjectEncoding\x18\x03\x20\x01(\tR\x0eobjectEncoding\x120\
    \n\x13serializationFormat\x18\x04\x20\x01(\tR\x13serializationFormat\x12\
    \x1a\n\x08hashFunc\x18\x05\x20\x01(\tR\x08hashFunc\x12\x1e\n\ncidVersion\
    \x18\x06\x20\x01(\x03R\ncidVersion\x12\x12\n\x04hash\x18\x07\x20\x01(\tR\
    \x04hash\x12/\n\x05links\x18\x08\x20\x03(\x0b2\x19.pb.DagRequest.LinksEn\
    tryR\x05links\x1a8\n\nLinksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x9f\
    \x02\n\x0bDagResponse\x120\n\x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb\
    .DAGREQTYPER\x0brequestType\x12\x16\n\x06hashes\x18\x02\x20\x03(\tR\x06h\
    ashes\x12\x18\n\x07rawData\x18\x03\x20\x01(\x0cR\x07rawData\x12\"\n\x05l\
    inks\x18\x04\x20\x03(\x0b2\x0c.pb.IPLDLinkR\x05links\x12<\n\tnodeStats\
    \x18\x05\x20\x03(\x0b2\x1e.pb.DagResponse.NodeStatsEntryR\tnodeStats\x1a\
    J\n\x0eNodeStatsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\"\
    \n\x05value\x18\x02\x20\x01(\x0b2\x0c.pb.IPLDStatR\x05value:\x028\x01\"\
    \xa4\x01\n\x08IPLDStat\x12\x1a\n\x08numLinks\x18\x01\x20\x01(\x03R\x08nu\
    mLinks\x12\x1c\n\tblockSize\x18\x02\x20\x01(\x03R\tblockSize\x12\x1a\n\
    \x08linkSize\x18\x03\x20\x01(\x03R\x08linkSize\x12&\n\x0ecumulativeSize\
    \x18\x04\x20\x01(\x03R\x0ecumulativeSize\x12\x1a\n\x08dataSize\x18\x05\
    \x20\x01(\x03R\x08dataSize\"F\n\x08IPLDLink\x12\x12\n\x04hash\x18\x01\
    \x20\x01(\x0cR\x04hash\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x12\n\x04size\x18\x03\x20\x01(\x04R\x04size\"B\n\x08IPLDNode\x12\"\n\
    \x05links\x18\x02\x20\x03(\x0b2\x0c.pb.IPLDLinkR\x05links\x12\x12\n\x04d\
    ata\x18\x01\x20\x01(\x0cR\x04data\"v\n\x0fKeystoreRequest\x12/\n\x0brequ\
    estType\x18\x01\x20\x01(\x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\nprivateKey\x18\x03\x20\
    \x01(\x0cR\nprivateKey\"\x91\x01\n\x10KeystoreResponse\x12/\n\x0brequest\
    Type\x18\x01\x20\x01(\x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x1e\n\npri\
    vateKey\x18\x02\x20\x01(\x0cR\nprivateKey\x12\x1a\n\x08keyNames\x18\x03\
    \x20\x03(\tR\x08keyNames\x12\x10\n\x03has\x18\x04\x20\x01(\x08R\x03has\"\
    $\n\x0ePersistRequest\x12\x12\n\x04cids\x18\x01\x20\x03(\tR\x04cids\"\
    \xf9\x01\n\x0fPersistResponse\x127\n\x06status\x18\x01\x20\x03(\x0b2\x1f\
    .pb.PersistResponse.StatusEntryR\x06status\x127\n\x06errors\x18\x02\x20\
    \x03(\x0b2\x1f.pb.PersistResponse.ErrorsEntryR\x06errors\x1a9\n\x0bStatu\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1a9\n\x0bErrorsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01*8\n\nP2PREQTYPE\x12\t\n\x05CLOSE\x10\0\x12\x0b\n\
    \x07FORWARD\x10\x01\x12\n\n\x06LISTEN\x10\x02\x12\x06\n\x02LS\x10\x03*U\
    \n\x0fCONNMGMTREQTYPE\x12\x0e\n\nCM_CONNECT\x10\0\x12\x11\n\rCM_DISCONNE\
    CT\x10\x01\x12\r\n\tCM_STATUS\x10\x02\x12\x10\n\x0cCM_GET_PEERS\x10\x03*\
    .\n\rEXTRASREQTYPE\x12\r\n\tEX_ENABLE\x10\0\x12\x0e\n\nEX_DISABLE\x10\
    \x01*?\n\nEXTRASTYPE\x12\x0c\n\x08IDENTIFY\x10\0\x12\n\n\x06PUBSUB\x10\
    \x01\x12\r\n\tDISCOVERY\x10\x02\x12\x08\n\x04MDNS\x10\x03*v\n\tBSREQTYPE\
    \x12\r\n\tBS_DELETE\x10\0\x12\n\n\x06BS_PUT\x10\x01\x12\x0f\n\x0bBS_PUT_\
    MANY\x10\x02\x12\n\n\x06BS_GET\x10\x03\x12\x0f\n\x0bBS_GET_MANY\x10\x04\
    \x12\x0e\n\nBS_GET_ALL\x10\x05\x12\x10\n\x0cBS_GET_STATS\x10\x06*&\n\tBS\
    REQOPTS\x12\x0b\n\x07DEFAULT\x10\0\x12\x0c\n\x08BS_FORCE\x10\x01*l\n\nDA\
    GREQTYPE\x12\x0b\n\x07DAG_PUT\x10\0\x12\x0b\n\x07DAG_GET\x10\x01\x12\x10\
    \n\x0cDAG_NEW_NODE\x10\x02\x12\x11\n\rDAG_ADD_LINKS\x10\x03\x12\x11\n\rD\
    AG_GET_LINKS\x10\x04\x12\x0c\n\x08DAG_STAT\x10\x05*K\n\tKSREQTYPE\x12\n\
    \n\x06KS_HAS\x10\0\x12\n\n\x06KS_GET\x10\x01\x12\n\n\x06KS_PUT\x10\x02\
    \x12\r\n\tKS_DELETE\x10\x03\x12\x0b\n\x07KS_LIST\x10\x042\xb7\x03\n\x07N\
    odeAPI\x127\n\x08ConnMgmt\x12\x13.pb.ConnMgmtRequest\x1a\x14.pb.ConnMgmt\
    Response\"\0\x12(\n\x06Extras\x12\x11.pb.ExtrasRequest\x1a\t.pb.Empty\"\
    \0\x12(\n\x03P2P\x12\x0e.pb.P2PRequest\x1a\x0f.pb.P2PResponse\"\0\x12=\n\
    \nBlockstore\x12\x15.pb.BlockstoreRequest\x1a\x16.pb.BlockstoreResponse\
    \"\0\x12G\n\x10BlockstoreStream\x12\x15.pb.BlockstoreRequest\x1a\x16.pb.\
    BlockstoreResponse\"\0(\x010\x01\x12(\n\x03Dag\x12\x0e.pb.DagRequest\x1a\
    \x0f.pb.DagResponse\"\0\x127\n\x08Keystore\x12\x13.pb.KeystoreRequest\
    \x1a\x14.pb.KeystoreResponse\"\0\x124\n\x07Persist\x12\x12.pb.PersistReq\
    uest\x1a\x13.pb.PersistResponse\"\0J\xe4\x80\x01\n\x07\x12\x05\0\0\xfc\
    \x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\x08\
    \n\n\t\n\x02\x03\0\x12\x03\x02\x07\x13\nO\n\x02\x06\0\x12\x04\x05\0\x19\
    \x01\x1aC\x20NodeAPI\x20provide\x20an\x20API\x20to\x20control\x20the\x20\
    underlying\x20custom\x20ipfs\x20node\n\n\n\n\x03\x06\0\x01\x12\x03\x05\
    \x08\x0f\n@\n\x04\x06\0\x02\0\x12\x03\x07\x04@\x1a3\x20ConnMgmt\x20provi\
    des\x20control\x20over\x20libp2p\x20connections\n\n\x0c\n\x05\x06\0\x02\
    \0\x01\x12\x03\x07\x08\x10\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x07\x11\
    \x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x07+;\nC\n\x04\x06\0\x02\x01\
    \x12\x03\t\x041\x1a6\x20Extras\x20provide\x20control\x20over\x20node\x20\
    extras\x20capabilities\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\t\x08\x0e\
    \n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\t\x0f\x1c\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\t',\n\xdf\x01\n\x04\x06\0\x02\x02\x12\x03\r\x041\x1a\
    \xd1\x01\x20P2P\x20allows\x20control\x20of\x20generalized\x20p2p\x20stre\
    ams\x20for\x20tcp/udp\x20based\x20protocol.\n\x20By\x20using\x20this\x20\
    RPC,\x20we\x20can\x20tunnel\x20traffic\x20similar\x20to\x20ssh\x20tunnel\
    ing\n\x20except\x20using\x20libp2p\x20as\x20the\x20transport\x20layer,\
    \x20and\x20and\x20tcp/udp\x20port.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\
    \x03\r\x08\x0b\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\r\x0c\x16\n\x0c\n\
    \x05\x06\0\x02\x02\x03\x12\x03\r!,\nR\n\x04\x06\0\x02\x03\x12\x03\x0f\
    \x04F\x1aE\x20Blockstore\x20allows\x20low-level\x20management\x20of\x20t\
    he\x20underlying\x20blockstore\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\
    \x0f\x08\x12\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x0f\x13$\n\x0c\n\x05\
    \x06\0\x02\x03\x03\x12\x03\x0f/A\n\x87\x01\n\x04\x06\0\x02\x04\x12\x03\
    \x12\x04Z\x1az\x20BlockstoreStream\x20is\x20akin\x20to\x20Blockstore,\
    \x20except\x20streamable\n\x20Once\x20v4\x20is\x20out,\x20condense\x20th\
    is\x20+\x20blockstore\x20into\x20a\x20single\x20call\n\n\x0c\n\x05\x06\0\
    \x02\x04\x01\x12\x03\x12\x08\x18\n\x0c\n\x05\x06\0\x02\x04\x05\x12\x03\
    \x12\x19\x1f\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x12\x201\n\x0c\n\x05\
    \x06\0\x02\x04\x06\x12\x03\x12<B\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\
    \x12CU\nZ\n\x04\x06\0\x02\x05\x12\x03\x14\x041\x1aM\x20Dag\x20is\x20a\
    \x20unidirectional\x20rpc\x20allowing\x20manipulation\x20of\x20low-level\
    \x20ipld\x20objects\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x14\x08\x0b\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x14\x0c\x16\n\x0c\n\x05\x06\0\x02\
    \x05\x03\x12\x03\x14!,\nU\n\x04\x06\0\x02\x06\x12\x03\x16\x04@\x1aH\x20K\
    eystore\x20is\x20a\x20unidirectional\x20RPC\x20allowing\x20management\
    \x20of\x20ipfs\x20keystores\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03\x16\
    \x08\x10\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\x16\x11\x20\n\x0c\n\x05\
    \x06\0\x02\x06\x03\x12\x03\x16+;\n^\n\x04\x06\0\x02\x07\x12\x03\x18\x04=\
    \x1aQ\x20Persist\x20is\x20used\x20to\x20retrieve\x20data\x20from\x20the\
    \x20network\x20and\x20make\x20it\x20available\x20locally\n\n\x0c\n\x05\
    \x06\0\x02\x07\x01\x12\x03\x18\x08\x0f\n\x0c\n\x05\x06\0\x02\x07\x02\x12\
    \x03\x18\x10\x1e\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\x18)8\nY\n\x02\
    \x05\0\x12\x04\x1c\0%\x01\x1aM\x20P2PREQTYPE\x20denotes\x20the\x20partic\
    ular\x20type\x20of\x20request\x20being\x20used\x20in\x20the\x20p2p\x20rp\
    c\n\n\n\n\x03\x05\0\x01\x12\x03\x1c\x05\x0f\n+\n\x04\x05\0\x02\0\x12\x03\
    \x1e\x04\x0e\x1a\x1e\x20equivalent\x20of\x20ipfs\x20p2p\x20close\n\n\x0c\
    \n\x05\x05\0\x02\0\x01\x12\x03\x1e\x04\t\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x1e\x0c\r\n-\n\x04\x05\0\x02\x01\x12\x03\x20\x04\x10\x1a\x20\x20equ\
    ivalent\x20of\x20ipfs\x20p2p\x20forward\n\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03\x20\x04\x0b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x20\x0e\x0f\n\
    ,\n\x04\x05\0\x02\x02\x12\x03\"\x04\x0f\x1a\x1f\x20equivalent\x20of\x20i\
    pfs\x20p2p\x20listen\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\"\x04\n\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x03\"\r\x0e\n(\n\x04\x05\0\x02\x03\x12\
    \x03$\x04\x0b\x1a\x1b\x20equivalent\x20of\x20ipfs\x20p2p\x20ls\n\n\x0c\n\
    \x05\x05\0\x02\x03\x01\x12\x03$\x04\x06\n\x0c\n\x05\x05\0\x02\x03\x02\
    \x12\x03$\t\n\n^\n\x02\x04\0\x12\x04(\0>\x01\x1aR\x20P2PRequest\x20is\
    \x20a\x20request\x20message\x20holding\x20the\x20details\x20of\x20a\x20p\
    articular\x20P2P\x20rpc\x20call\n\n\n\n\x03\x04\0\x01\x12\x03(\x08\x12\n\
    )\n\x04\x04\0\x02\0\x12\x03*\x04\x1f\x1a\x1c\x20indicates\x20the\x20requ\
    est\x20type\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04*\x04(\x14\n\x0c\n\x05\
    \x04\0\x02\0\x06\x12\x03*\x04\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03*\
    \x0f\x1a\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03*\x1d\x1e\n(\n\x04\x04\0\x02\
    \x01\x12\x03,\x04\x11\x1a\x1b\x20used\x20by:\x20P2PREQTYPE.CLOSE\n\n\r\n\
    \x05\x04\0\x02\x01\x04\x12\x04,\x04*\x1f\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03,\x04\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03,\t\x0c\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03,\x0f\x10\n%\n\x04\x04\0\x02\x02\x12\x03.\
    \x04\x15\x1a\x18\x20used\x20by:\x20P2PREQTYPE.LS\n\n\r\n\x05\x04\0\x02\
    \x02\x04\x12\x04.\x04,\x11\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03.\x04\
    \x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03.\t\x10\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03.\x13\x14\nO\n\x04\x04\0\x02\x03\x12\x030\x04\x1c\x1aB\
    \x20used\x20by:\x20P2PREQTYPE.CLOSE,\x20P2PREQTYPE.FORWARD,\x20P2PREQTYP\
    E.LISTEN\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x040\x04.\x15\n\x0c\n\x05\x04\
    \0\x02\x03\x05\x12\x030\x04\n\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x030\x0b\
    \x17\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x030\x1a\x1b\n^\n\x04\x04\0\x02\
    \x04\x12\x033\x04\x1d\x1aQ\x20used\x20by:\x20P2PREQTYPE.CLOSE,\x20P2PREQ\
    TYPE.FORWARD\n\x20must\x20be\x20specified\x20as\x20a\x20multiaddr\n\n\r\
    \n\x05\x04\0\x02\x04\x04\x12\x043\x040\x1c\n\x0c\n\x05\x04\0\x02\x04\x05\
    \x12\x033\x04\n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x033\x0b\x18\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x033\x1b\x1c\n^\n\x04\x04\0\x02\x05\x12\x036\
    \x04\x1d\x1aQ\x20used\x20by:\x20P2PREQTYPE.CLOSE,\x20P2PREQTYPE.FORWARD\
    \n\x20must\x20be\x20specified\x20as\x20a\x20multiaddr\n\n\r\n\x05\x04\0\
    \x02\x05\x04\x12\x046\x043\x1d\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x036\
    \x04\n\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x036\x0b\x18\n\x0c\n\x05\x04\0\
    \x02\x05\x03\x12\x036\x1b\x1c\nK\n\x04\x04\0\x02\x06\x12\x039\x04\x1d\
    \x1a>\x20used\x20by:\x20P2PREQTYPE.LISTEN\n\x20must\x20be\x20specified\
    \x20as\x20a\x20multiaddr\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x049\x046\x1d\
    \n\x0c\n\x05\x04\0\x02\x06\x05\x12\x039\x04\n\n\x0c\n\x05\x04\0\x02\x06\
    \x01\x12\x039\x0b\x18\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x039\x1b\x1c\n=\
    \n\x04\x04\0\x02\x07\x12\x03;\x04\"\x1a0\x20used\x20by:\x20P2PREQTYPE.LI\
    STEN,\x20P2PREQTYPE.FORWARD\n\n\r\n\x05\x04\0\x02\x07\x04\x12\x04;\x049\
    \x1d\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03;\x04\x08\n\x0c\n\x05\x04\0\
    \x02\x07\x01\x12\x03;\t\x1d\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03;\x20!\
    \n)\n\x04\x04\0\x02\x08\x12\x03=\x04\x1a\x1a\x1c\x20used\x20by:\x20P2PRE\
    QTYPE.LISTEN\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x04=\x04;\"\n\x0c\n\x05\
    \x04\0\x02\x08\x05\x12\x03=\x04\x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\
    \x03=\t\x15\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03=\x18\x19\nX\n\x02\x04\
    \x01\x12\x04A\0I\x01\x1aL\x20P2PResponse\x20is\x20a\x20response\x20messa\
    ge\x20sent\x20in\x20response\x20to\x20a\x20P2PRequest\x20message\n\n\n\n\
    \x03\x04\x01\x01\x12\x03A\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\x03B\x04\
    \x1f\n\r\n\x05\x04\x01\x02\0\x04\x12\x04B\x04A\x15\n\x0c\n\x05\x04\x01\
    \x02\0\x06\x12\x03B\x04\x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03B\x0f\
    \x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03B\x1d\x1e\n)\n\x04\x04\x01\x02\
    \x01\x12\x03D\x04\x1e\x1a\x1c\x20sent\x20by:\x20P2PREQTYPE.LISTEN\n\n\
    \x0c\n\x05\x04\x01\x02\x01\x04\x12\x03D\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03D\r\x13\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03D\x14\x19\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03D\x1c\x1d\nU\n\x04\x04\x01\x02\
    \x02\x12\x03F\x04\x1a\x1aH\x20sent\x20by:\x20P2PREQTYPE.CLOSE\x20to\x20i\
    ndicate\x20the\x20number\x20of\x20connections\x20closed\n\n\r\n\x05\x04\
    \x01\x02\x02\x04\x12\x04F\x04D\x1e\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x03F\x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03F\n\x15\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03F\x18\x19\nO\n\x04\x04\x01\x02\x03\x12\x03H\
    \x04'\x1aB\x20sent\x20by:\x20P2PREQTYPE.LS\x20and\x20contains\x20all\x20\
    known\x20stream\x20information\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\
    H\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03H\r\x16\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03H\x17\"\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03H\
    %&\nF\n\x02\x04\x02\x12\x04L\0R\x01\x1a:\x20P2PLsInfo\x20contains\x20inf\
    ormation\x20about\x20a\x20single\x20p2p\x20stream\n\n\n\n\x03\x04\x02\
    \x01\x12\x03L\x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\x03M\x04\x1c\n\r\n\
    \x05\x04\x02\x02\0\x04\x12\x04M\x04L\x13\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03M\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03M\x0b\x17\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03M\x1a\x1b\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03N\x04\x1d\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04N\x04M\x1c\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03N\x04\n\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03N\x0b\x18\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03N\x1b\x1c\n\x0b\
    \n\x04\x04\x02\x02\x02\x12\x03O\x04\x1d\n\r\n\x05\x04\x02\x02\x02\x04\
    \x12\x04O\x04N\x1d\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03O\x04\n\n\x0c\
    \n\x05\x04\x02\x02\x02\x01\x12\x03O\x0b\x18\n\x0c\n\x05\x04\x02\x02\x02\
    \x03\x12\x03O\x1b\x1c\nP\n\x04\x04\x02\x02\x03\x12\x03Q\x04\x13\x1aC\x20\
    indicates\x20whether\x20or\x20not\x20this\x20is\x20a\x20p2p\x20listener\
    \x20or\x20local\x20listener\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04Q\x04\
    O\x1d\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03Q\x04\x08\n\x0c\n\x05\x04\
    \x02\x02\x03\x01\x12\x03Q\t\x0e\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03Q\
    \x11\x12\nW\n\x02\x04\x03\x12\x04U\0X\x01\x1aK\x20GetPeersResponse\x20is\
    \x20a\x20response\x20to\x20GetPeers\x20containing\x20a\x20slice\x20of\
    \x20peer\x20IDs\n\n\n\n\x03\x04\x03\x01\x12\x03U\x08\x18\n\"\n\x04\x04\
    \x03\x02\0\x12\x03W\x04\x20\x1a\x15\x20a\x20slice\x20of\x20peer\x20IDs\n\
    \n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03W\x04\x0c\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x03W\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03W\x14\x1b\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03W\x1e\x1f\nW\n\x02\x05\x01\x12\x04[\
    \0e\x01\x1aK\x20CONNMGMTREQTYPE\x20indicates\x20the\x20particular\x20Con\
    nMgmt\x20request\x20being\x20performed\n\n\n\n\x03\x05\x01\x01\x12\x03[\
    \x05\x14\n=\n\x04\x05\x01\x02\0\x12\x03]\x04\x13\x1a0\x20CM_CONNECT\x20i\
    s\x20used\x20to\x20connect\x20to\x20a\x20libp2p\x20peer\n\n\x0c\n\x05\
    \x05\x01\x02\0\x01\x12\x03]\x04\x0e\n\x0c\n\x05\x05\x01\x02\0\x02\x12\
    \x03]\x11\x12\nE\n\x04\x05\x01\x02\x01\x12\x03_\x04\x16\x1a8\x20CM_DISCO\
    NNECT\x20is\x20used\x20to\x20disconnect\x20from\x20a\x20libp2p\x20peer\n\
    \n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03_\x04\x11\n\x0c\n\x05\x05\x01\
    \x02\x01\x02\x12\x03_\x14\x15\n\x9f\x01\n\x04\x05\x01\x02\x02\x12\x03b\
    \x04\x12\x1a\x91\x01\x20CM_STATUS\x20is\x20used\x20to\x20return\x20statu\
    s\x20information\x20about\x20libp2p\x20peer\x20connections\n\x20useful\
    \x20for\x20determining\x20whether\x20or\x20not\x20we\x20are\x20connected\
    \x20to\x20someone\n\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03b\x04\r\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03b\x10\x11\n<\n\x04\x05\x01\x02\x03\x12\
    \x03d\x04\x15\x1a/CM_GET_PEERS\x20is\x20used\x20to\x20return\x20all\x20k\
    nown\x20peers\n\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03d\x04\x10\n\x0c\n\
    \x05\x05\x01\x02\x03\x02\x12\x03d\x13\x14\n\n\n\x02\x04\x04\x12\x04g\0p\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03g\x08\x17\nU\n\x04\x04\x04\x02\0\x12\
    \x03i\x04$\x1aH\x20indicates\x20the\x20particular\x20connection\x20manag\
    ement\x20request\x20being\x20performed\n\n\r\n\x05\x04\x04\x02\0\x04\x12\
    \x04i\x04g\x19\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03i\x04\x13\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03i\x14\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03i\"#\n8\n\x04\x04\x04\x02\x01\x12\x03l\x04#\x1a+\x20a\x20list\
    \x20of\x20multiaddrs\n\x20sent\x20by:\x20CM_CONNECT\n\n\x0c\n\x05\x04\
    \x04\x02\x01\x04\x12\x03l\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03l\r\x13\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03l\x14\x1e\n\x0c\n\x05\
    \x04\x04\x02\x01\x03\x12\x03l!\"\nR\n\x04\x04\x04\x02\x02\x12\x03o\x04\
    \x20\x1aE\x20a\x20list\x20of\x20peer\x20IDs\n\x20sent\x20by:\x20CM_DISCO\
    NNECT,\x20CM_STATUS,\x20CM_GET_PEERS\n\n\x0c\n\x05\x04\x04\x02\x02\x04\
    \x12\x03o\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03o\r\x13\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x03o\x14\x1b\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03o\x1e\x1f\n\n\n\x02\x04\x05\x12\x04r\0y\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03r\x08\x18\nU\n\x04\x04\x05\x02\0\x12\x03t\x04$\x1aH\x20i\
    ndicates\x20the\x20particular\x20connection\x20management\x20request\x20\
    being\x20performed\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04t\x04r\x1a\n\x0c\
    \n\x05\x04\x05\x02\0\x06\x12\x03t\x04\x13\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03t\x14\x1f\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03t\"#\n\x0b\n\x04\
    \x04\x05\x02\x01\x12\x03u\x04$\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04u\
    \x04t$\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03u\x04\x15\n\x0c\n\x05\x04\
    \x05\x02\x01\x01\x12\x03u\x16\x1f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x03u\"#\nh\n\x04\x04\x05\x02\x02\x12\x03w\x04+\x1a[\x20a\x20map\x20of\
    \x20the\x20peer\x20id,\x20and\x20a\x20custom\x20message\x20indicating\
    \x20success,\x20or\x20why\x20there\x20was\x20a\x20failure\n\n\r\n\x05\
    \x04\x05\x02\x02\x04\x12\x04w\x04u$\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\
    \x03w\x04\x1f\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03w\x20&\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x03w)*\n\x0b\n\x04\x04\x05\x02\x03\x12\x03x\x04\
    \x20\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03x\x04\x0c\n\x0c\n\x05\x04\
    \x05\x02\x03\x05\x12\x03x\r\x13\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03x\
    \x14\x1b\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03x\x1e\x1f\nP\n\x02\x04\
    \x06\x12\x05|\0\x81\x01\x01\x1aC\x20Contains\x20status\x20information\
    \x20about\x20a\x20particular\x20disconnect\x20attempt\n\n\n\n\x03\x04\
    \x06\x01\x12\x03|\x08\x16\n?\n\x04\x04\x06\x02\0\x12\x03~\x04\x1a\x1a2\
    \x20indicate\x20whether\x20or\x20not\x20we\x20actually\x20disconnected\n\
    \n\r\n\x05\x04\x06\x02\0\x04\x12\x04~\x04|\x18\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03~\x04\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03~\t\x15\n\x0c\
    \n\x05\x04\x06\x02\0\x03\x12\x03~\x18\x19\nD\n\x04\x04\x06\x02\x01\x12\
    \x04\x80\x01\x04\x16\x1a6\x20if\x20disconnected\x20is\x20false,\x20the\
    \x20reason\x20why\x20it\x20is\x20false\n\n\x0e\n\x05\x04\x06\x02\x01\x04\
    \x12\x05\x80\x01\x04~\x1a\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x80\x01\
    \x04\n\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x80\x01\x0b\x11\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\x80\x01\x14\x15\nU\n\x02\x05\x02\x12\x06\
    \x84\x01\0\x89\x01\x01\x1aG\x20EXTRASREQTYPE\x20indicates\x20the\x20part\
    icular\x20Extras\x20request\x20being\x20performed\n\n\x0b\n\x03\x05\x02\
    \x01\x12\x04\x84\x01\x05\x12\nL\n\x04\x05\x02\x02\0\x12\x04\x86\x01\x04\
    \x12\x1a>\x20EX_ENABLE\x20is\x20used\x20to\x20enable\x20a\x20particular\
    \x20node\x20extras\x20feature\n\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x86\
    \x01\x04\r\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\x86\x01\x10\x11\nN\n\x04\
    \x05\x02\x02\x01\x12\x04\x88\x01\x04\x13\x1a@\x20EX_DISABLE\x20is\x20use\
    d\x20to\x20disable\x20a\x20particular\x20node\x20extras\x20feature\n\n\r\
    \n\x05\x05\x02\x02\x01\x01\x12\x04\x88\x01\x04\x0e\n\r\n\x05\x05\x02\x02\
    \x01\x02\x12\x04\x88\x01\x11\x12\n;\n\x02\x05\x03\x12\x06\x8c\x01\0\x95\
    \x01\x01\x1a-\x20EXTRASTYPE\x20denotes\x20a\x20particular\x20extras\x20t\
    ype\n\n\x0b\n\x03\x05\x03\x01\x12\x04\x8c\x01\x05\x0f\n0\n\x04\x05\x03\
    \x02\0\x12\x04\x8e\x01\x04\x11\x1a\"\x20IDENTIFY\x20is\x20the\x20identif\
    y\x20service\n\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x8e\x01\x04\x0c\n\r\n\
    \x05\x05\x03\x02\0\x02\x12\x04\x8e\x01\x0f\x10\n2\n\x04\x05\x03\x02\x01\
    \x12\x04\x90\x01\x04\x0f\x1a$\x20PUBSUB\x20is\x20the\x20libp2p\x20pubsub\
    \x20system\n\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\x90\x01\x04\n\n\r\n\
    \x05\x05\x03\x02\x01\x02\x12\x04\x90\x01\r\x0e\n7\n\x04\x05\x03\x02\x02\
    \x12\x04\x92\x01\x04\x12\x1a)\x20DISCOVERY\x20is\x20a\x20libp2p\x20disco\
    very\x20service\n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\x92\x01\x04\r\n\
    \r\n\x05\x05\x03\x02\x02\x02\x12\x04\x92\x01\x10\x11\n?\n\x04\x05\x03\
    \x02\x03\x12\x04\x94\x01\x04\r\x1a1\x20MDNS\x20is\x20used\x20to\x20disco\
    ver\x20libp2p\x20hosts\x20over\x20mdns\n\n\r\n\x05\x05\x03\x02\x03\x01\
    \x12\x04\x94\x01\x04\x08\n\r\n\x05\x05\x03\x02\x03\x02\x12\x04\x94\x01\
    \x0b\x0c\n\x0c\n\x02\x04\x07\x12\x06\x97\x01\0\x9c\x01\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x97\x01\x08\x15\n5\n\x04\x04\x07\x02\0\x12\x04\x99\
    \x01\x04\"\x1a'\x20indicates\x20the\x20request\x20being\x20performed\n\n\
    \x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x99\x01\x04\x97\x01\x17\n\r\n\x05\
    \x04\x07\x02\0\x06\x12\x04\x99\x01\x04\x11\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\x99\x01\x12\x1d\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x99\x01\x20\
    !\nD\n\x04\x04\x07\x02\x01\x12\x04\x9b\x01\x04!\x1a6\x20indicates\x20the\
    \x20extras\x20feature\x20this\x20request\x20applies\x20to\n\n\x0f\n\x05\
    \x04\x07\x02\x01\x04\x12\x06\x9b\x01\x04\x99\x01\"\n\r\n\x05\x04\x07\x02\
    \x01\x06\x12\x04\x9b\x01\x04\x0e\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\
    \x9b\x01\x0f\x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9b\x01\x1f\x20\n\
    A\n\x02\x05\x04\x12\x06\xa0\x01\0\xb0\x01\x01\x1a3\x20BSREQTYPE\x20is\
    \x20a\x20particular\x20blockstore\x20request\x20type\n\n\x0b\n\x03\x05\
    \x04\x01\x12\x04\xa0\x01\x05\x0e\nB\n\x04\x05\x04\x02\0\x12\x04\xa2\x01\
    \x04\x12\x1a4\x20BS_DELETE\x20is\x20used\x20to\x20delete\x20a\x20block\
    \x20from\x20the\x20store\n\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xa2\x01\
    \x04\r\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xa2\x01\x10\x11\nA\n\x04\x05\
    \x04\x02\x01\x12\x04\xa4\x01\x04\x0f\x1a3\x20BS_PUT\x20is\x20used\x20to\
    \x20put\x20a\x20single\x20block\x20in\x20the\x20store\n\n\r\n\x05\x05\
    \x04\x02\x01\x01\x12\x04\xa4\x01\x04\n\n\r\n\x05\x05\x04\x02\x01\x02\x12\
    \x04\xa4\x01\r\x0e\nC\n\x04\x05\x04\x02\x02\x12\x04\xa6\x01\x04\x14\x1a5\
    \x20BS_PUT_MANY\x20is\x20used\x20to\x20put\x20many\x20blocks\x20in\x20th\
    e\x20store\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xa6\x01\x04\x0f\n\r\n\
    \x05\x05\x04\x02\x02\x02\x12\x04\xa6\x01\x12\x13\n<\n\x04\x05\x04\x02\
    \x03\x12\x04\xa8\x01\x04\x0f\x1a.\x20BS_GET\x20is\x20used\x20to\x20get\
    \x20a\x20block\x20from\x20the\x20store\n\n\r\n\x05\x05\x04\x02\x03\x01\
    \x12\x04\xa8\x01\x04\n\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xa8\x01\r\
    \x0e\nE\n\x04\x05\x04\x02\x04\x12\x04\xaa\x01\x04\x14\x1a7\x20BS_GET_MAN\
    Y\x20is\x20used\x20to\x20get\x20many\x20blocks\x20from\x20the\x20store\n\
    \n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xaa\x01\x04\x0f\n\r\n\x05\x05\x04\
    \x02\x04\x02\x12\x04\xaa\x01\x12\x13\n~\n\x04\x05\x04\x02\x05\x12\x04\
    \xad\x01\x04\x13\x1ap\x20BS_GET_ALL\x20is\x20used\x20to\x20retrieve\x20a\
    ll\x20blocks\x20from\x20the\x20store\n\x20It\x20is\x20the\x20gRPC\x20equ\
    ivalent\x20of\x20Blockstore::AllKeysChan\n\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\xad\x01\x04\x0e\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xad\x01\
    \x11\x12\nS\n\x04\x05\x04\x02\x06\x12\x04\xaf\x01\x04\x15\x1aE\x20BS_GET\
    _STATS\x20is\x20used\x20to\x20retrieve\x20statistics\x20about\x20individ\
    ual\x20blocks\n\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\xaf\x01\x04\x10\n\
    \r\n\x05\x05\x04\x02\x06\x02\x12\x04\xaf\x01\x13\x14\n=\n\x02\x05\x05\
    \x12\x06\xb3\x01\0\xb8\x01\x01\x1a/\x20BSREQOPTS\x20are\x20options\x20fo\
    r\x20blockstore\x20requests\n\n\x0b\n\x03\x05\x05\x01\x12\x04\xb3\x01\
    \x05\x0e\n=\n\x04\x05\x05\x02\0\x12\x04\xb5\x01\x04\x10\x1a/\x20DEFAULT\
    \x20indicates\x20to\x20use\x20the\x20default\x20settings\n\n\r\n\x05\x05\
    \x05\x02\0\x01\x12\x04\xb5\x01\x04\x0b\n\r\n\x05\x05\x05\x02\0\x02\x12\
    \x04\xb5\x01\x0e\x0f\nY\n\x04\x05\x05\x02\x01\x12\x04\xb7\x01\x04\x11\
    \x1aK\x20BS_FORCE\x20indicates\x20to\x20force\x20the\x20request\x20regar\
    dless\x20of\x20any\x20possible\x20issues\n\n\r\n\x05\x05\x05\x02\x01\x01\
    \x12\x04\xb7\x01\x04\x0c\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xb7\x01\
    \x0f\x10\nJ\n\x02\x04\x08\x12\x06\xbb\x01\0\xcc\x01\x01\x1a<\x20Blocksto\
    reRequest\x20is\x20a\x20message\x20used\x20to\x20control\x20blockstores\
    \n\n\x0b\n\x03\x04\x08\x01\x12\x04\xbb\x01\x08\x19\nA\n\x04\x04\x08\x02\
    \0\x12\x04\xbd\x01\x04\x1e\x1a3\x20\x20indicates\x20the\x20particular\
    \x20request\x20type\x20being\x20made\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\
    \x06\xbd\x01\x04\xbb\x01\x1b\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xbd\x01\
    \x04\r\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xbd\x01\x0e\x19\n\r\n\x05\x04\
    \x08\x02\0\x03\x12\x04\xbd\x01\x1c\x1d\n)\n\x04\x04\x08\x02\x01\x12\x04\
    \xbf\x01\x04#\x1a\x1b\x20optional\x20request\x20settings\n\n\r\n\x05\x04\
    \x08\x02\x01\x04\x12\x04\xbf\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\x06\
    \x12\x04\xbf\x01\r\x16\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xbf\x01\x17\
    \x1e\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xbf\x01!\"\nU\n\x04\x04\x08\
    \x02\x02\x12\x04\xc2\x01\x04\x1d\x1aG\x20cids\x20of\x20blocks\n\x20sent\
    \x20by:\x20BS_DELETE,\x20BS_GET,\x20BS_GET_MANY,\x20BS_GET_STATS\n\n\r\n\
    \x05\x04\x08\x02\x02\x04\x12\x04\xc2\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xc2\x01\r\x13\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc2\
    \x01\x14\x18\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xc2\x01\x1b\x1c\nE\n\
    \x04\x04\x08\x02\x03\x12\x04\xc5\x01\x04\x1c\x1a7\x20the\x20data\x20we\
    \x20are\x20putting\n\x20sent\x20by:\x20BS_PUT,\x20BS_PUT_MANY\n\n\r\n\
    \x05\x04\x08\x02\x03\x04\x12\x04\xc5\x01\x04\x0c\n\r\n\x05\x04\x08\x02\
    \x03\x05\x12\x04\xc5\x01\r\x12\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xc5\
    \x01\x13\x17\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xc5\x01\x1a\x1b\nl\n\
    \x04\x04\x08\x02\x04\x12\x04\xc8\x01\x04\x1a\x1a^\x20the\x20cid\x20versi\
    on\x20to\x20use\x20when\x20constructing\x20blocks,\x20default\x20is\x20v\
    1\n\x20sent\x20by:\x20BS_PUT,\x20BS_PUT_MANY\n\n\x0f\n\x05\x04\x08\x02\
    \x04\x04\x12\x06\xc8\x01\x04\xc5\x01\x1c\n\r\n\x05\x04\x08\x02\x04\x05\
    \x12\x04\xc8\x01\x04\n\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xc8\x01\x0b\
    \x15\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xc8\x01\x18\x19\nt\n\x04\x04\
    \x08\x02\x05\x12\x04\xcb\x01\x04\x18\x1af\x20the\x20hash\x20function\x20\
    to\x20use\x20when\x20constructing\x20blocks,\x20default\x20is\x20sha2-25\
    6\n\x20sent\x20by:\x20BS_PUT,\x20BS_PUT_MANY\n\n\x0f\n\x05\x04\x08\x02\
    \x05\x04\x12\x06\xcb\x01\x04\xc8\x01\x1a\n\r\n\x05\x04\x08\x02\x05\x05\
    \x12\x04\xcb\x01\x04\n\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xcb\x01\x0b\
    \x13\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\xcb\x01\x16\x17\nH\n\x02\x04\
    \t\x12\x06\xcf\x01\0\xdc\x01\x01\x1a:\x20BlockstoreResponse\x20is\x20a\
    \x20response\x20to\x20a\x20BlockstoreqRequest\n\n\x0b\n\x03\x04\t\x01\
    \x12\x04\xcf\x01\x08\x1a\n@\n\x04\x04\t\x02\0\x12\x04\xd1\x01\x04\x1e\
    \x1a2\x20indicates\x20the\x20particular\x20request\x20type\x20being\x20m\
    ade\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xd1\x01\x04\xcf\x01\x1c\n\r\n\
    \x05\x04\t\x02\0\x06\x12\x04\xd1\x01\x04\r\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xd1\x01\x0e\x19\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd1\x01\x1c\x1d\n\
    \xf7\x02\n\x04\x04\t\x02\x01\x12\x04\xdb\x01\x04\x1e\x1a\xe8\x02\x20a\
    \x20copy\x20of\x20blocks\x20from\x20the\x20blockstore\n\x20sent\x20by:\
    \x20BS_PUT,\x20BS_PUT_MANY,\x20BS_GET,\x20BS_GET_MANY,\x20BS_GET_STATS,\
    \x20BS_GET_ALL\n\n\x20in\x20the\x20case\x20of\x20BS_PUT,\x20and\x20BS_PU\
    T_MANY\x20requests\n\x20the\x20data\x20field\x20will\x20be\x20empty\x20a\
    s\x20this\x20is\x20only\x20populated\n\x20by\x20get\x20requests\n\n\x20i\
    n\x20the\x20case\x20of\x20BS_GET_STATS\x20only\x20the\x20cid,\x20and\x20\
    size\x20params\n\x20will\x20be\x20filled\x20out,\x20since\x20we\x20are\
    \x20just\x20interested\x20in\x20the\x20size\n\n\r\n\x05\x04\t\x02\x01\
    \x04\x12\x04\xdb\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xdb\x01\
    \r\x12\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xdb\x01\x13\x19\n\r\n\x05\x04\
    \t\x02\x01\x03\x12\x04\xdb\x01\x1c\x1d\n\x0c\n\x02\x04\n\x12\x06\xde\x01\
    \0\xe7\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xde\x01\x08\r\n2\n\x04\x04\
    \n\x02\0\x12\x04\xe0\x01\x04\x13\x1a$\x20cid\x20is\x20the\x20identifier\
    \x20of\x20the\x20block\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\xe0\x01\x04\
    \xde\x01\x0f\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xe0\x01\x04\n\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xe0\x01\x0b\x0e\n\r\n\x05\x04\n\x02\0\x03\x12\
    \x04\xe0\x01\x11\x12\n8\n\x04\x04\n\x02\x01\x12\x04\xe2\x01\x04\x13\x1a*\
    \x20data\x20is\x20the\x20actual\x20contents\x20of\x20the\x20block\n\n\
    \x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xe2\x01\x04\xe0\x01\x13\n\r\n\x05\
    \x04\n\x02\x01\x05\x12\x04\xe2\x01\x04\t\n\r\n\x05\x04\n\x02\x01\x01\x12\
    \x04\xe2\x01\n\x0e\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xe2\x01\x11\x12\n\
    \x89\x01\n\x04\x04\n\x02\x02\x12\x04\xe6\x01\x04\x13\x1a{\x20size\x20of\
    \x20the\x20block,\x20only\x20filled\x20out\x20by\x20BS_GET_STATS\n\x20si\
    nce\x20if\x20we\x20just\x20want\x20stats,\x20we\x20dont\x20want\x20to\
    \x20\n\x20retrieve\x20all\x20the\x20data.\n\n\x0f\n\x05\x04\n\x02\x02\
    \x04\x12\x06\xe6\x01\x04\xe2\x01\x13\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\
    \xe6\x01\x04\t\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xe6\x01\n\x0e\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\xe6\x01\x11\x12\nR\n\x02\x05\x06\x12\x06\
    \xea\x01\0\xf7\x01\x01\x1aD\x20DAGREQTYPE\x20indicates\x20the\x20particu\
    lar\x20DagAPI\x20request\x20being\x20performed\n\n\x0b\n\x03\x05\x06\x01\
    \x12\x04\xea\x01\x05\x0f\n7\n\x04\x05\x06\x02\0\x12\x04\xec\x01\x04\x10\
    \x1a)\x20DAG_PUT\x20is\x20used\x20to\x20add\x20new\x20IPLD\x20objects\n\
    \n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xec\x01\x04\x0b\n\r\n\x05\x05\x06\
    \x02\0\x02\x12\x04\xec\x01\x0e\x0f\n<\n\x04\x05\x06\x02\x01\x12\x04\xee\
    \x01\x04\x10\x1a.\x20DAG_GET\x20is\x20used\x20to\x20retrieve\x20IPLD\x20\
    object\x20data\n\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xee\x01\x04\x0b\n\
    \r\n\x05\x05\x06\x02\x01\x02\x12\x04\xee\x01\x0e\x0f\nE\n\x04\x05\x06\
    \x02\x02\x12\x04\xf0\x01\x04\x15\x1a7\x20DAG_NEW_NODE\x20is\x20used\x20t\
    o\x20create\x20a\x20new\x20IPLD\x20node\x20object\n\n\r\n\x05\x05\x06\
    \x02\x02\x01\x12\x04\xf0\x01\x04\x10\n\r\n\x05\x05\x06\x02\x02\x02\x12\
    \x04\xf0\x01\x13\x14\nI\n\x04\x05\x06\x02\x03\x12\x04\xf2\x01\x04\x16\
    \x1a;\x20DAG_ADD_LINKS\x20is\x20used\x20to\x20add\x20links\x20to\x20an\
    \x20IPLD\x20node\x20object\n\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\xf2\
    \x01\x04\x11\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\xf2\x01\x14\x15\n\\\n\
    \x04\x05\x06\x02\x04\x12\x04\xf4\x01\x04\x16\x1aN\x20DAG_GET_LINKS\x20is\
    \x20used\x20to\x20retrieve\x20all\x20links\x20contained\x20in\x20an\x20I\
    PLD\x20node\x20object\n\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xf4\x01\
    \x04\x11\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\xf4\x01\x14\x15\nG\n\x04\
    \x05\x06\x02\x05\x12\x04\xf6\x01\x04\x11\x1a9\x20DAG_STAT\x20is\x20used\
    \x20to\x20retrieve\x20ipld.NodeStats\x20information\n\n\r\n\x05\x05\x06\
    \x02\x05\x01\x12\x04\xf6\x01\x04\x0c\n\r\n\x05\x05\x06\x02\x05\x02\x12\
    \x04\xf6\x01\x0f\x10\nA\n\x02\x04\x0b\x12\x06\xfa\x01\0\x93\x02\x01\x1a3\
    \x20Used\x20to\x20submit\x20a\x20request\x20to\x20Dag\x20or\x20DagStream\
    \x20RPCs\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xfa\x01\x08\x12\nQ\n\x04\x04\
    \x0b\x02\0\x12\x04\xfd\x01\x04\x1f\x1aC\x20indicates\x20the\x20request\
    \x20being\x20performed\n\x20sent\x20by:\x20all\x20request\x20types\n\n\
    \x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xfd\x01\x04\xfa\x01\x14\n\r\n\x05\
    \x04\x0b\x02\0\x06\x12\x04\xfd\x01\x04\x0e\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\xfd\x01\x0f\x1a\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xfd\x01\x1d\
    \x1e\nL\n\x04\x04\x0b\x02\x01\x12\x04\x80\x02\x04\x13\x1a>\x20data\x20th\
    at\x20we\x20will\x20be\x20storing\n\x20sent\x20by:\x20DAG_PUT,\x20DAG_NE\
    W_NODE\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\x80\x02\x04\xfd\x01\x1f\
    \n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x80\x02\x04\t\n\r\n\x05\x04\x0b\
    \x02\x01\x01\x12\x04\x80\x02\n\x0e\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \x80\x02\x11\x12\nX\n\x04\x04\x0b\x02\x02\x12\x04\x83\x02\x04\x1e\x1aJ\
    \x20the\x20object\x20encoding\x20type\x20(raw,\x20cbor,\x20protobuf,\x20\
    etc...)\n\x20sent\x20by:\x20DAG_PUT\n\n\x0f\n\x05\x04\x0b\x02\x02\x04\
    \x12\x06\x83\x02\x04\x80\x02\x13\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\
    \x83\x02\x04\n\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x83\x02\x0b\x19\n\r\
    \n\x05\x04\x0b\x02\x02\x03\x12\x04\x83\x02\x1c\x1d\nX\n\x04\x04\x0b\x02\
    \x03\x12\x04\x86\x02\x04#\x1aJ\x20the\x20serialization\x20format\x20(raw\
    ,\x20cbor,\x20protobuf,\x20etc...)\n\x20sent\x20by:\x20DAG_PUT\n\n\x0f\n\
    \x05\x04\x0b\x02\x03\x04\x12\x06\x86\x02\x04\x83\x02\x1e\n\r\n\x05\x04\
    \x0b\x02\x03\x05\x12\x04\x86\x02\x04\n\n\r\n\x05\x04\x0b\x02\x03\x01\x12\
    \x04\x86\x02\x0b\x1e\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x86\x02!\"\nw\
    \n\x04\x04\x0b\x02\x04\x12\x04\x89\x02\x04\x18\x1ai\x20the\x20hash\x20fu\
    nction\x20to\x20to\x20use\x20(sha2-256,\x20sha3-512,\x20etc...)\n\x20sen\
    t\x20by:\x20DAG_PUT,\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS\n\n\x0f\n\x05\x04\
    \x0b\x02\x04\x04\x12\x06\x89\x02\x04\x86\x02#\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\x89\x02\x04\n\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x89\x02\
    \x0b\x13\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x89\x02\x16\x17\nM\n\x04\
    \x04\x0b\x02\x05\x12\x04\x8c\x02\x04\x19\x1a?\x20the\x20cid\x20version\
    \x20to\x20use\x20(0,\x201)\n\x20sent\x20by:\x20DAG_PUT,\x20DAG_NEW_NODE\
    \n\n\x0f\n\x05\x04\x0b\x02\x05\x04\x12\x06\x8c\x02\x04\x89\x02\x18\n\r\n\
    \x05\x04\x0b\x02\x05\x05\x12\x04\x8c\x02\x04\t\n\r\n\x05\x04\x0b\x02\x05\
    \x01\x12\x04\x8c\x02\n\x14\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\x8c\x02\
    \x17\x18\nv\n\x04\x04\x0b\x02\x06\x12\x04\x8f\x02\x04\x14\x1ah\x20the\
    \x20hash\x20of\x20the\x20object\x20we\x20are\x20processing\n\x20sent\x20\
    by:\x20DAG_GET,\x20DAG_NEW_NODe,\x20DAG_ADD_LINKS,\x20DAG_GET_LINKS\n\n\
    \x0f\n\x05\x04\x0b\x02\x06\x04\x12\x06\x8f\x02\x04\x8c\x02\x19\n\r\n\x05\
    \x04\x0b\x02\x06\x05\x12\x04\x8f\x02\x04\n\n\r\n\x05\x04\x0b\x02\x06\x01\
    \x12\x04\x8f\x02\x0b\x0f\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x8f\x02\
    \x12\x13\nt\n\x04\x04\x0b\x02\x07\x12\x04\x92\x02\x04\"\x1af\x20indicate\
    s\x20links\x20and\x20their\x20names.\x20key\x20=\x20name,\x20value\x20=\
    \x20link\x20hash\n\x20sent\x20by:\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS\n\n\
    \x0f\n\x05\x04\x0b\x02\x07\x04\x12\x06\x92\x02\x04\x8f\x02\x14\n\r\n\x05\
    \x04\x0b\x02\x07\x06\x12\x04\x92\x02\x04\x17\n\r\n\x05\x04\x0b\x02\x07\
    \x01\x12\x04\x92\x02\x18\x1d\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\x92\
    \x02\x20!\n:\n\x02\x04\x0c\x12\x06\x96\x02\0\xa6\x02\x01\x1a,\x20Used\
    \x20in\x20response\x20to\x20a\x20Dag\x20or\x20DagStream\x20RPC\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\x96\x02\x08\x13\nQ\n\x04\x04\x0c\x02\0\x12\x04\
    \x99\x02\x04\x1f\x1aC\x20indicates\x20the\x20request\x20being\x20perform\
    ed\n\x20sent\x20by:\x20all\x20request\x20types\n\n\x0f\n\x05\x04\x0c\x02\
    \0\x04\x12\x06\x99\x02\x04\x96\x02\x15\n\r\n\x05\x04\x0c\x02\0\x06\x12\
    \x04\x99\x02\x04\x0e\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x99\x02\x0f\x1a\
    \n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x99\x02\x1d\x1e\n\x80\x01\n\x04\x04\
    \x0c\x02\x01\x12\x04\x9c\x02\x04\x1f\x1ar\x20returns\x20the\x20hashes\
    \x20of\x20newly\x20generated\x20IPLD\x20objects\n\x20sent\x20by:\x20DAG_\
    PUT,\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS,\x20DAG_GET_LINKS\n\n\r\n\x05\x04\
    \x0c\x02\x01\x04\x12\x04\x9c\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\x01\x05\
    \x12\x04\x9c\x02\r\x13\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x9c\x02\x14\
    \x1a\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x9c\x02\x1d\x1e\nN\n\x04\x04\
    \x0c\x02\x02\x12\x04\x9f\x02\x04\x16\x1a@\x20the\x20actual\x20data\x20co\
    ntained\x20by\x20the\x20IPLD\x20object\n\x20sent\x20by:\x20DAG_GET\n\n\
    \x0f\n\x05\x04\x0c\x02\x02\x04\x12\x06\x9f\x02\x04\x9c\x02\x1f\n\r\n\x05\
    \x04\x0c\x02\x02\x05\x12\x04\x9f\x02\x04\t\n\r\n\x05\x04\x0c\x02\x02\x01\
    \x12\x04\x9f\x02\n\x11\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x9f\x02\x14\
    \x15\nV\n\x04\x04\x0c\x02\x03\x12\x04\xa2\x02\x04\x20\x1aH\x20the\x20lin\
    ks\x20contained\x20within\x20an\x20IPLD\x20node\x20object\n\x20sent\x20b\
    y:\x20DAG_GET_LINKS\n\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\xa2\x02\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\xa2\x02\r\x15\n\r\n\x05\x04\
    \x0c\x02\x03\x01\x12\x04\xa2\x02\x16\x1b\n\r\n\x05\x04\x0c\x02\x03\x03\
    \x12\x04\xa2\x02\x1e\x1f\nV\n\x04\x04\x0c\x02\x04\x12\x04\xa5\x02\x04(\
    \x1aH\x20maps\x20ipld\x20cids\x20to\x20a\x20ipld.NodeStat\x20object\x20e\
    quivalent\n\x20sent\x20by:\x20DAG_STAT\n\n\x0f\n\x05\x04\x0c\x02\x04\x04\
    \x12\x06\xa5\x02\x04\xa2\x02\x20\n\r\n\x05\x04\x0c\x02\x04\x06\x12\x04\
    \xa5\x02\x04\x19\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xa5\x02\x1a#\n\r\
    \n\x05\x04\x0c\x02\x04\x03\x12\x04\xa5\x02&'\ny\n\x02\x04\r\x12\x06\xaa\
    \x02\0\xb5\x02\x01\x1ak\x20IPLDStat\x20is\x20statistics\x20about\x20an\
    \x20individual\x20dag\x20node\n\x20it\x20is\x20a\x20protocol\x20buffer\
    \x20wrapper\x20around\x20ipld.NodeStat\n\n\x0b\n\x03\x04\r\x01\x12\x04\
    \xaa\x02\x08\x10\n-\n\x04\x04\r\x02\0\x12\x04\xac\x02\x04\x17\x1a\x1f\
    \x20number\x20of\x20links\x20in\x20link\x20table\n\n\x0f\n\x05\x04\r\x02\
    \0\x04\x12\x06\xac\x02\x04\xaa\x02\x12\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xac\x02\x04\t\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xac\x02\n\x12\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\xac\x02\x15\x16\n-\n\x04\x04\r\x02\x01\x12\x04\
    \xae\x02\x04\x18\x1a\x1f\x20size\x20of\x20the\x20raw,\x20encoded\x20data\
    \n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\xae\x02\x04\xac\x02\x17\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\xae\x02\x04\t\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xae\x02\n\x13\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xae\x02\x16\
    \x17\n)\n\x04\x04\r\x02\x02\x12\x04\xb0\x02\x04\x17\x1a\x1b\x20size\x20o\
    f\x20the\x20links\x20segment\n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\xb0\
    \x02\x04\xae\x02\x18\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xb0\x02\x04\t\n\
    \r\n\x05\x04\r\x02\x02\x01\x12\x04\xb0\x02\n\x12\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\xb0\x02\x15\x16\n<\n\x04\x04\r\x02\x03\x12\x04\xb2\x02\x04\
    \x1d\x1a.\x20cumulative\x20size\x20of\x20object\x20and\x20its\x20referen\
    ces\n\n\x0f\n\x05\x04\r\x02\x03\x04\x12\x06\xb2\x02\x04\xb0\x02\x17\n\r\
    \n\x05\x04\r\x02\x03\x05\x12\x04\xb2\x02\x04\t\n\r\n\x05\x04\r\x02\x03\
    \x01\x12\x04\xb2\x02\n\x18\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xb2\x02\
    \x1b\x1c\n(\n\x04\x04\r\x02\x04\x12\x04\xb4\x02\x04\x17\x1a\x1a\x20size\
    \x20of\x20the\x20data\x20segment\n\n\x0f\n\x05\x04\r\x02\x04\x04\x12\x06\
    \xb4\x02\x04\xb2\x02\x1d\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xb4\x02\x04\
    \t\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xb4\x02\n\x12\n\r\n\x05\x04\r\x02\
    \x04\x03\x12\x04\xb4\x02\x15\x16\n&\n\x02\x04\x0e\x12\x06\xb8\x02\0\xbf\
    \x02\x01\x1a\x18\x20An\x20IPFS\x20MerkleDAG\x20Link\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xb8\x02\x08\x10\n.\n\x04\x04\x0e\x02\0\x12\x04\xba\x02\
    \x04\x13\x1a\x20\x20multihash\x20of\x20the\x20target\x20object\n\n\x0f\n\
    \x05\x04\x0e\x02\0\x04\x12\x06\xba\x02\x04\xb8\x02\x12\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xba\x02\x04\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xba\
    \x02\n\x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xba\x02\x11\x12\n<\n\x04\
    \x04\x0e\x02\x01\x12\x04\xbc\x02\x04\x14\x1a.\x20utf\x20string\x20name.\
    \x20should\x20be\x20unique\x20per\x20object\n\n\x0f\n\x05\x04\x0e\x02\
    \x01\x04\x12\x06\xbc\x02\x04\xba\x02\x13\n\r\n\x05\x04\x0e\x02\x01\x05\
    \x12\x04\xbc\x02\x04\n\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xbc\x02\x0b\
    \x0f\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xbc\x02\x12\x13\n0\n\x04\x04\
    \x0e\x02\x02\x12\x04\xbe\x02\x04\x14\x1a\"\x20cumulative\x20size\x20of\
    \x20target\x20object\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\xbe\x02\
    \x04\xbc\x02\x14\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xbe\x02\x04\n\n\r\
    \n\x05\x04\x0e\x02\x02\x01\x12\x04\xbe\x02\x0b\x0f\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xbe\x02\x12\x13\n&\n\x02\x04\x0f\x12\x06\xc2\x02\0\xc7\
    \x02\x01\x1a\x18\x20An\x20IPFS\x20MerkleDAG\x20Node\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xc2\x02\x08\x10\n%\n\x04\x04\x0f\x02\0\x12\x04\xc4\x02\
    \x04\x20\x1a\x17\x20refs\x20to\x20other\x20objects\n\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\xc4\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\
    \xc4\x02\r\x15\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xc4\x02\x16\x1b\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\xc4\x02\x1e\x1f\n\x20\n\x04\x04\x0f\x02\
    \x01\x12\x04\xc6\x02\x04\x13\x1a\x12\x20opaque\x20user\x20data\n\n\x0f\n\
    \x05\x04\x0f\x02\x01\x04\x12\x06\xc6\x02\x04\xc4\x02\x20\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xc6\x02\x04\t\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xc6\x02\n\x0e\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xc6\x02\x11\x12\
    \nV\n\x02\x05\x07\x12\x06\xca\x02\0\xd5\x02\x01\x1aH\x20KSREQTYPE\x20ind\
    icates\x20the\x20particular\x20KeystoreAPI\x20request\x20being\x20perfor\
    med\n\n\x0b\n\x03\x05\x07\x01\x12\x04\xca\x02\x05\x0e\nI\n\x04\x05\x07\
    \x02\0\x12\x04\xcc\x02\x04\x0f\x1a;\x20KS_HAS\x20is\x20used\x20to\x20che\
    ck\x20if\x20the\x20key\x20exists\x20in\x20our\x20keystore\n\n\r\n\x05\
    \x05\x07\x02\0\x01\x12\x04\xcc\x02\x04\n\n\r\n\x05\x05\x07\x02\0\x02\x12\
    \x04\xcc\x02\r\x0e\nN\n\x04\x05\x07\x02\x01\x12\x04\xce\x02\x04\x0f\x1a@\
    \x20KS_GET\x20is\x20used\x20to\x20retrieve\x20private\x20key\x20bytes\
    \x20from\x20our\x20keystore\n\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\xce\
    \x02\x04\n\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\xce\x02\r\x0e\nI\n\x04\
    \x05\x07\x02\x02\x12\x04\xd0\x02\x04\x0f\x1a;\x20KS_PUT\x20is\x20used\
    \x20to\x20store\x20private\x20key\x20bytes\x20in\x20our\x20keystore\n\n\
    \r\n\x05\x05\x07\x02\x02\x01\x12\x04\xd0\x02\x04\n\n\r\n\x05\x05\x07\x02\
    \x02\x02\x12\x04\xd0\x02\r\x0e\nJ\n\x04\x05\x07\x02\x03\x12\x04\xd2\x02\
    \x04\x12\x1a<\x20KS_DELETE\x20is\x20used\x20to\x20delete\x20private\x20k\
    eys\x20from\x20our\x20keystore\n\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\
    \xd2\x02\x04\r\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xd2\x02\x10\x11\nN\
    \n\x04\x05\x07\x02\x04\x12\x04\xd4\x02\x04\x10\x1a@\x20KS_LIST\x20is\x20\
    used\x20to\x20list\x20all\x20keys\x20in\x20our\x20keystore\x20by\x20thei\
    r\x20name\n\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xd4\x02\x04\x0b\n\r\n\
    \x05\x05\x07\x02\x04\x02\x12\x04\xd4\x02\x0e\x0f\n8\n\x02\x04\x10\x12\
    \x06\xd8\x02\0\xe1\x02\x01\x1a*\x20Used\x20to\x20submit\x20a\x20request\
    \x20to\x20Keystore\x20RPC\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xd8\x02\x08\
    \x17\n:\n\x04\x04\x10\x02\0\x12\x04\xda\x02\x04\x1e\x1a,\x20indicates\
    \x20the\x20request\x20type\x20being\x20performed\n\n\x0f\n\x05\x04\x10\
    \x02\0\x04\x12\x06\xda\x02\x04\xd8\x02\x19\n\r\n\x05\x04\x10\x02\0\x06\
    \x12\x04\xda\x02\x04\r\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xda\x02\x0e\
    \x19\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xda\x02\x1c\x1d\n^\n\x04\x04\
    \x10\x02\x01\x12\x04\xdd\x02\x04\x14\x1aP\x20name\x20of\x20the\x20key\
    \x20the\x20request\x20is\x20for\n\x20sent\x20by:\x20KS_HAS,\x20KS_GET,\
    \x20KS_PUT,\x20KS_DELETE\n\n\x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\xdd\
    \x02\x04\xda\x02\x1e\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xdd\x02\x04\n\
    \n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xdd\x02\x0b\x0f\n\r\n\x05\x04\x10\
    \x02\x01\x03\x12\x04\xdd\x02\x12\x13\n=\n\x04\x04\x10\x02\x02\x12\x04\
    \xe0\x02\x04\x19\x1a/\x20the\x20actual\x20private\x20key\x20bytes\n\x20s\
    ent\x20by:\x20KS_PUT\n\n\x0f\n\x05\x04\x10\x02\x02\x04\x12\x06\xe0\x02\
    \x04\xdd\x02\x14\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xe0\x02\x04\t\n\r\
    \n\x05\x04\x10\x02\x02\x01\x12\x04\xe0\x02\n\x14\n\r\n\x05\x04\x10\x02\
    \x02\x03\x12\x04\xe0\x02\x17\x18\n2\n\x02\x04\x11\x12\x06\xe4\x02\0\xf0\
    \x02\x01\x1a$\x20Used\x20in\x20response\x20to\x20a\x20Keystore\x20RPC\n\
    \n\x0b\n\x03\x04\x11\x01\x12\x04\xe4\x02\x08\x18\n:\n\x04\x04\x11\x02\0\
    \x12\x04\xe6\x02\x04\x1e\x1a,\x20indicates\x20the\x20request\x20type\x20\
    being\x20performed\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xe6\x02\x04\
    \xe4\x02\x1a\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xe6\x02\x04\r\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\xe6\x02\x0e\x19\n\r\n\x05\x04\x11\x02\0\x03\
    \x12\x04\xe6\x02\x1c\x1d\n6\n\x04\x04\x11\x02\x01\x12\x04\xe9\x02\x04\
    \x19\x1a(\x20the\x20private\x20key\x20bytes\n\x20sent\x20by:\x20KS_GET\n\
    \n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\xe9\x02\x04\xe6\x02\x1e\n\r\n\
    \x05\x04\x11\x02\x01\x05\x12\x04\xe9\x02\x04\t\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xe9\x02\n\x14\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe9\x02\
    \x17\x18\n>\n\x04\x04\x11\x02\x02\x12\x04\xec\x02\x04!\x1a0\x20contains\
    \x20all\x20known\x20key\x20names\n\x20sent\x20by:\x20KS_LIST\n\n\r\n\x05\
    \x04\x11\x02\x02\x04\x12\x04\xec\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x02\
    \x05\x12\x04\xec\x02\r\x13\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xec\x02\
    \x14\x1c\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xec\x02\x1f\x20\nM\n\x04\
    \x04\x11\x02\x03\x12\x04\xef\x02\x04\x11\x1a?\x20indicates\x20if\x20we\
    \x20have\x20the\x20key\x20in\x20our\x20keystore\n\x20sent\x20by:\x20KS_H\
    AS\n\n\x0f\n\x05\x04\x11\x02\x03\x04\x12\x06\xef\x02\x04\xec\x02!\n\r\n\
    \x05\x04\x11\x02\x03\x05\x12\x04\xef\x02\x04\x08\n\r\n\x05\x04\x11\x02\
    \x03\x01\x12\x04\xef\x02\t\x0c\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xef\
    \x02\x0f\x10\n\x0c\n\x02\x04\x12\x12\x06\xf2\x02\0\xf5\x02\x01\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\xf2\x02\x08\x16\n'\n\x04\x04\x12\x02\0\x12\x04\
    \xf4\x02\x04\x1d\x1a\x19\x20cids\x20to\x20persist\x20locally\n\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xf4\x02\x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\
    \x12\x04\xf4\x02\r\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf4\x02\x14\
    \x18\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf4\x02\x1b\x1c\n\x0c\n\x02\x04\
    \x13\x12\x06\xf7\x02\0\xfc\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xf7\
    \x02\x08\x17\nB\n\x04\x04\x13\x02\0\x12\x04\xf9\x02\x04!\x1a4\x20key\x20\
    =\x20cid,\x20value\x20=\x20whether\x20or\x20not\x20it\x20was\x20persiste\
    d\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xf9\x02\x04\xf7\x02\x19\n\r\n\
    \x05\x04\x13\x02\0\x06\x12\x04\xf9\x02\x04\x15\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xf9\x02\x16\x1c\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf9\x02\
    \x1f\x20\n9\n\x04\x04\x13\x02\x01\x12\x04\xfb\x02\x04#\x1a+\x20key\x20=\
    \x20cid,\x20value\x20=\x20error\x20if\x20not\x20persisted\n\n\x0f\n\x05\
    \x04\x13\x02\x01\x04\x12\x06\xfb\x02\x04\xf9\x02!\n\r\n\x05\x04\x13\x02\
    \x01\x06\x12\x04\xfb\x02\x04\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\
    \xfb\x02\x18\x1e\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xfb\x02!\"b\x06pr\
    oto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
