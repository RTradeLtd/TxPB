// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `node.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct P2PRequest {
    // message fields
    pub requestType: P2PREQTYPE,
    pub all: bool,
    pub verbose: bool,
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub remoteAddress: ::std::string::String,
    pub allowCustomProtocols: bool,
    pub reportPeerID: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PRequest {
    fn default() -> &'a P2PRequest {
        <P2PRequest as ::protobuf::Message>::default_instance()
    }
}

impl P2PRequest {
    pub fn new() -> P2PRequest {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // bool verbose = 3;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }

    // string protocolName = 4;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 5;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 6;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // string remoteAddress = 7;


    pub fn get_remoteAddress(&self) -> &str {
        &self.remoteAddress
    }
    pub fn clear_remoteAddress(&mut self) {
        self.remoteAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_remoteAddress(&mut self, v: ::std::string::String) {
        self.remoteAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteAddress(&mut self) -> &mut ::std::string::String {
        &mut self.remoteAddress
    }

    // Take field
    pub fn take_remoteAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remoteAddress, ::std::string::String::new())
    }

    // bool allowCustomProtocols = 8;


    pub fn get_allowCustomProtocols(&self) -> bool {
        self.allowCustomProtocols
    }
    pub fn clear_allowCustomProtocols(&mut self) {
        self.allowCustomProtocols = false;
    }

    // Param is passed by value, moved
    pub fn set_allowCustomProtocols(&mut self, v: bool) {
        self.allowCustomProtocols = v;
    }

    // bool reportPeerID = 9;


    pub fn get_reportPeerID(&self) -> bool {
        self.reportPeerID
    }
    pub fn clear_reportPeerID(&mut self) {
        self.reportPeerID = false;
    }

    // Param is passed by value, moved
    pub fn set_reportPeerID(&mut self, v: bool) {
        self.reportPeerID = v;
    }
}

impl ::protobuf::Message for P2PRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remoteAddress)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowCustomProtocols = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reportPeerID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.all != false {
            my_size += 2;
        }
        if self.verbose != false {
            my_size += 2;
        }
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.targetAddress);
        }
        if !self.remoteAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.remoteAddress);
        }
        if self.allowCustomProtocols != false {
            my_size += 2;
        }
        if self.reportPeerID != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        if self.verbose != false {
            os.write_bool(3, self.verbose)?;
        }
        if !self.protocolName.is_empty() {
            os.write_string(4, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(5, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(6, &self.targetAddress)?;
        }
        if !self.remoteAddress.is_empty() {
            os.write_string(7, &self.remoteAddress)?;
        }
        if self.allowCustomProtocols != false {
            os.write_bool(8, self.allowCustomProtocols)?;
        }
        if self.reportPeerID != false {
            os.write_bool(9, self.reportPeerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PRequest {
        P2PRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                "requestType",
                |m: &P2PRequest| { &m.requestType },
                |m: &mut P2PRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "all",
                |m: &P2PRequest| { &m.all },
                |m: &mut P2PRequest| { &mut m.all },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verbose",
                |m: &P2PRequest| { &m.verbose },
                |m: &mut P2PRequest| { &mut m.verbose },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocolName",
                |m: &P2PRequest| { &m.protocolName },
                |m: &mut P2PRequest| { &mut m.protocolName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listenAddress",
                |m: &P2PRequest| { &m.listenAddress },
                |m: &mut P2PRequest| { &mut m.listenAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAddress",
                |m: &P2PRequest| { &m.targetAddress },
                |m: &mut P2PRequest| { &mut m.targetAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remoteAddress",
                |m: &P2PRequest| { &m.remoteAddress },
                |m: &mut P2PRequest| { &mut m.remoteAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowCustomProtocols",
                |m: &P2PRequest| { &m.allowCustomProtocols },
                |m: &mut P2PRequest| { &mut m.allowCustomProtocols },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reportPeerID",
                |m: &P2PRequest| { &m.reportPeerID },
                |m: &mut P2PRequest| { &mut m.reportPeerID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PRequest>(
                "P2PRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P2PRequest {
        static instance: ::protobuf::rt::LazyV2<P2PRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P2PRequest::new)
    }
}

impl ::protobuf::Clear for P2PRequest {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.all = false;
        self.verbose = false;
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.remoteAddress.clear();
        self.allowCustomProtocols = false;
        self.reportPeerID = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PResponse {
    // message fields
    pub requestType: P2PREQTYPE,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    pub connsClosed: i32,
    pub streamInfos: ::protobuf::RepeatedField<P2PLsInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PResponse {
    fn default() -> &'a P2PResponse {
        <P2PResponse as ::protobuf::Message>::default_instance()
    }
}

impl P2PResponse {
    pub fn new() -> P2PResponse {
        ::std::default::Default::default()
    }

    // .pb.P2PREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> P2PREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: P2PREQTYPE) {
        self.requestType = v;
    }

    // repeated string names = 2;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    // int32 connsClosed = 3;


    pub fn get_connsClosed(&self) -> i32 {
        self.connsClosed
    }
    pub fn clear_connsClosed(&mut self) {
        self.connsClosed = 0;
    }

    // Param is passed by value, moved
    pub fn set_connsClosed(&mut self, v: i32) {
        self.connsClosed = v;
    }

    // repeated .pb.P2PLsInfo streamInfos = 4;


    pub fn get_streamInfos(&self) -> &[P2PLsInfo] {
        &self.streamInfos
    }
    pub fn clear_streamInfos(&mut self) {
        self.streamInfos.clear();
    }

    // Param is passed by value, moved
    pub fn set_streamInfos(&mut self, v: ::protobuf::RepeatedField<P2PLsInfo>) {
        self.streamInfos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streamInfos(&mut self) -> &mut ::protobuf::RepeatedField<P2PLsInfo> {
        &mut self.streamInfos
    }

    // Take field
    pub fn take_streamInfos(&mut self) -> ::protobuf::RepeatedField<P2PLsInfo> {
        ::std::mem::replace(&mut self.streamInfos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P2PResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.streamInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connsClosed = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streamInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != P2PREQTYPE::CLOSE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.connsClosed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.connsClosed, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.streamInfos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != P2PREQTYPE::CLOSE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        if self.connsClosed != 0 {
            os.write_int32(3, self.connsClosed)?;
        }
        for v in &self.streamInfos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PResponse {
        P2PResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<P2PREQTYPE>>(
                "requestType",
                |m: &P2PResponse| { &m.requestType },
                |m: &mut P2PResponse| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "names",
                |m: &P2PResponse| { &m.names },
                |m: &mut P2PResponse| { &mut m.names },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connsClosed",
                |m: &P2PResponse| { &m.connsClosed },
                |m: &mut P2PResponse| { &mut m.connsClosed },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P2PLsInfo>>(
                "streamInfos",
                |m: &P2PResponse| { &m.streamInfos },
                |m: &mut P2PResponse| { &mut m.streamInfos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PResponse>(
                "P2PResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P2PResponse {
        static instance: ::protobuf::rt::LazyV2<P2PResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P2PResponse::new)
    }
}

impl ::protobuf::Clear for P2PResponse {
    fn clear(&mut self) {
        self.requestType = P2PREQTYPE::CLOSE;
        self.names.clear();
        self.connsClosed = 0;
        self.streamInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P2PLsInfo {
    // message fields
    pub protocolName: ::std::string::String,
    pub listenAddress: ::std::string::String,
    pub targetAddress: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P2PLsInfo {
    fn default() -> &'a P2PLsInfo {
        <P2PLsInfo as ::protobuf::Message>::default_instance()
    }
}

impl P2PLsInfo {
    pub fn new() -> P2PLsInfo {
        ::std::default::Default::default()
    }

    // string protocolName = 1;


    pub fn get_protocolName(&self) -> &str {
        &self.protocolName
    }
    pub fn clear_protocolName(&mut self) {
        self.protocolName.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocolName(&mut self, v: ::std::string::String) {
        self.protocolName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolName(&mut self) -> &mut ::std::string::String {
        &mut self.protocolName
    }

    // Take field
    pub fn take_protocolName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocolName, ::std::string::String::new())
    }

    // string listenAddress = 2;


    pub fn get_listenAddress(&self) -> &str {
        &self.listenAddress
    }
    pub fn clear_listenAddress(&mut self) {
        self.listenAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listenAddress(&mut self, v: ::std::string::String) {
        self.listenAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listenAddress(&mut self) -> &mut ::std::string::String {
        &mut self.listenAddress
    }

    // Take field
    pub fn take_listenAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listenAddress, ::std::string::String::new())
    }

    // string targetAddress = 3;


    pub fn get_targetAddress(&self) -> &str {
        &self.targetAddress
    }
    pub fn clear_targetAddress(&mut self) {
        self.targetAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAddress(&mut self, v: ::std::string::String) {
        self.targetAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAddress(&mut self) -> &mut ::std::string::String {
        &mut self.targetAddress
    }

    // Take field
    pub fn take_targetAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAddress, ::std::string::String::new())
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for P2PLsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listenAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAddress)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.protocolName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.protocolName);
        }
        if !self.listenAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.listenAddress);
        }
        if !self.targetAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.targetAddress);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.protocolName.is_empty() {
            os.write_string(1, &self.protocolName)?;
        }
        if !self.listenAddress.is_empty() {
            os.write_string(2, &self.listenAddress)?;
        }
        if !self.targetAddress.is_empty() {
            os.write_string(3, &self.targetAddress)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P2PLsInfo {
        P2PLsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocolName",
                |m: &P2PLsInfo| { &m.protocolName },
                |m: &mut P2PLsInfo| { &mut m.protocolName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listenAddress",
                |m: &P2PLsInfo| { &m.listenAddress },
                |m: &mut P2PLsInfo| { &mut m.listenAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAddress",
                |m: &P2PLsInfo| { &m.targetAddress },
                |m: &mut P2PLsInfo| { &mut m.targetAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &P2PLsInfo| { &m.local },
                |m: &mut P2PLsInfo| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P2PLsInfo>(
                "P2PLsInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P2PLsInfo {
        static instance: ::protobuf::rt::LazyV2<P2PLsInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P2PLsInfo::new)
    }
}

impl ::protobuf::Clear for P2PLsInfo {
    fn clear(&mut self) {
        self.protocolName.clear();
        self.listenAddress.clear();
        self.targetAddress.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P2PLsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PLsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeersResponse {
    // message fields
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeersResponse {
    fn default() -> &'a GetPeersResponse {
        <GetPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeersResponse {
    pub fn new() -> GetPeersResponse {
        ::std::default::Default::default()
    }

    // repeated string peerIDs = 1;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peerIDs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersResponse {
        GetPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerIDs",
                |m: &GetPeersResponse| { &m.peerIDs },
                |m: &mut GetPeersResponse| { &mut m.peerIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPeersResponse>(
                "GetPeersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPeersResponse {
        static instance: ::protobuf::rt::LazyV2<GetPeersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPeersResponse::new)
    }
}

impl ::protobuf::Clear for GetPeersResponse {
    fn clear(&mut self) {
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtRequest {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub multiAddrs: ::protobuf::RepeatedField<::std::string::String>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtRequest {
    fn default() -> &'a ConnMgmtRequest {
        <ConnMgmtRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtRequest {
    pub fn new() -> ConnMgmtRequest {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated string multiAddrs = 2;


    pub fn get_multiAddrs(&self) -> &[::std::string::String] {
        &self.multiAddrs
    }
    pub fn clear_multiAddrs(&mut self) {
        self.multiAddrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_multiAddrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.multiAddrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_multiAddrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.multiAddrs
    }

    // Take field
    pub fn take_multiAddrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.multiAddrs, ::protobuf::RepeatedField::new())
    }

    // repeated string peerIDs = 3;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.multiAddrs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.multiAddrs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        for v in &self.multiAddrs {
            os.write_string(2, &v)?;
        };
        for v in &self.peerIDs {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtRequest {
        ConnMgmtRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                "requestType",
                |m: &ConnMgmtRequest| { &m.requestType },
                |m: &mut ConnMgmtRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "multiAddrs",
                |m: &ConnMgmtRequest| { &m.multiAddrs },
                |m: &mut ConnMgmtRequest| { &mut m.multiAddrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerIDs",
                |m: &ConnMgmtRequest| { &m.peerIDs },
                |m: &mut ConnMgmtRequest| { &mut m.peerIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtRequest>(
                "ConnMgmtRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnMgmtRequest {
        static instance: ::protobuf::rt::LazyV2<ConnMgmtRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnMgmtRequest::new)
    }
}

impl ::protobuf::Clear for ConnMgmtRequest {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.multiAddrs.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtResponse {
    // message fields
    pub requestType: CONNMGMTREQTYPE,
    pub connected: ::std::collections::HashMap<::std::string::String, bool>,
    pub status: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>,
    pub peerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtResponse {
    fn default() -> &'a ConnMgmtResponse {
        <ConnMgmtResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtResponse {
    pub fn new() -> ConnMgmtResponse {
        ::std::default::Default::default()
    }

    // .pb.CONNMGMTREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> CONNMGMTREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: CONNMGMTREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.ConnMgmtResponse.ConnectedEntry connected = 2;


    pub fn get_connected(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.connected
    }
    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.connected = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connected(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.connected
    }

    // Take field
    pub fn take_connected(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.connected, ::std::collections::HashMap::new())
    }

    // repeated .pb.ConnMgmtResponse.StatusEntry status = 3;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, ConnMgmtStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, ConnMgmtStatus> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated string peerIDs = 4;


    pub fn get_peerIDs(&self) -> &[::std::string::String] {
        &self.peerIDs
    }
    pub fn clear_peerIDs(&mut self) {
        self.peerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerIDs
    }

    // Take field
    pub fn take_peerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConnMgmtResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.connected)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status);
        for value in &self.peerIDs {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != CONNMGMTREQTYPE::CM_CONNECT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(2, &self.connected, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(3, &self.status, os)?;
        for v in &self.peerIDs {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtResponse {
        ConnMgmtResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CONNMGMTREQTYPE>>(
                "requestType",
                |m: &ConnMgmtResponse| { &m.requestType },
                |m: &mut ConnMgmtResponse| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                "connected",
                |m: &ConnMgmtResponse| { &m.connected },
                |m: &mut ConnMgmtResponse| { &mut m.connected },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ConnMgmtStatus>>(
                "status",
                |m: &ConnMgmtResponse| { &m.status },
                |m: &mut ConnMgmtResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerIDs",
                |m: &ConnMgmtResponse| { &m.peerIDs },
                |m: &mut ConnMgmtResponse| { &mut m.peerIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtResponse>(
                "ConnMgmtResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnMgmtResponse {
        static instance: ::protobuf::rt::LazyV2<ConnMgmtResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnMgmtResponse::new)
    }
}

impl ::protobuf::Clear for ConnMgmtResponse {
    fn clear(&mut self) {
        self.requestType = CONNMGMTREQTYPE::CM_CONNECT;
        self.connected.clear();
        self.status.clear();
        self.peerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnMgmtStatus {
    // message fields
    pub disconnected: bool,
    pub reason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnMgmtStatus {
    fn default() -> &'a ConnMgmtStatus {
        <ConnMgmtStatus as ::protobuf::Message>::default_instance()
    }
}

impl ConnMgmtStatus {
    pub fn new() -> ConnMgmtStatus {
        ::std::default::Default::default()
    }

    // bool disconnected = 1;


    pub fn get_disconnected(&self) -> bool {
        self.disconnected
    }
    pub fn clear_disconnected(&mut self) {
        self.disconnected = false;
    }

    // Param is passed by value, moved
    pub fn set_disconnected(&mut self, v: bool) {
        self.disconnected = v;
    }

    // string reason = 2;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnMgmtStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disconnected = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disconnected != false {
            my_size += 2;
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disconnected != false {
            os.write_bool(1, self.disconnected)?;
        }
        if !self.reason.is_empty() {
            os.write_string(2, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnMgmtStatus {
        ConnMgmtStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disconnected",
                |m: &ConnMgmtStatus| { &m.disconnected },
                |m: &mut ConnMgmtStatus| { &mut m.disconnected },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ConnMgmtStatus| { &m.reason },
                |m: &mut ConnMgmtStatus| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnMgmtStatus>(
                "ConnMgmtStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnMgmtStatus {
        static instance: ::protobuf::rt::LazyV2<ConnMgmtStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnMgmtStatus::new)
    }
}

impl ::protobuf::Clear for ConnMgmtStatus {
    fn clear(&mut self) {
        self.disconnected = false;
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnMgmtStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnMgmtStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtrasRequest {
    // message fields
    pub requestType: EXTRASREQTYPE,
    pub extrasFeature: EXTRASTYPE,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtrasRequest {
    fn default() -> &'a ExtrasRequest {
        <ExtrasRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtrasRequest {
    pub fn new() -> ExtrasRequest {
        ::std::default::Default::default()
    }

    // .pb.EXTRASREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> EXTRASREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: EXTRASREQTYPE) {
        self.requestType = v;
    }

    // .pb.EXTRASTYPE extrasFeature = 2;


    pub fn get_extrasFeature(&self) -> EXTRASTYPE {
        self.extrasFeature
    }
    pub fn clear_extrasFeature(&mut self) {
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
    }

    // Param is passed by value, moved
    pub fn set_extrasFeature(&mut self, v: EXTRASTYPE) {
        self.extrasFeature = v;
    }
}

impl ::protobuf::Message for ExtrasRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.extrasFeature, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            my_size += ::protobuf::rt::enum_size(2, self.extrasFeature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != EXTRASREQTYPE::EX_ENABLE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        if self.extrasFeature != EXTRASTYPE::IDENTIFY {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.extrasFeature))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtrasRequest {
        ExtrasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASREQTYPE>>(
                "requestType",
                |m: &ExtrasRequest| { &m.requestType },
                |m: &mut ExtrasRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EXTRASTYPE>>(
                "extrasFeature",
                |m: &ExtrasRequest| { &m.extrasFeature },
                |m: &mut ExtrasRequest| { &mut m.extrasFeature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtrasRequest>(
                "ExtrasRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtrasRequest {
        static instance: ::protobuf::rt::LazyV2<ExtrasRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtrasRequest::new)
    }
}

impl ::protobuf::Clear for ExtrasRequest {
    fn clear(&mut self) {
        self.requestType = EXTRASREQTYPE::EX_ENABLE;
        self.extrasFeature = EXTRASTYPE::IDENTIFY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtrasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtrasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreRequest {
    // message fields
    pub requestType: BSREQTYPE,
    pub reqOpts: ::std::vec::Vec<BSREQOPTS>,
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub cidVersion: ::std::string::String,
    pub hashFunc: ::std::string::String,
    pub refID: ::std::string::String,
    pub progressive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreRequest {
    fn default() -> &'a BlockstoreRequest {
        <BlockstoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreRequest {
    pub fn new() -> BlockstoreRequest {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.BSREQOPTS reqOpts = 2;


    pub fn get_reqOpts(&self) -> &[BSREQOPTS] {
        &self.reqOpts
    }
    pub fn clear_reqOpts(&mut self) {
        self.reqOpts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reqOpts(&mut self, v: ::std::vec::Vec<BSREQOPTS>) {
        self.reqOpts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reqOpts(&mut self) -> &mut ::std::vec::Vec<BSREQOPTS> {
        &mut self.reqOpts
    }

    // Take field
    pub fn take_reqOpts(&mut self) -> ::std::vec::Vec<BSREQOPTS> {
        ::std::mem::replace(&mut self.reqOpts, ::std::vec::Vec::new())
    }

    // repeated string cids = 3;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes data = 4;


    pub fn get_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // string cidVersion = 5;


    pub fn get_cidVersion(&self) -> &str {
        &self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: ::std::string::String) {
        self.cidVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidVersion(&mut self) -> &mut ::std::string::String {
        &mut self.cidVersion
    }

    // Take field
    pub fn take_cidVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cidVersion, ::std::string::String::new())
    }

    // string hashFunc = 7;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }

    // string refID = 8;


    pub fn get_refID(&self) -> &str {
        &self.refID
    }
    pub fn clear_refID(&mut self) {
        self.refID.clear();
    }

    // Param is passed by value, moved
    pub fn set_refID(&mut self, v: ::std::string::String) {
        self.refID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refID(&mut self) -> &mut ::std::string::String {
        &mut self.refID
    }

    // Take field
    pub fn take_refID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.refID, ::std::string::String::new())
    }

    // bool progressive = 9;


    pub fn get_progressive(&self) -> bool {
        self.progressive
    }
    pub fn clear_progressive(&mut self) {
        self.progressive = false;
    }

    // Param is passed by value, moved
    pub fn set_progressive(&mut self, v: bool) {
        self.progressive = v;
    }
}

impl ::protobuf::Message for BlockstoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.reqOpts, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cidVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.refID)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.progressive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.reqOpts {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.data {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.cidVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cidVersion);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hashFunc);
        }
        if !self.refID.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.refID);
        }
        if self.progressive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        for v in &self.reqOpts {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.cids {
            os.write_string(3, &v)?;
        };
        for v in &self.data {
            os.write_bytes(4, &v)?;
        };
        if !self.cidVersion.is_empty() {
            os.write_string(5, &self.cidVersion)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(7, &self.hashFunc)?;
        }
        if !self.refID.is_empty() {
            os.write_string(8, &self.refID)?;
        }
        if self.progressive != false {
            os.write_bool(9, self.progressive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreRequest {
        BlockstoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                "requestType",
                |m: &BlockstoreRequest| { &m.requestType },
                |m: &mut BlockstoreRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQOPTS>>(
                "reqOpts",
                |m: &BlockstoreRequest| { &m.reqOpts },
                |m: &mut BlockstoreRequest| { &mut m.reqOpts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cids",
                |m: &BlockstoreRequest| { &m.cids },
                |m: &mut BlockstoreRequest| { &mut m.cids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &BlockstoreRequest| { &m.data },
                |m: &mut BlockstoreRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cidVersion",
                |m: &BlockstoreRequest| { &m.cidVersion },
                |m: &mut BlockstoreRequest| { &mut m.cidVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hashFunc",
                |m: &BlockstoreRequest| { &m.hashFunc },
                |m: &mut BlockstoreRequest| { &mut m.hashFunc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "refID",
                |m: &BlockstoreRequest| { &m.refID },
                |m: &mut BlockstoreRequest| { &mut m.refID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "progressive",
                |m: &BlockstoreRequest| { &m.progressive },
                |m: &mut BlockstoreRequest| { &mut m.progressive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockstoreRequest>(
                "BlockstoreRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockstoreRequest {
        static instance: ::protobuf::rt::LazyV2<BlockstoreRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockstoreRequest::new)
    }
}

impl ::protobuf::Clear for BlockstoreRequest {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.reqOpts.clear();
        self.cids.clear();
        self.data.clear();
        self.cidVersion.clear();
        self.hashFunc.clear();
        self.refID.clear();
        self.progressive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockstoreResponse {
    // message fields
    pub requestType: BSREQTYPE,
    pub blocks: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockstoreResponse {
    fn default() -> &'a BlockstoreResponse {
        <BlockstoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockstoreResponse {
    pub fn new() -> BlockstoreResponse {
        ::std::default::Default::default()
    }

    // .pb.BSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> BSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: BSREQTYPE) {
        self.requestType = v;
    }

    // repeated .pb.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockstoreResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != BSREQTYPE::BS_DELETE {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != BSREQTYPE::BS_DELETE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockstoreResponse {
        BlockstoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BSREQTYPE>>(
                "requestType",
                |m: &BlockstoreResponse| { &m.requestType },
                |m: &mut BlockstoreResponse| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                "blocks",
                |m: &BlockstoreResponse| { &m.blocks },
                |m: &mut BlockstoreResponse| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockstoreResponse>(
                "BlockstoreResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockstoreResponse {
        static instance: ::protobuf::rt::LazyV2<BlockstoreResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockstoreResponse::new)
    }
}

impl ::protobuf::Clear for BlockstoreResponse {
    fn clear(&mut self) {
        self.requestType = BSREQTYPE::BS_DELETE;
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockstoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockstoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub cid: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    pub size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // string cid = 1;


    pub fn get_cid(&self) -> &str {
        &self.cid
    }
    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: ::std::string::String) {
        self.cid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut ::std::string::String {
        &mut self.cid
    }

    // Take field
    pub fn take_cid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cid, ::std::string::String::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cid);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cid.is_empty() {
            os.write_string(1, &self.cid)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cid",
                |m: &Block| { &m.cid },
                |m: &mut Block| { &mut m.cid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &Block| { &m.data },
                |m: &mut Block| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Block| { &m.size },
                |m: &mut Block| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Block>(
                "Block",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Block {
        static instance: ::protobuf::rt::LazyV2<Block> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Block::new)
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.cid.clear();
        self.data.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagRequest {
    // message fields
    pub requestType: DAGREQTYPE,
    pub data: ::std::vec::Vec<u8>,
    pub objectEncoding: ::std::string::String,
    pub serializationFormat: ::std::string::String,
    pub hashFunc: ::std::string::String,
    pub cidVersion: i64,
    pub hash: ::std::string::String,
    pub links: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub refID: ::std::string::String,
    pub progressive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagRequest {
    fn default() -> &'a DagRequest {
        <DagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DagRequest {
    pub fn new() -> DagRequest {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string objectEncoding = 3;


    pub fn get_objectEncoding(&self) -> &str {
        &self.objectEncoding
    }
    pub fn clear_objectEncoding(&mut self) {
        self.objectEncoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectEncoding(&mut self, v: ::std::string::String) {
        self.objectEncoding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectEncoding(&mut self) -> &mut ::std::string::String {
        &mut self.objectEncoding
    }

    // Take field
    pub fn take_objectEncoding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.objectEncoding, ::std::string::String::new())
    }

    // string serializationFormat = 4;


    pub fn get_serializationFormat(&self) -> &str {
        &self.serializationFormat
    }
    pub fn clear_serializationFormat(&mut self) {
        self.serializationFormat.clear();
    }

    // Param is passed by value, moved
    pub fn set_serializationFormat(&mut self, v: ::std::string::String) {
        self.serializationFormat = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serializationFormat(&mut self) -> &mut ::std::string::String {
        &mut self.serializationFormat
    }

    // Take field
    pub fn take_serializationFormat(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serializationFormat, ::std::string::String::new())
    }

    // string hashFunc = 5;


    pub fn get_hashFunc(&self) -> &str {
        &self.hashFunc
    }
    pub fn clear_hashFunc(&mut self) {
        self.hashFunc.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashFunc(&mut self, v: ::std::string::String) {
        self.hashFunc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashFunc(&mut self) -> &mut ::std::string::String {
        &mut self.hashFunc
    }

    // Take field
    pub fn take_hashFunc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hashFunc, ::std::string::String::new())
    }

    // int64 cidVersion = 6;


    pub fn get_cidVersion(&self) -> i64 {
        self.cidVersion
    }
    pub fn clear_cidVersion(&mut self) {
        self.cidVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_cidVersion(&mut self, v: i64) {
        self.cidVersion = v;
    }

    // string hash = 7;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // repeated .pb.DagRequest.LinksEntry links = 8;


    pub fn get_links(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.links, ::std::collections::HashMap::new())
    }

    // string refID = 9;


    pub fn get_refID(&self) -> &str {
        &self.refID
    }
    pub fn clear_refID(&mut self) {
        self.refID.clear();
    }

    // Param is passed by value, moved
    pub fn set_refID(&mut self, v: ::std::string::String) {
        self.refID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refID(&mut self) -> &mut ::std::string::String {
        &mut self.refID
    }

    // Take field
    pub fn take_refID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.refID, ::std::string::String::new())
    }

    // bool progressive = 10;


    pub fn get_progressive(&self) -> bool {
        self.progressive
    }
    pub fn clear_progressive(&mut self) {
        self.progressive = false;
    }

    // Param is passed by value, moved
    pub fn set_progressive(&mut self, v: bool) {
        self.progressive = v;
    }
}

impl ::protobuf::Message for DagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.objectEncoding)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serializationFormat)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hashFunc)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cidVersion = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.links)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.refID)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.progressive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.objectEncoding.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.objectEncoding);
        }
        if !self.serializationFormat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.serializationFormat);
        }
        if !self.hashFunc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hashFunc);
        }
        if self.cidVersion != 0 {
            my_size += ::protobuf::rt::value_size(6, self.cidVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hash);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links);
        if !self.refID.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.refID);
        }
        if self.progressive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.objectEncoding.is_empty() {
            os.write_string(3, &self.objectEncoding)?;
        }
        if !self.serializationFormat.is_empty() {
            os.write_string(4, &self.serializationFormat)?;
        }
        if !self.hashFunc.is_empty() {
            os.write_string(5, &self.hashFunc)?;
        }
        if self.cidVersion != 0 {
            os.write_int64(6, self.cidVersion)?;
        }
        if !self.hash.is_empty() {
            os.write_string(7, &self.hash)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.links, os)?;
        if !self.refID.is_empty() {
            os.write_string(9, &self.refID)?;
        }
        if self.progressive != false {
            os.write_bool(10, self.progressive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagRequest {
        DagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                "requestType",
                |m: &DagRequest| { &m.requestType },
                |m: &mut DagRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &DagRequest| { &m.data },
                |m: &mut DagRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "objectEncoding",
                |m: &DagRequest| { &m.objectEncoding },
                |m: &mut DagRequest| { &mut m.objectEncoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serializationFormat",
                |m: &DagRequest| { &m.serializationFormat },
                |m: &mut DagRequest| { &mut m.serializationFormat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hashFunc",
                |m: &DagRequest| { &m.hashFunc },
                |m: &mut DagRequest| { &mut m.hashFunc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cidVersion",
                |m: &DagRequest| { &m.cidVersion },
                |m: &mut DagRequest| { &mut m.cidVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &DagRequest| { &m.hash },
                |m: &mut DagRequest| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "links",
                |m: &DagRequest| { &m.links },
                |m: &mut DagRequest| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "refID",
                |m: &DagRequest| { &m.refID },
                |m: &mut DagRequest| { &mut m.refID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "progressive",
                |m: &DagRequest| { &m.progressive },
                |m: &mut DagRequest| { &mut m.progressive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DagRequest>(
                "DagRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DagRequest {
        static instance: ::protobuf::rt::LazyV2<DagRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DagRequest::new)
    }
}

impl ::protobuf::Clear for DagRequest {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.data.clear();
        self.objectEncoding.clear();
        self.serializationFormat.clear();
        self.hashFunc.clear();
        self.cidVersion = 0;
        self.hash.clear();
        self.links.clear();
        self.refID.clear();
        self.progressive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DagResponse {
    // message fields
    pub requestType: DAGREQTYPE,
    pub hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub rawData: ::std::vec::Vec<u8>,
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub nodeStats: ::std::collections::HashMap<::std::string::String, IPLDStat>,
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DagResponse {
    fn default() -> &'a DagResponse {
        <DagResponse as ::protobuf::Message>::default_instance()
    }
}

impl DagResponse {
    pub fn new() -> DagResponse {
        ::std::default::Default::default()
    }

    // .pb.DAGREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> DAGREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: DAGREQTYPE) {
        self.requestType = v;
    }

    // repeated string hashes = 2;


    pub fn get_hashes(&self) -> &[::std::string::String] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    // bytes rawData = 3;


    pub fn get_rawData(&self) -> &[u8] {
        &self.rawData
    }
    pub fn clear_rawData(&mut self) {
        self.rawData.clear();
    }

    // Param is passed by value, moved
    pub fn set_rawData(&mut self, v: ::std::vec::Vec<u8>) {
        self.rawData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rawData
    }

    // Take field
    pub fn take_rawData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rawData, ::std::vec::Vec::new())
    }

    // repeated .pb.IPLDLink links = 4;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.DagResponse.NodeStatsEntry nodeStats = 5;


    pub fn get_nodeStats(&self) -> &::std::collections::HashMap<::std::string::String, IPLDStat> {
        &self.nodeStats
    }
    pub fn clear_nodeStats(&mut self) {
        self.nodeStats.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeStats(&mut self, v: ::std::collections::HashMap<::std::string::String, IPLDStat>) {
        self.nodeStats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeStats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, IPLDStat> {
        &mut self.nodeStats
    }

    // Take field
    pub fn take_nodeStats(&mut self) -> ::std::collections::HashMap<::std::string::String, IPLDStat> {
        ::std::mem::replace(&mut self.nodeStats, ::std::collections::HashMap::new())
    }

    // uint64 count = 6;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }
}

impl ::protobuf::Message for DagResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hashes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rawData)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(wire_type, is, &mut self.nodeStats)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != DAGREQTYPE::DAG_PUT {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        for value in &self.hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.rawData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.rawData);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats);
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != DAGREQTYPE::DAG_PUT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        for v in &self.hashes {
            os.write_string(2, &v)?;
        };
        if !self.rawData.is_empty() {
            os.write_bytes(3, &self.rawData)?;
        }
        for v in &self.links {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(5, &self.nodeStats, os)?;
        if self.count != 0 {
            os.write_uint64(6, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DagResponse {
        DagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DAGREQTYPE>>(
                "requestType",
                |m: &DagResponse| { &m.requestType },
                |m: &mut DagResponse| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hashes",
                |m: &DagResponse| { &m.hashes },
                |m: &mut DagResponse| { &mut m.hashes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rawData",
                |m: &DagResponse| { &m.rawData },
                |m: &mut DagResponse| { &mut m.rawData },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                "links",
                |m: &DagResponse| { &m.links },
                |m: &mut DagResponse| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<IPLDStat>>(
                "nodeStats",
                |m: &DagResponse| { &m.nodeStats },
                |m: &mut DagResponse| { &mut m.nodeStats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &DagResponse| { &m.count },
                |m: &mut DagResponse| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DagResponse>(
                "DagResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DagResponse {
        static instance: ::protobuf::rt::LazyV2<DagResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DagResponse::new)
    }
}

impl ::protobuf::Clear for DagResponse {
    fn clear(&mut self) {
        self.requestType = DAGREQTYPE::DAG_PUT;
        self.hashes.clear();
        self.rawData.clear();
        self.links.clear();
        self.nodeStats.clear();
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDStat {
    // message fields
    pub numLinks: i64,
    pub blockSize: i64,
    pub linkSize: i64,
    pub cumulativeSize: i64,
    pub dataSize: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDStat {
    fn default() -> &'a IPLDStat {
        <IPLDStat as ::protobuf::Message>::default_instance()
    }
}

impl IPLDStat {
    pub fn new() -> IPLDStat {
        ::std::default::Default::default()
    }

    // int64 numLinks = 1;


    pub fn get_numLinks(&self) -> i64 {
        self.numLinks
    }
    pub fn clear_numLinks(&mut self) {
        self.numLinks = 0;
    }

    // Param is passed by value, moved
    pub fn set_numLinks(&mut self, v: i64) {
        self.numLinks = v;
    }

    // int64 blockSize = 2;


    pub fn get_blockSize(&self) -> i64 {
        self.blockSize
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: i64) {
        self.blockSize = v;
    }

    // int64 linkSize = 3;


    pub fn get_linkSize(&self) -> i64 {
        self.linkSize
    }
    pub fn clear_linkSize(&mut self) {
        self.linkSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_linkSize(&mut self, v: i64) {
        self.linkSize = v;
    }

    // int64 cumulativeSize = 4;


    pub fn get_cumulativeSize(&self) -> i64 {
        self.cumulativeSize
    }
    pub fn clear_cumulativeSize(&mut self) {
        self.cumulativeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_cumulativeSize(&mut self, v: i64) {
        self.cumulativeSize = v;
    }

    // int64 dataSize = 5;


    pub fn get_dataSize(&self) -> i64 {
        self.dataSize
    }
    pub fn clear_dataSize(&mut self) {
        self.dataSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_dataSize(&mut self, v: i64) {
        self.dataSize = v;
    }
}

impl ::protobuf::Message for IPLDStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numLinks = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockSize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.linkSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cumulativeSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dataSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.numLinks != 0 {
            my_size += ::protobuf::rt::value_size(1, self.numLinks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.linkSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.linkSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cumulativeSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.cumulativeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dataSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dataSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.numLinks != 0 {
            os.write_int64(1, self.numLinks)?;
        }
        if self.blockSize != 0 {
            os.write_int64(2, self.blockSize)?;
        }
        if self.linkSize != 0 {
            os.write_int64(3, self.linkSize)?;
        }
        if self.cumulativeSize != 0 {
            os.write_int64(4, self.cumulativeSize)?;
        }
        if self.dataSize != 0 {
            os.write_int64(5, self.dataSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDStat {
        IPLDStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numLinks",
                |m: &IPLDStat| { &m.numLinks },
                |m: &mut IPLDStat| { &mut m.numLinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockSize",
                |m: &IPLDStat| { &m.blockSize },
                |m: &mut IPLDStat| { &mut m.blockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "linkSize",
                |m: &IPLDStat| { &m.linkSize },
                |m: &mut IPLDStat| { &mut m.linkSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cumulativeSize",
                |m: &IPLDStat| { &m.cumulativeSize },
                |m: &mut IPLDStat| { &mut m.cumulativeSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dataSize",
                |m: &IPLDStat| { &m.dataSize },
                |m: &mut IPLDStat| { &mut m.dataSize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDStat>(
                "IPLDStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IPLDStat {
        static instance: ::protobuf::rt::LazyV2<IPLDStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLDStat::new)
    }
}

impl ::protobuf::Clear for IPLDStat {
    fn clear(&mut self) {
        self.numLinks = 0;
        self.blockSize = 0;
        self.linkSize = 0;
        self.cumulativeSize = 0;
        self.dataSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDLink {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDLink {
    fn default() -> &'a IPLDLink {
        <IPLDLink as ::protobuf::Message>::default_instance()
    }
}

impl IPLDLink {
    pub fn new() -> IPLDLink {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 size = 3;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for IPLDLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.size != 0 {
            os.write_uint64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDLink {
        IPLDLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &IPLDLink| { &m.hash },
                |m: &mut IPLDLink| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &IPLDLink| { &m.name },
                |m: &mut IPLDLink| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &IPLDLink| { &m.size },
                |m: &mut IPLDLink| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDLink>(
                "IPLDLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IPLDLink {
        static instance: ::protobuf::rt::LazyV2<IPLDLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLDLink::new)
    }
}

impl ::protobuf::Clear for IPLDLink {
    fn clear(&mut self) {
        self.hash.clear();
        self.name.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPLDNode {
    // message fields
    pub links: ::protobuf::RepeatedField<IPLDLink>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLDNode {
    fn default() -> &'a IPLDNode {
        <IPLDNode as ::protobuf::Message>::default_instance()
    }
}

impl IPLDNode {
    pub fn new() -> IPLDNode {
        ::std::default::Default::default()
    }

    // repeated .pb.IPLDLink links = 2;


    pub fn get_links(&self) -> &[IPLDLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<IPLDLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<IPLDLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<IPLDLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IPLDNode {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.links {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLDNode {
        IPLDNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPLDLink>>(
                "links",
                |m: &IPLDNode| { &m.links },
                |m: &mut IPLDNode| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &IPLDNode| { &m.data },
                |m: &mut IPLDNode| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLDNode>(
                "IPLDNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IPLDNode {
        static instance: ::protobuf::rt::LazyV2<IPLDNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLDNode::new)
    }
}

impl ::protobuf::Clear for IPLDNode {
    fn clear(&mut self) {
        self.links.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLDNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLDNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreRequest {
    // message fields
    pub requestType: KSREQTYPE,
    pub name: ::std::string::String,
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreRequest {
    fn default() -> &'a KeystoreRequest {
        <KeystoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreRequest {
    pub fn new() -> KeystoreRequest {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes privateKey = 3;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeystoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(3, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreRequest {
        KeystoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                "requestType",
                |m: &KeystoreRequest| { &m.requestType },
                |m: &mut KeystoreRequest| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &KeystoreRequest| { &m.name },
                |m: &mut KeystoreRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "privateKey",
                |m: &KeystoreRequest| { &m.privateKey },
                |m: &mut KeystoreRequest| { &mut m.privateKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeystoreRequest>(
                "KeystoreRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeystoreRequest {
        static instance: ::protobuf::rt::LazyV2<KeystoreRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeystoreRequest::new)
    }
}

impl ::protobuf::Clear for KeystoreRequest {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.name.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeystoreResponse {
    // message fields
    pub requestType: KSREQTYPE,
    pub privateKey: ::std::vec::Vec<u8>,
    pub keyNames: ::protobuf::RepeatedField<::std::string::String>,
    pub has: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeystoreResponse {
    fn default() -> &'a KeystoreResponse {
        <KeystoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeystoreResponse {
    pub fn new() -> KeystoreResponse {
        ::std::default::Default::default()
    }

    // .pb.KSREQTYPE requestType = 1;


    pub fn get_requestType(&self) -> KSREQTYPE {
        self.requestType
    }
    pub fn clear_requestType(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
    }

    // Param is passed by value, moved
    pub fn set_requestType(&mut self, v: KSREQTYPE) {
        self.requestType = v;
    }

    // bytes privateKey = 2;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // repeated string keyNames = 3;


    pub fn get_keyNames(&self) -> &[::std::string::String] {
        &self.keyNames
    }
    pub fn clear_keyNames(&mut self) {
        self.keyNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keyNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keyNames
    }

    // Take field
    pub fn take_keyNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keyNames, ::protobuf::RepeatedField::new())
    }

    // bool has = 4;


    pub fn get_has(&self) -> bool {
        self.has
    }
    pub fn clear_has(&mut self) {
        self.has = false;
    }

    // Param is passed by value, moved
    pub fn set_has(&mut self, v: bool) {
        self.has = v;
    }
}

impl ::protobuf::Message for KeystoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keyNames)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requestType != KSREQTYPE::KS_HAS {
            my_size += ::protobuf::rt::enum_size(1, self.requestType);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        for value in &self.keyNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.has != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requestType != KSREQTYPE::KS_HAS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requestType))?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        for v in &self.keyNames {
            os.write_string(3, &v)?;
        };
        if self.has != false {
            os.write_bool(4, self.has)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeystoreResponse {
        KeystoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KSREQTYPE>>(
                "requestType",
                |m: &KeystoreResponse| { &m.requestType },
                |m: &mut KeystoreResponse| { &mut m.requestType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "privateKey",
                |m: &KeystoreResponse| { &m.privateKey },
                |m: &mut KeystoreResponse| { &mut m.privateKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyNames",
                |m: &KeystoreResponse| { &m.keyNames },
                |m: &mut KeystoreResponse| { &mut m.keyNames },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has",
                |m: &KeystoreResponse| { &m.has },
                |m: &mut KeystoreResponse| { &mut m.has },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeystoreResponse>(
                "KeystoreResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeystoreResponse {
        static instance: ::protobuf::rt::LazyV2<KeystoreResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeystoreResponse::new)
    }
}

impl ::protobuf::Clear for KeystoreResponse {
    fn clear(&mut self) {
        self.requestType = KSREQTYPE::KS_HAS;
        self.privateKey.clear();
        self.keyNames.clear();
        self.has = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeystoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistRequest {
    // message fields
    pub cids: ::protobuf::RepeatedField<::std::string::String>,
    pub refID: ::std::string::String,
    pub progressive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistRequest {
    fn default() -> &'a PersistRequest {
        <PersistRequest as ::protobuf::Message>::default_instance()
    }
}

impl PersistRequest {
    pub fn new() -> PersistRequest {
        ::std::default::Default::default()
    }

    // repeated string cids = 1;


    pub fn get_cids(&self) -> &[::std::string::String] {
        &self.cids
    }
    pub fn clear_cids(&mut self) {
        self.cids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cids
    }

    // Take field
    pub fn take_cids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cids, ::protobuf::RepeatedField::new())
    }

    // string refID = 2;


    pub fn get_refID(&self) -> &str {
        &self.refID
    }
    pub fn clear_refID(&mut self) {
        self.refID.clear();
    }

    // Param is passed by value, moved
    pub fn set_refID(&mut self, v: ::std::string::String) {
        self.refID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refID(&mut self) -> &mut ::std::string::String {
        &mut self.refID
    }

    // Take field
    pub fn take_refID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.refID, ::std::string::String::new())
    }

    // bool progressive = 5;


    pub fn get_progressive(&self) -> bool {
        self.progressive
    }
    pub fn clear_progressive(&mut self) {
        self.progressive = false;
    }

    // Param is passed by value, moved
    pub fn set_progressive(&mut self, v: bool) {
        self.progressive = v;
    }
}

impl ::protobuf::Message for PersistRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.refID)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.progressive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.refID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.refID);
        }
        if self.progressive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cids {
            os.write_string(1, &v)?;
        };
        if !self.refID.is_empty() {
            os.write_string(2, &self.refID)?;
        }
        if self.progressive != false {
            os.write_bool(5, self.progressive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistRequest {
        PersistRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cids",
                |m: &PersistRequest| { &m.cids },
                |m: &mut PersistRequest| { &mut m.cids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "refID",
                |m: &PersistRequest| { &m.refID },
                |m: &mut PersistRequest| { &mut m.refID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "progressive",
                |m: &PersistRequest| { &m.progressive },
                |m: &mut PersistRequest| { &mut m.progressive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistRequest>(
                "PersistRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistRequest {
        static instance: ::protobuf::rt::LazyV2<PersistRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistRequest::new)
    }
}

impl ::protobuf::Clear for PersistRequest {
    fn clear(&mut self) {
        self.cids.clear();
        self.refID.clear();
        self.progressive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistResponse {
    // message fields
    pub status: ::std::collections::HashMap<::std::string::String, bool>,
    pub errors: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistResponse {
    fn default() -> &'a PersistResponse {
        <PersistResponse as ::protobuf::Message>::default_instance()
    }
}

impl PersistResponse {
    pub fn new() -> PersistResponse {
        ::std::default::Default::default()
    }

    // repeated .pb.PersistResponse.StatusEntry status = 1;


    pub fn get_status(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.status, ::std::collections::HashMap::new())
    }

    // repeated .pb.PersistResponse.ErrorsEntry errors = 2;


    pub fn get_errors(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.errors, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PersistResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(1, &self.status, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.errors, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistResponse {
        PersistResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                "status",
                |m: &PersistResponse| { &m.status },
                |m: &mut PersistResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "errors",
                |m: &PersistResponse| { &m.errors },
                |m: &mut PersistResponse| { &mut m.errors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistResponse>(
                "PersistResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistResponse {
        static instance: ::protobuf::rt::LazyV2<PersistResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistResponse::new)
    }
}

impl ::protobuf::Clear for PersistResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum P2PREQTYPE {
    CLOSE = 0,
    FORWARD = 1,
    LISTEN = 2,
    LS = 3,
}

impl ::protobuf::ProtobufEnum for P2PREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<P2PREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(P2PREQTYPE::CLOSE),
            1 => ::std::option::Option::Some(P2PREQTYPE::FORWARD),
            2 => ::std::option::Option::Some(P2PREQTYPE::LISTEN),
            3 => ::std::option::Option::Some(P2PREQTYPE::LS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [P2PREQTYPE] = &[
            P2PREQTYPE::CLOSE,
            P2PREQTYPE::FORWARD,
            P2PREQTYPE::LISTEN,
            P2PREQTYPE::LS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<P2PREQTYPE>("P2PREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for P2PREQTYPE {
}

impl ::std::default::Default for P2PREQTYPE {
    fn default() -> Self {
        P2PREQTYPE::CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CONNMGMTREQTYPE {
    CM_CONNECT = 0,
    CM_DISCONNECT = 1,
    CM_STATUS = 2,
    CM_GET_PEERS = 3,
}

impl ::protobuf::ProtobufEnum for CONNMGMTREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CONNMGMTREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_CONNECT),
            1 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_DISCONNECT),
            2 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_STATUS),
            3 => ::std::option::Option::Some(CONNMGMTREQTYPE::CM_GET_PEERS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CONNMGMTREQTYPE] = &[
            CONNMGMTREQTYPE::CM_CONNECT,
            CONNMGMTREQTYPE::CM_DISCONNECT,
            CONNMGMTREQTYPE::CM_STATUS,
            CONNMGMTREQTYPE::CM_GET_PEERS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CONNMGMTREQTYPE>("CONNMGMTREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CONNMGMTREQTYPE {
}

impl ::std::default::Default for CONNMGMTREQTYPE {
    fn default() -> Self {
        CONNMGMTREQTYPE::CM_CONNECT
    }
}

impl ::protobuf::reflect::ProtobufValue for CONNMGMTREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASREQTYPE {
    EX_ENABLE = 0,
    EX_DISABLE = 1,
}

impl ::protobuf::ProtobufEnum for EXTRASREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASREQTYPE::EX_ENABLE),
            1 => ::std::option::Option::Some(EXTRASREQTYPE::EX_DISABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASREQTYPE] = &[
            EXTRASREQTYPE::EX_ENABLE,
            EXTRASREQTYPE::EX_DISABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EXTRASREQTYPE>("EXTRASREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EXTRASREQTYPE {
}

impl ::std::default::Default for EXTRASREQTYPE {
    fn default() -> Self {
        EXTRASREQTYPE::EX_ENABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EXTRASTYPE {
    IDENTIFY = 0,
    PUBSUB = 1,
    DISCOVERY = 2,
    MDNS = 3,
}

impl ::protobuf::ProtobufEnum for EXTRASTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EXTRASTYPE> {
        match value {
            0 => ::std::option::Option::Some(EXTRASTYPE::IDENTIFY),
            1 => ::std::option::Option::Some(EXTRASTYPE::PUBSUB),
            2 => ::std::option::Option::Some(EXTRASTYPE::DISCOVERY),
            3 => ::std::option::Option::Some(EXTRASTYPE::MDNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EXTRASTYPE] = &[
            EXTRASTYPE::IDENTIFY,
            EXTRASTYPE::PUBSUB,
            EXTRASTYPE::DISCOVERY,
            EXTRASTYPE::MDNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EXTRASTYPE>("EXTRASTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EXTRASTYPE {
}

impl ::std::default::Default for EXTRASTYPE {
    fn default() -> Self {
        EXTRASTYPE::IDENTIFY
    }
}

impl ::protobuf::reflect::ProtobufValue for EXTRASTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQTYPE {
    BS_DELETE = 0,
    BS_PUT = 1,
    BS_PUT_MANY = 2,
    BS_GET = 3,
    BS_GET_MANY = 4,
    BS_GET_ALL = 5,
    BS_GET_STATS = 6,
    BS_HAS = 7,
    BS_HASH_ON_READ_ENABLE = 8,
    BS_HASH_ON_READ_DISABLE = 9,
}

impl ::protobuf::ProtobufEnum for BSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(BSREQTYPE::BS_DELETE),
            1 => ::std::option::Option::Some(BSREQTYPE::BS_PUT),
            2 => ::std::option::Option::Some(BSREQTYPE::BS_PUT_MANY),
            3 => ::std::option::Option::Some(BSREQTYPE::BS_GET),
            4 => ::std::option::Option::Some(BSREQTYPE::BS_GET_MANY),
            5 => ::std::option::Option::Some(BSREQTYPE::BS_GET_ALL),
            6 => ::std::option::Option::Some(BSREQTYPE::BS_GET_STATS),
            7 => ::std::option::Option::Some(BSREQTYPE::BS_HAS),
            8 => ::std::option::Option::Some(BSREQTYPE::BS_HASH_ON_READ_ENABLE),
            9 => ::std::option::Option::Some(BSREQTYPE::BS_HASH_ON_READ_DISABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQTYPE] = &[
            BSREQTYPE::BS_DELETE,
            BSREQTYPE::BS_PUT,
            BSREQTYPE::BS_PUT_MANY,
            BSREQTYPE::BS_GET,
            BSREQTYPE::BS_GET_MANY,
            BSREQTYPE::BS_GET_ALL,
            BSREQTYPE::BS_GET_STATS,
            BSREQTYPE::BS_HAS,
            BSREQTYPE::BS_HASH_ON_READ_ENABLE,
            BSREQTYPE::BS_HASH_ON_READ_DISABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BSREQTYPE>("BSREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BSREQTYPE {
}

impl ::std::default::Default for BSREQTYPE {
    fn default() -> Self {
        BSREQTYPE::BS_DELETE
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BSREQOPTS {
    DEFAULT = 0,
    BS_FORCE = 1,
}

impl ::protobuf::ProtobufEnum for BSREQOPTS {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BSREQOPTS> {
        match value {
            0 => ::std::option::Option::Some(BSREQOPTS::DEFAULT),
            1 => ::std::option::Option::Some(BSREQOPTS::BS_FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BSREQOPTS] = &[
            BSREQOPTS::DEFAULT,
            BSREQOPTS::BS_FORCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BSREQOPTS>("BSREQOPTS", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BSREQOPTS {
}

impl ::std::default::Default for BSREQOPTS {
    fn default() -> Self {
        BSREQOPTS::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for BSREQOPTS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DAGREQTYPE {
    DAG_PUT = 0,
    DAG_GET = 1,
    DAG_NEW_NODE = 2,
    DAG_ADD_LINKS = 3,
    DAG_GET_LINKS = 4,
    DAG_STAT = 5,
    DAG_REMOVE = 6,
}

impl ::protobuf::ProtobufEnum for DAGREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DAGREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(DAGREQTYPE::DAG_PUT),
            1 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET),
            2 => ::std::option::Option::Some(DAGREQTYPE::DAG_NEW_NODE),
            3 => ::std::option::Option::Some(DAGREQTYPE::DAG_ADD_LINKS),
            4 => ::std::option::Option::Some(DAGREQTYPE::DAG_GET_LINKS),
            5 => ::std::option::Option::Some(DAGREQTYPE::DAG_STAT),
            6 => ::std::option::Option::Some(DAGREQTYPE::DAG_REMOVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DAGREQTYPE] = &[
            DAGREQTYPE::DAG_PUT,
            DAGREQTYPE::DAG_GET,
            DAGREQTYPE::DAG_NEW_NODE,
            DAGREQTYPE::DAG_ADD_LINKS,
            DAGREQTYPE::DAG_GET_LINKS,
            DAGREQTYPE::DAG_STAT,
            DAGREQTYPE::DAG_REMOVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DAGREQTYPE>("DAGREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DAGREQTYPE {
}

impl ::std::default::Default for DAGREQTYPE {
    fn default() -> Self {
        DAGREQTYPE::DAG_PUT
    }
}

impl ::protobuf::reflect::ProtobufValue for DAGREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KSREQTYPE {
    KS_HAS = 0,
    KS_GET = 1,
    KS_PUT = 2,
    KS_DELETE = 3,
    KS_LIST = 4,
}

impl ::protobuf::ProtobufEnum for KSREQTYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KSREQTYPE> {
        match value {
            0 => ::std::option::Option::Some(KSREQTYPE::KS_HAS),
            1 => ::std::option::Option::Some(KSREQTYPE::KS_GET),
            2 => ::std::option::Option::Some(KSREQTYPE::KS_PUT),
            3 => ::std::option::Option::Some(KSREQTYPE::KS_DELETE),
            4 => ::std::option::Option::Some(KSREQTYPE::KS_LIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KSREQTYPE] = &[
            KSREQTYPE::KS_HAS,
            KSREQTYPE::KS_GET,
            KSREQTYPE::KS_PUT,
            KSREQTYPE::KS_DELETE,
            KSREQTYPE::KS_LIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<KSREQTYPE>("KSREQTYPE", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for KSREQTYPE {
}

impl ::std::default::Default for KSREQTYPE {
    fn default() -> Self {
        KSREQTYPE::KS_HAS
    }
}

impl ::protobuf::reflect::ProtobufValue for KSREQTYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nnode.proto\x12\x02pb\x1a\nutil.proto\"\xd8\x02\n\nP2PRequest\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\x12\x18\n\x07verbose\x18\
    \x03\x20\x01(\x08R\x07verbose\x12\"\n\x0cprotocolName\x18\x04\x20\x01(\t\
    R\x0cprotocolName\x12$\n\rlistenAddress\x18\x05\x20\x01(\tR\rlistenAddre\
    ss\x12$\n\rtargetAddress\x18\x06\x20\x01(\tR\rtargetAddress\x12$\n\rremo\
    teAddress\x18\x07\x20\x01(\tR\rremoteAddress\x122\n\x14allowCustomProtoc\
    ols\x18\x08\x20\x01(\x08R\x14allowCustomProtocols\x12\"\n\x0creportPeerI\
    D\x18\t\x20\x01(\x08R\x0creportPeerID\"\xa8\x01\n\x0bP2PResponse\x120\n\
    \x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb.P2PREQTYPER\x0brequestType\
    \x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05names\x12\x20\n\x0bconnsClose\
    d\x18\x03\x20\x01(\x05R\x0bconnsClosed\x12/\n\x0bstreamInfos\x18\x04\x20\
    \x03(\x0b2\r.pb.P2PLsInfoR\x0bstreamInfos\"\x91\x01\n\tP2PLsInfo\x12\"\n\
    \x0cprotocolName\x18\x01\x20\x01(\tR\x0cprotocolName\x12$\n\rlistenAddre\
    ss\x18\x02\x20\x01(\tR\rlistenAddress\x12$\n\rtargetAddress\x18\x03\x20\
    \x01(\tR\rtargetAddress\x12\x14\n\x05local\x18\x04\x20\x01(\x08R\x05loca\
    l\",\n\x10GetPeersResponse\x12\x18\n\x07peerIDs\x18\x01\x20\x03(\tR\x07p\
    eerIDs\"\x82\x01\n\x0fConnMgmtRequest\x125\n\x0brequestType\x18\x01\x20\
    \x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12\x1e\n\nmultiAddrs\
    \x18\x02\x20\x03(\tR\nmultiAddrs\x12\x18\n\x07peerIDs\x18\x03\x20\x03(\t\
    R\x07peerIDs\"\xed\x02\n\x10ConnMgmtResponse\x125\n\x0brequestType\x18\
    \x01\x20\x01(\x0e2\x13.pb.CONNMGMTREQTYPER\x0brequestType\x12A\n\tconnec\
    ted\x18\x02\x20\x03(\x0b2#.pb.ConnMgmtResponse.ConnectedEntryR\tconnecte\
    d\x128\n\x06status\x18\x03\x20\x03(\x0b2\x20.pb.ConnMgmtResponse.StatusE\
    ntryR\x06status\x12\x18\n\x07peerIDs\x18\x04\x20\x03(\tR\x07peerIDs\x1a<\
    \n\x0eConnectedEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1aM\n\x0bStatusEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12(\n\x05value\x18\x02\
    \x20\x01(\x0b2\x12.pb.ConnMgmtStatusR\x05value:\x028\x01\"L\n\x0eConnMgm\
    tStatus\x12\"\n\x0cdisconnected\x18\x01\x20\x01(\x08R\x0cdisconnected\
    \x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reason\"z\n\rExtrasRequest\
    \x123\n\x0brequestType\x18\x01\x20\x01(\x0e2\x11.pb.EXTRASREQTYPER\x0bre\
    questType\x124\n\rextrasFeature\x18\x02\x20\x01(\x0e2\x0e.pb.EXTRASTYPER\
    \rextrasFeature\"\x89\x02\n\x11BlockstoreRequest\x12/\n\x0brequestType\
    \x18\x01\x20\x01(\x0e2\r.pb.BSREQTYPER\x0brequestType\x12'\n\x07reqOpts\
    \x18\x02\x20\x03(\x0e2\r.pb.BSREQOPTSR\x07reqOpts\x12\x12\n\x04cids\x18\
    \x03\x20\x03(\tR\x04cids\x12\x12\n\x04data\x18\x04\x20\x03(\x0cR\x04data\
    \x12\x1e\n\ncidVersion\x18\x05\x20\x01(\tR\ncidVersion\x12\x1a\n\x08hash\
    Func\x18\x07\x20\x01(\tR\x08hashFunc\x12\x14\n\x05refID\x18\x08\x20\x01(\
    \tR\x05refID\x12\x20\n\x0bprogressive\x18\t\x20\x01(\x08R\x0bprogressive\
    \"h\n\x12BlockstoreResponse\x12/\n\x0brequestType\x18\x01\x20\x01(\x0e2\
    \r.pb.BSREQTYPER\x0brequestType\x12!\n\x06blocks\x18\x02\x20\x03(\x0b2\t\
    .pb.BlockR\x06blocks\"A\n\x05Block\x12\x10\n\x03cid\x18\x01\x20\x01(\tR\
    \x03cid\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x12\n\x04siz\
    e\x18\x03\x20\x01(\x03R\x04size\"\x9f\x03\n\nDagRequest\x120\n\x0breques\
    tType\x18\x01\x20\x01(\x0e2\x0e.pb.DAGREQTYPER\x0brequestType\x12\x12\n\
    \x04data\x18\x02\x20\x01(\x0cR\x04data\x12&\n\x0eobjectEncoding\x18\x03\
    \x20\x01(\tR\x0eobjectEncoding\x120\n\x13serializationFormat\x18\x04\x20\
    \x01(\tR\x13serializationFormat\x12\x1a\n\x08hashFunc\x18\x05\x20\x01(\t\
    R\x08hashFunc\x12\x1e\n\ncidVersion\x18\x06\x20\x01(\x03R\ncidVersion\
    \x12\x12\n\x04hash\x18\x07\x20\x01(\tR\x04hash\x12/\n\x05links\x18\x08\
    \x20\x03(\x0b2\x19.pb.DagRequest.LinksEntryR\x05links\x12\x14\n\x05refID\
    \x18\t\x20\x01(\tR\x05refID\x12\x20\n\x0bprogressive\x18\n\x20\x01(\x08R\
    \x0bprogressive\x1a8\n\nLinksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb5\
    \x02\n\x0bDagResponse\x120\n\x0brequestType\x18\x01\x20\x01(\x0e2\x0e.pb\
    .DAGREQTYPER\x0brequestType\x12\x16\n\x06hashes\x18\x02\x20\x03(\tR\x06h\
    ashes\x12\x18\n\x07rawData\x18\x03\x20\x01(\x0cR\x07rawData\x12\"\n\x05l\
    inks\x18\x04\x20\x03(\x0b2\x0c.pb.IPLDLinkR\x05links\x12<\n\tnodeStats\
    \x18\x05\x20\x03(\x0b2\x1e.pb.DagResponse.NodeStatsEntryR\tnodeStats\x12\
    \x14\n\x05count\x18\x06\x20\x01(\x04R\x05count\x1aJ\n\x0eNodeStatsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\"\n\x05value\x18\x02\
    \x20\x01(\x0b2\x0c.pb.IPLDStatR\x05value:\x028\x01\"\xa4\x01\n\x08IPLDSt\
    at\x12\x1a\n\x08numLinks\x18\x01\x20\x01(\x03R\x08numLinks\x12\x1c\n\tbl\
    ockSize\x18\x02\x20\x01(\x03R\tblockSize\x12\x1a\n\x08linkSize\x18\x03\
    \x20\x01(\x03R\x08linkSize\x12&\n\x0ecumulativeSize\x18\x04\x20\x01(\x03\
    R\x0ecumulativeSize\x12\x1a\n\x08dataSize\x18\x05\x20\x01(\x03R\x08dataS\
    ize\"F\n\x08IPLDLink\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04size\x18\x03\x20\
    \x01(\x04R\x04size\"B\n\x08IPLDNode\x12\"\n\x05links\x18\x02\x20\x03(\
    \x0b2\x0c.pb.IPLDLinkR\x05links\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\"v\n\x0fKeystoreRequest\x12/\n\x0brequestType\x18\x01\x20\x01(\
    \x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name\x12\x1e\n\nprivateKey\x18\x03\x20\x01(\x0cR\nprivateKey\"\
    \x91\x01\n\x10KeystoreResponse\x12/\n\x0brequestType\x18\x01\x20\x01(\
    \x0e2\r.pb.KSREQTYPER\x0brequestType\x12\x1e\n\nprivateKey\x18\x02\x20\
    \x01(\x0cR\nprivateKey\x12\x1a\n\x08keyNames\x18\x03\x20\x03(\tR\x08keyN\
    ames\x12\x10\n\x03has\x18\x04\x20\x01(\x08R\x03has\"\\\n\x0ePersistReque\
    st\x12\x12\n\x04cids\x18\x01\x20\x03(\tR\x04cids\x12\x14\n\x05refID\x18\
    \x02\x20\x01(\tR\x05refID\x12\x20\n\x0bprogressive\x18\x05\x20\x01(\x08R\
    \x0bprogressive\"\xf9\x01\n\x0fPersistResponse\x127\n\x06status\x18\x01\
    \x20\x03(\x0b2\x1f.pb.PersistResponse.StatusEntryR\x06status\x127\n\x06e\
    rrors\x18\x02\x20\x03(\x0b2\x1f.pb.PersistResponse.ErrorsEntryR\x06error\
    s\x1a9\n\x0bStatusEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1a9\n\x0bError\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01*8\n\nP2PREQTYPE\x12\t\n\x05CLOSE\
    \x10\0\x12\x0b\n\x07FORWARD\x10\x01\x12\n\n\x06LISTEN\x10\x02\x12\x06\n\
    \x02LS\x10\x03*U\n\x0fCONNMGMTREQTYPE\x12\x0e\n\nCM_CONNECT\x10\0\x12\
    \x11\n\rCM_DISCONNECT\x10\x01\x12\r\n\tCM_STATUS\x10\x02\x12\x10\n\x0cCM\
    _GET_PEERS\x10\x03*.\n\rEXTRASREQTYPE\x12\r\n\tEX_ENABLE\x10\0\x12\x0e\n\
    \nEX_DISABLE\x10\x01*?\n\nEXTRASTYPE\x12\x0c\n\x08IDENTIFY\x10\0\x12\n\n\
    \x06PUBSUB\x10\x01\x12\r\n\tDISCOVERY\x10\x02\x12\x08\n\x04MDNS\x10\x03*\
    \xbb\x01\n\tBSREQTYPE\x12\r\n\tBS_DELETE\x10\0\x12\n\n\x06BS_PUT\x10\x01\
    \x12\x0f\n\x0bBS_PUT_MANY\x10\x02\x12\n\n\x06BS_GET\x10\x03\x12\x0f\n\
    \x0bBS_GET_MANY\x10\x04\x12\x0e\n\nBS_GET_ALL\x10\x05\x12\x10\n\x0cBS_GE\
    T_STATS\x10\x06\x12\n\n\x06BS_HAS\x10\x07\x12\x1a\n\x16BS_HASH_ON_READ_E\
    NABLE\x10\x08\x12\x1b\n\x17BS_HASH_ON_READ_DISABLE\x10\t*&\n\tBSREQOPTS\
    \x12\x0b\n\x07DEFAULT\x10\0\x12\x0c\n\x08BS_FORCE\x10\x01*|\n\nDAGREQTYP\
    E\x12\x0b\n\x07DAG_PUT\x10\0\x12\x0b\n\x07DAG_GET\x10\x01\x12\x10\n\x0cD\
    AG_NEW_NODE\x10\x02\x12\x11\n\rDAG_ADD_LINKS\x10\x03\x12\x11\n\rDAG_GET_\
    LINKS\x10\x04\x12\x0c\n\x08DAG_STAT\x10\x05\x12\x0e\n\nDAG_REMOVE\x10\
    \x06*K\n\tKSREQTYPE\x12\n\n\x06KS_HAS\x10\0\x12\n\n\x06KS_GET\x10\x01\
    \x12\n\n\x06KS_PUT\x10\x02\x12\r\n\tKS_DELETE\x10\x03\x12\x0b\n\x07KS_LI\
    ST\x10\x042\xb7\x03\n\x07NodeAPI\x127\n\x08ConnMgmt\x12\x13.pb.ConnMgmtR\
    equest\x1a\x14.pb.ConnMgmtResponse\"\0\x12(\n\x06Extras\x12\x11.pb.Extra\
    sRequest\x1a\t.pb.Empty\"\0\x12(\n\x03P2P\x12\x0e.pb.P2PRequest\x1a\x0f.\
    pb.P2PResponse\"\0\x12=\n\nBlockstore\x12\x15.pb.BlockstoreRequest\x1a\
    \x16.pb.BlockstoreResponse\"\0\x12G\n\x10BlockstoreStream\x12\x15.pb.Blo\
    ckstoreRequest\x1a\x16.pb.BlockstoreResponse\"\0(\x010\x01\x12(\n\x03Dag\
    \x12\x0e.pb.DagRequest\x1a\x0f.pb.DagResponse\"\0\x127\n\x08Keystore\x12\
    \x13.pb.KeystoreRequest\x1a\x14.pb.KeystoreResponse\"\0\x124\n\x07Persis\
    t\x12\x12.pb.PersistRequest\x1a\x13.pb.PersistResponse\"\0J\xc2\x8e\x01\
    \n\x07\x12\x05\0\0\x97\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x01\x08\n\n\t\n\x02\x03\0\x12\x03\x02\x07\x13\nP\n\x02\
    \x06\0\x12\x04\x05\0\x19\x01\x1aD\x20NodeAPI\x20provide\x20an\x20API\x20\
    to\x20control\x20the\x20underlying\x20custom\x20ipfs\x20node\r\n\n\n\n\
    \x03\x06\0\x01\x12\x03\x05\x08\x0f\nA\n\x04\x06\0\x02\0\x12\x03\x07\x04@\
    \x1a4\x20ConnMgmt\x20provides\x20control\x20over\x20libp2p\x20connection\
    s\r\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x07\x08\x10\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\x07\x11\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x07+;\
    \nD\n\x04\x06\0\x02\x01\x12\x03\t\x041\x1a7\x20Extras\x20provide\x20cont\
    rol\x20over\x20node\x20extras\x20capabilities\r\n\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03\t\x08\x0e\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\t\x0f\
    \x1c\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\t',\n\xe2\x01\n\x04\x06\0\x02\
    \x02\x12\x03\r\x041\x1a\xd4\x01\x20P2P\x20allows\x20control\x20of\x20gen\
    eralized\x20p2p\x20streams\x20for\x20tcp/udp\x20based\x20protocol.\r\n\
    \x20By\x20using\x20this\x20RPC,\x20we\x20can\x20tunnel\x20traffic\x20sim\
    ilar\x20to\x20ssh\x20tunneling\r\n\x20except\x20using\x20libp2p\x20as\
    \x20the\x20transport\x20layer,\x20and\x20and\x20tcp/udp\x20port.\r\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03\r\x08\x0b\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03\r\x0c\x16\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\r!,\nS\n\
    \x04\x06\0\x02\x03\x12\x03\x0f\x04F\x1aF\x20Blockstore\x20allows\x20low-\
    level\x20management\x20of\x20the\x20underlying\x20blockstore\r\n\n\x0c\n\
    \x05\x06\0\x02\x03\x01\x12\x03\x0f\x08\x12\n\x0c\n\x05\x06\0\x02\x03\x02\
    \x12\x03\x0f\x13$\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x0f/A\n\x89\x01\
    \n\x04\x06\0\x02\x04\x12\x03\x12\x04Z\x1a|\x20BlockstoreStream\x20is\x20\
    akin\x20to\x20Blockstore,\x20except\x20streamable\r\n\x20Once\x20v4\x20i\
    s\x20out,\x20condense\x20this\x20+\x20blockstore\x20into\x20a\x20single\
    \x20call\r\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x12\x08\x18\n\x0c\n\
    \x05\x06\0\x02\x04\x05\x12\x03\x12\x19\x1f\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03\x12\x201\n\x0c\n\x05\x06\0\x02\x04\x06\x12\x03\x12<B\n\x0c\n\
    \x05\x06\0\x02\x04\x03\x12\x03\x12CU\n[\n\x04\x06\0\x02\x05\x12\x03\x14\
    \x041\x1aN\x20Dag\x20is\x20a\x20unidirectional\x20rpc\x20allowing\x20man\
    ipulation\x20of\x20low-level\x20ipld\x20objects\r\n\n\x0c\n\x05\x06\0\
    \x02\x05\x01\x12\x03\x14\x08\x0b\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\
    \x14\x0c\x16\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03\x14!,\nV\n\x04\x06\0\
    \x02\x06\x12\x03\x16\x04@\x1aI\x20Keystore\x20is\x20a\x20unidirectional\
    \x20RPC\x20allowing\x20management\x20of\x20ipfs\x20keystores\r\n\n\x0c\n\
    \x05\x06\0\x02\x06\x01\x12\x03\x16\x08\x10\n\x0c\n\x05\x06\0\x02\x06\x02\
    \x12\x03\x16\x11\x20\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x16+;\n_\n\
    \x04\x06\0\x02\x07\x12\x03\x18\x04=\x1aR\x20Persist\x20is\x20used\x20to\
    \x20retrieve\x20data\x20from\x20the\x20network\x20and\x20make\x20it\x20a\
    vailable\x20locally\r\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\x18\x08\
    \x0f\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\x18\x10\x1e\n\x0c\n\x05\x06\0\
    \x02\x07\x03\x12\x03\x18)8\nZ\n\x02\x05\0\x12\x04\x1c\0%\x01\x1aN\x20P2P\
    REQTYPE\x20denotes\x20the\x20particular\x20type\x20of\x20request\x20bein\
    g\x20used\x20in\x20the\x20p2p\x20rpc\r\n\n\n\n\x03\x05\0\x01\x12\x03\x1c\
    \x05\x0f\n,\n\x04\x05\0\x02\0\x12\x03\x1e\x04\x0e\x1a\x1f\x20equivalent\
    \x20of\x20ipfs\x20p2p\x20close\r\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\
    \x1e\x04\t\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x1e\x0c\r\n.\n\x04\x05\0\
    \x02\x01\x12\x03\x20\x04\x10\x1a!\x20equivalent\x20of\x20ipfs\x20p2p\x20\
    forward\r\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x20\x04\x0b\n\x0c\n\
    \x05\x05\0\x02\x01\x02\x12\x03\x20\x0e\x0f\n-\n\x04\x05\0\x02\x02\x12\
    \x03\"\x04\x0f\x1a\x20\x20equivalent\x20of\x20ipfs\x20p2p\x20listen\r\n\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\"\x04\n\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03\"\r\x0e\n)\n\x04\x05\0\x02\x03\x12\x03$\x04\x0b\x1a\x1c\x20\
    equivalent\x20of\x20ipfs\x20p2p\x20ls\r\n\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03$\x04\x06\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03$\t\n\n_\n\x02\
    \x04\0\x12\x04(\0>\x01\x1aS\x20P2PRequest\x20is\x20a\x20request\x20messa\
    ge\x20holding\x20the\x20details\x20of\x20a\x20particular\x20P2P\x20rpc\
    \x20call\r\n\n\n\n\x03\x04\0\x01\x12\x03(\x08\x12\n*\n\x04\x04\0\x02\0\
    \x12\x03*\x04\x1f\x1a\x1d\x20indicates\x20the\x20request\x20type\r\n\n\r\
    \n\x05\x04\0\x02\0\x04\x12\x04*\x04(\x14\n\x0c\n\x05\x04\0\x02\0\x06\x12\
    \x03*\x04\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03*\x0f\x1a\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03*\x1d\x1e\n)\n\x04\x04\0\x02\x01\x12\x03,\x04\
    \x11\x1a\x1c\x20used\x20by:\x20P2PREQTYPE.CLOSE\r\n\n\r\n\x05\x04\0\x02\
    \x01\x04\x12\x04,\x04*\x1f\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03,\x04\
    \x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03,\t\x0c\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03,\x0f\x10\n&\n\x04\x04\0\x02\x02\x12\x03.\x04\x15\x1a\
    \x19\x20used\x20by:\x20P2PREQTYPE.LS\r\n\n\r\n\x05\x04\0\x02\x02\x04\x12\
    \x04.\x04,\x11\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03.\x04\x08\n\x0c\n\
    \x05\x04\0\x02\x02\x01\x12\x03.\t\x10\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x03.\x13\x14\nP\n\x04\x04\0\x02\x03\x12\x030\x04\x1c\x1aC\x20used\x20by\
    :\x20P2PREQTYPE.CLOSE,\x20P2PREQTYPE.FORWARD,\x20P2PREQTYPE.LISTEN\r\n\n\
    \r\n\x05\x04\0\x02\x03\x04\x12\x040\x04.\x15\n\x0c\n\x05\x04\0\x02\x03\
    \x05\x12\x030\x04\n\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x030\x0b\x17\n\x0c\
    \n\x05\x04\0\x02\x03\x03\x12\x030\x1a\x1b\n`\n\x04\x04\0\x02\x04\x12\x03\
    3\x04\x1d\x1aS\x20used\x20by:\x20P2PREQTYPE.CLOSE,\x20P2PREQTYPE.FORWARD\
    \r\n\x20must\x20be\x20specified\x20as\x20a\x20multiaddr\r\n\n\r\n\x05\
    \x04\0\x02\x04\x04\x12\x043\x040\x1c\n\x0c\n\x05\x04\0\x02\x04\x05\x12\
    \x033\x04\n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x033\x0b\x18\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x033\x1b\x1c\n`\n\x04\x04\0\x02\x05\x12\x036\x04\
    \x1d\x1aS\x20used\x20by:\x20P2PREQTYPE.CLOSE,\x20P2PREQTYPE.FORWARD\r\n\
    \x20must\x20be\x20specified\x20as\x20a\x20multiaddr\r\n\n\r\n\x05\x04\0\
    \x02\x05\x04\x12\x046\x043\x1d\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x036\
    \x04\n\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x036\x0b\x18\n\x0c\n\x05\x04\0\
    \x02\x05\x03\x12\x036\x1b\x1c\nM\n\x04\x04\0\x02\x06\x12\x039\x04\x1d\
    \x1a@\x20used\x20by:\x20P2PREQTYPE.LISTEN\r\n\x20must\x20be\x20specified\
    \x20as\x20a\x20multiaddr\r\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x049\x046\
    \x1d\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x039\x04\n\n\x0c\n\x05\x04\0\x02\
    \x06\x01\x12\x039\x0b\x18\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x039\x1b\x1c\
    \n>\n\x04\x04\0\x02\x07\x12\x03;\x04\"\x1a1\x20used\x20by:\x20P2PREQTYPE\
    .LISTEN,\x20P2PREQTYPE.FORWARD\r\n\n\r\n\x05\x04\0\x02\x07\x04\x12\x04;\
    \x049\x1d\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03;\x04\x08\n\x0c\n\x05\x04\
    \0\x02\x07\x01\x12\x03;\t\x1d\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03;\x20\
    !\n*\n\x04\x04\0\x02\x08\x12\x03=\x04\x1a\x1a\x1d\x20used\x20by:\x20P2PR\
    EQTYPE.LISTEN\r\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x04=\x04;\"\n\x0c\n\
    \x05\x04\0\x02\x08\x05\x12\x03=\x04\x08\n\x0c\n\x05\x04\0\x02\x08\x01\
    \x12\x03=\t\x15\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03=\x18\x19\nY\n\x02\
    \x04\x01\x12\x04A\0I\x01\x1aM\x20P2PResponse\x20is\x20a\x20response\x20m\
    essage\x20sent\x20in\x20response\x20to\x20a\x20P2PRequest\x20message\r\n\
    \n\n\n\x03\x04\x01\x01\x12\x03A\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\
    \x03B\x04\x1f\n\r\n\x05\x04\x01\x02\0\x04\x12\x04B\x04A\x15\n\x0c\n\x05\
    \x04\x01\x02\0\x06\x12\x03B\x04\x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03B\x0f\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03B\x1d\x1e\n*\n\x04\
    \x04\x01\x02\x01\x12\x03D\x04\x1e\x1a\x1d\x20sent\x20by:\x20P2PREQTYPE.L\
    ISTEN\r\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03D\x04\x0c\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03D\r\x13\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03D\x14\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03D\x1c\x1d\nV\n\x04\
    \x04\x01\x02\x02\x12\x03F\x04\x1a\x1aI\x20sent\x20by:\x20P2PREQTYPE.CLOS\
    E\x20to\x20indicate\x20the\x20number\x20of\x20connections\x20closed\r\n\
    \n\r\n\x05\x04\x01\x02\x02\x04\x12\x04F\x04D\x1e\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03F\x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03F\n\x15\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x03F\x18\x19\nP\n\x04\x04\x01\x02\x03\
    \x12\x03H\x04'\x1aC\x20sent\x20by:\x20P2PREQTYPE.LS\x20and\x20contains\
    \x20all\x20known\x20stream\x20information\r\n\n\x0c\n\x05\x04\x01\x02\
    \x03\x04\x12\x03H\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03H\r\x16\
    \n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03H\x17\"\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03H%&\nG\n\x02\x04\x02\x12\x04L\0R\x01\x1a;\x20P2PLsInfo\
    \x20contains\x20information\x20about\x20a\x20single\x20p2p\x20stream\r\n\
    \n\n\n\x03\x04\x02\x01\x12\x03L\x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03M\x04\x1c\n\r\n\x05\x04\x02\x02\0\x04\x12\x04M\x04L\x13\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03M\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03M\
    \x0b\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03M\x1a\x1b\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03N\x04\x1d\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04N\x04\
    M\x1c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03N\x04\n\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03N\x0b\x18\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03N\
    \x1b\x1c\n\x0b\n\x04\x04\x02\x02\x02\x12\x03O\x04\x1d\n\r\n\x05\x04\x02\
    \x02\x02\x04\x12\x04O\x04N\x1d\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03O\
    \x04\n\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03O\x0b\x18\n\x0c\n\x05\x04\
    \x02\x02\x02\x03\x12\x03O\x1b\x1c\nQ\n\x04\x04\x02\x02\x03\x12\x03Q\x04\
    \x13\x1aD\x20indicates\x20whether\x20or\x20not\x20this\x20is\x20a\x20p2p\
    \x20listener\x20or\x20local\x20listener\r\n\n\r\n\x05\x04\x02\x02\x03\
    \x04\x12\x04Q\x04O\x1d\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03Q\x04\x08\
    \n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03Q\t\x0e\n\x0c\n\x05\x04\x02\x02\
    \x03\x03\x12\x03Q\x11\x12\nX\n\x02\x04\x03\x12\x04U\0X\x01\x1aL\x20GetPe\
    ersResponse\x20is\x20a\x20response\x20to\x20GetPeers\x20containing\x20a\
    \x20slice\x20of\x20peer\x20IDs\r\n\n\n\n\x03\x04\x03\x01\x12\x03U\x08\
    \x18\n#\n\x04\x04\x03\x02\0\x12\x03W\x04\x20\x1a\x16\x20a\x20slice\x20of\
    \x20peer\x20IDs\r\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03W\x04\x0c\n\x0c\
    \n\x05\x04\x03\x02\0\x05\x12\x03W\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03W\x14\x1b\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03W\x1e\x1f\nX\n\
    \x02\x05\x01\x12\x04[\0e\x01\x1aL\x20CONNMGMTREQTYPE\x20indicates\x20the\
    \x20particular\x20ConnMgmt\x20request\x20being\x20performed\r\n\n\n\n\
    \x03\x05\x01\x01\x12\x03[\x05\x14\n>\n\x04\x05\x01\x02\0\x12\x03]\x04\
    \x13\x1a1\x20CM_CONNECT\x20is\x20used\x20to\x20connect\x20to\x20a\x20lib\
    p2p\x20peer\r\n\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03]\x04\x0e\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03]\x11\x12\nF\n\x04\x05\x01\x02\x01\x12\x03\
    _\x04\x16\x1a9\x20CM_DISCONNECT\x20is\x20used\x20to\x20disconnect\x20fro\
    m\x20a\x20libp2p\x20peer\r\n\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03_\
    \x04\x11\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03_\x14\x15\n\xa1\x01\n\
    \x04\x05\x01\x02\x02\x12\x03b\x04\x12\x1a\x93\x01\x20CM_STATUS\x20is\x20\
    used\x20to\x20return\x20status\x20information\x20about\x20libp2p\x20peer\
    \x20connections\r\n\x20useful\x20for\x20determining\x20whether\x20or\x20\
    not\x20we\x20are\x20connected\x20to\x20someone\r\n\n\x0c\n\x05\x05\x01\
    \x02\x02\x01\x12\x03b\x04\r\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03b\x10\
    \x11\n=\n\x04\x05\x01\x02\x03\x12\x03d\x04\x15\x1a0CM_GET_PEERS\x20is\
    \x20used\x20to\x20return\x20all\x20known\x20peers\r\n\n\x0c\n\x05\x05\
    \x01\x02\x03\x01\x12\x03d\x04\x10\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\
    \x03d\x13\x14\n\n\n\x02\x04\x04\x12\x04g\0p\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03g\x08\x17\nV\n\x04\x04\x04\x02\0\x12\x03i\x04$\x1aI\x20indicates\
    \x20the\x20particular\x20connection\x20management\x20request\x20being\
    \x20performed\r\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04i\x04g\x19\n\x0c\n\
    \x05\x04\x04\x02\0\x06\x12\x03i\x04\x13\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03i\x14\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03i\"#\n:\n\x04\x04\
    \x04\x02\x01\x12\x03l\x04#\x1a-\x20a\x20list\x20of\x20multiaddrs\r\n\x20\
    sent\x20by:\x20CM_CONNECT\r\n\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03l\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03l\r\x13\n\x0c\n\x05\x04\
    \x04\x02\x01\x01\x12\x03l\x14\x1e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03l!\"\nT\n\x04\x04\x04\x02\x02\x12\x03o\x04\x20\x1aG\x20a\x20list\x20\
    of\x20peer\x20IDs\r\n\x20sent\x20by:\x20CM_DISCONNECT,\x20CM_STATUS,\x20\
    CM_GET_PEERS\r\n\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03o\x04\x0c\n\x0c\
    \n\x05\x04\x04\x02\x02\x05\x12\x03o\r\x13\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03o\x14\x1b\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03o\x1e\x1f\n\
    \n\n\x02\x04\x05\x12\x04r\0y\x01\n\n\n\x03\x04\x05\x01\x12\x03r\x08\x18\
    \nV\n\x04\x04\x05\x02\0\x12\x03t\x04$\x1aI\x20indicates\x20the\x20partic\
    ular\x20connection\x20management\x20request\x20being\x20performed\r\n\n\
    \r\n\x05\x04\x05\x02\0\x04\x12\x04t\x04r\x1a\n\x0c\n\x05\x04\x05\x02\0\
    \x06\x12\x03t\x04\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03t\x14\x1f\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03t\"#\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x03u\x04$\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04u\x04t$\n\x0c\n\x05\x04\
    \x05\x02\x01\x06\x12\x03u\x04\x15\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\
    \x03u\x16\x1f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03u\"#\ni\n\x04\x04\
    \x05\x02\x02\x12\x03w\x04+\x1a\\\x20a\x20map\x20of\x20the\x20peer\x20id,\
    \x20and\x20a\x20custom\x20message\x20indicating\x20success,\x20or\x20why\
    \x20there\x20was\x20a\x20failure\r\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\
    \x04w\x04u$\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03w\x04\x1f\n\x0c\n\x05\
    \x04\x05\x02\x02\x01\x12\x03w\x20&\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\
    \x03w)*\n\x0b\n\x04\x04\x05\x02\x03\x12\x03x\x04\x20\n\x0c\n\x05\x04\x05\
    \x02\x03\x04\x12\x03x\x04\x0c\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03x\r\
    \x13\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03x\x14\x1b\n\x0c\n\x05\x04\
    \x05\x02\x03\x03\x12\x03x\x1e\x1f\nQ\n\x02\x04\x06\x12\x05|\0\x81\x01\
    \x01\x1aD\x20Contains\x20status\x20information\x20about\x20a\x20particul\
    ar\x20disconnect\x20attempt\r\n\n\n\n\x03\x04\x06\x01\x12\x03|\x08\x16\n\
    @\n\x04\x04\x06\x02\0\x12\x03~\x04\x1a\x1a3\x20indicate\x20whether\x20or\
    \x20not\x20we\x20actually\x20disconnected\r\n\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04~\x04|\x18\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03~\x04\x08\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03~\t\x15\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03~\x18\x19\nE\n\x04\x04\x06\x02\x01\x12\x04\x80\x01\x04\x16\
    \x1a7\x20if\x20disconnected\x20is\x20false,\x20the\x20reason\x20why\x20i\
    t\x20is\x20false\r\n\n\x0e\n\x05\x04\x06\x02\x01\x04\x12\x05\x80\x01\x04\
    ~\x1a\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x80\x01\x04\n\n\r\n\x05\x04\
    \x06\x02\x01\x01\x12\x04\x80\x01\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x03\
    \x12\x04\x80\x01\x14\x15\nV\n\x02\x05\x02\x12\x06\x84\x01\0\x89\x01\x01\
    \x1aH\x20EXTRASREQTYPE\x20indicates\x20the\x20particular\x20Extras\x20re\
    quest\x20being\x20performed\r\n\n\x0b\n\x03\x05\x02\x01\x12\x04\x84\x01\
    \x05\x12\nM\n\x04\x05\x02\x02\0\x12\x04\x86\x01\x04\x12\x1a?\x20EX_ENABL\
    E\x20is\x20used\x20to\x20enable\x20a\x20particular\x20node\x20extras\x20\
    feature\r\n\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x86\x01\x04\r\n\r\n\x05\
    \x05\x02\x02\0\x02\x12\x04\x86\x01\x10\x11\nO\n\x04\x05\x02\x02\x01\x12\
    \x04\x88\x01\x04\x13\x1aA\x20EX_DISABLE\x20is\x20used\x20to\x20disable\
    \x20a\x20particular\x20node\x20extras\x20feature\r\n\n\r\n\x05\x05\x02\
    \x02\x01\x01\x12\x04\x88\x01\x04\x0e\n\r\n\x05\x05\x02\x02\x01\x02\x12\
    \x04\x88\x01\x11\x12\n<\n\x02\x05\x03\x12\x06\x8c\x01\0\x95\x01\x01\x1a.\
    \x20EXTRASTYPE\x20denotes\x20a\x20particular\x20extras\x20type\r\n\n\x0b\
    \n\x03\x05\x03\x01\x12\x04\x8c\x01\x05\x0f\n1\n\x04\x05\x03\x02\0\x12\
    \x04\x8e\x01\x04\x11\x1a#\x20IDENTIFY\x20is\x20the\x20identify\x20servic\
    e\r\n\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x8e\x01\x04\x0c\n\r\n\x05\x05\
    \x03\x02\0\x02\x12\x04\x8e\x01\x0f\x10\n3\n\x04\x05\x03\x02\x01\x12\x04\
    \x90\x01\x04\x0f\x1a%\x20PUBSUB\x20is\x20the\x20libp2p\x20pubsub\x20syst\
    em\r\n\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\x90\x01\x04\n\n\r\n\x05\x05\
    \x03\x02\x01\x02\x12\x04\x90\x01\r\x0e\n8\n\x04\x05\x03\x02\x02\x12\x04\
    \x92\x01\x04\x12\x1a*\x20DISCOVERY\x20is\x20a\x20libp2p\x20discovery\x20\
    service\r\n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\x92\x01\x04\r\n\r\n\
    \x05\x05\x03\x02\x02\x02\x12\x04\x92\x01\x10\x11\n@\n\x04\x05\x03\x02\
    \x03\x12\x04\x94\x01\x04\r\x1a2\x20MDNS\x20is\x20used\x20to\x20discover\
    \x20libp2p\x20hosts\x20over\x20mdns\r\n\n\r\n\x05\x05\x03\x02\x03\x01\
    \x12\x04\x94\x01\x04\x08\n\r\n\x05\x05\x03\x02\x03\x02\x12\x04\x94\x01\
    \x0b\x0c\n\x0c\n\x02\x04\x07\x12\x06\x97\x01\0\x9c\x01\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x97\x01\x08\x15\n6\n\x04\x04\x07\x02\0\x12\x04\x99\
    \x01\x04\"\x1a(\x20indicates\x20the\x20request\x20being\x20performed\r\n\
    \n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x99\x01\x04\x97\x01\x17\n\r\n\x05\
    \x04\x07\x02\0\x06\x12\x04\x99\x01\x04\x11\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\x99\x01\x12\x1d\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x99\x01\x20\
    !\nE\n\x04\x04\x07\x02\x01\x12\x04\x9b\x01\x04!\x1a7\x20indicates\x20the\
    \x20extras\x20feature\x20this\x20request\x20applies\x20to\r\n\n\x0f\n\
    \x05\x04\x07\x02\x01\x04\x12\x06\x9b\x01\x04\x99\x01\"\n\r\n\x05\x04\x07\
    \x02\x01\x06\x12\x04\x9b\x01\x04\x0e\n\r\n\x05\x04\x07\x02\x01\x01\x12\
    \x04\x9b\x01\x0f\x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9b\x01\x1f\
    \x20\nB\n\x02\x05\x04\x12\x06\xa0\x01\0\xb6\x01\x01\x1a4\x20BSREQTYPE\
    \x20is\x20a\x20particular\x20blockstore\x20request\x20type\r\n\n\x0b\n\
    \x03\x05\x04\x01\x12\x04\xa0\x01\x05\x0e\nC\n\x04\x05\x04\x02\0\x12\x04\
    \xa2\x01\x04\x12\x1a5\x20BS_DELETE\x20is\x20used\x20to\x20delete\x20a\
    \x20block\x20from\x20the\x20store\r\n\n\r\n\x05\x05\x04\x02\0\x01\x12\
    \x04\xa2\x01\x04\r\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xa2\x01\x10\x11\n\
    B\n\x04\x05\x04\x02\x01\x12\x04\xa4\x01\x04\x0f\x1a4\x20BS_PUT\x20is\x20\
    used\x20to\x20put\x20a\x20single\x20block\x20in\x20the\x20store\r\n\n\r\
    \n\x05\x05\x04\x02\x01\x01\x12\x04\xa4\x01\x04\n\n\r\n\x05\x05\x04\x02\
    \x01\x02\x12\x04\xa4\x01\r\x0e\nD\n\x04\x05\x04\x02\x02\x12\x04\xa6\x01\
    \x04\x14\x1a6\x20BS_PUT_MANY\x20is\x20used\x20to\x20put\x20many\x20block\
    s\x20in\x20the\x20store\r\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xa6\
    \x01\x04\x0f\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xa6\x01\x12\x13\n=\n\
    \x04\x05\x04\x02\x03\x12\x04\xa8\x01\x04\x0f\x1a/\x20BS_GET\x20is\x20use\
    d\x20to\x20get\x20a\x20block\x20from\x20the\x20store\r\n\n\r\n\x05\x05\
    \x04\x02\x03\x01\x12\x04\xa8\x01\x04\n\n\r\n\x05\x05\x04\x02\x03\x02\x12\
    \x04\xa8\x01\r\x0e\nF\n\x04\x05\x04\x02\x04\x12\x04\xaa\x01\x04\x14\x1a8\
    \x20BS_GET_MANY\x20is\x20used\x20to\x20get\x20many\x20blocks\x20from\x20\
    the\x20store\r\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xaa\x01\x04\x0f\n\
    \r\n\x05\x05\x04\x02\x04\x02\x12\x04\xaa\x01\x12\x13\n\x80\x01\n\x04\x05\
    \x04\x02\x05\x12\x04\xad\x01\x04\x13\x1ar\x20BS_GET_ALL\x20is\x20used\
    \x20to\x20retrieve\x20all\x20blocks\x20from\x20the\x20store\r\n\x20It\
    \x20is\x20the\x20gRPC\x20equivalent\x20of\x20Blockstore::AllKeysChan\r\n\
    \n\r\n\x05\x05\x04\x02\x05\x01\x12\x04\xad\x01\x04\x0e\n\r\n\x05\x05\x04\
    \x02\x05\x02\x12\x04\xad\x01\x11\x12\nT\n\x04\x05\x04\x02\x06\x12\x04\
    \xaf\x01\x04\x15\x1aF\x20BS_GET_STATS\x20is\x20used\x20to\x20retrieve\
    \x20statistics\x20about\x20individual\x20blocks\r\n\n\r\n\x05\x05\x04\
    \x02\x06\x01\x12\x04\xaf\x01\x04\x10\n\r\n\x05\x05\x04\x02\x06\x02\x12\
    \x04\xaf\x01\x13\x14\nL\n\x04\x05\x04\x02\x07\x12\x04\xb1\x01\x04\x0f\
    \x1a>\x20BS_HAS\x20is\x20used\x20to\x20retrieve\x20whether\x20or\x20not\
    \x20we\x20have\x20the\x20block\r\n\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\
    \xb1\x01\x04\n\n\r\n\x05\x05\x04\x02\x07\x02\x12\x04\xb1\x01\r\x0e\nF\n\
    \x04\x05\x04\x02\x08\x12\x04\xb3\x01\x04\x1f\x1a8\x20BS_HASH_ON_READ_ENA\
    BLE\x20is\x20used\x20to\x20enable\x20hash\x20on\x20read\r\n\n\r\n\x05\
    \x05\x04\x02\x08\x01\x12\x04\xb3\x01\x04\x1a\n\r\n\x05\x05\x04\x02\x08\
    \x02\x12\x04\xb3\x01\x1d\x1e\nH\n\x04\x05\x04\x02\t\x12\x04\xb5\x01\x04\
    \x20\x1a:\x20BS_HASH_ON_READ_DISABLE\x20is\x20used\x20to\x20disable\x20h\
    ash\x20on\x20read\r\n\n\r\n\x05\x05\x04\x02\t\x01\x12\x04\xb5\x01\x04\
    \x1b\n\r\n\x05\x05\x04\x02\t\x02\x12\x04\xb5\x01\x1e\x1f\n>\n\x02\x05\
    \x05\x12\x06\xb9\x01\0\xbe\x01\x01\x1a0\x20BSREQOPTS\x20are\x20options\
    \x20for\x20blockstore\x20requests\r\n\n\x0b\n\x03\x05\x05\x01\x12\x04\
    \xb9\x01\x05\x0e\n>\n\x04\x05\x05\x02\0\x12\x04\xbb\x01\x04\x10\x1a0\x20\
    DEFAULT\x20indicates\x20to\x20use\x20the\x20default\x20settings\r\n\n\r\
    \n\x05\x05\x05\x02\0\x01\x12\x04\xbb\x01\x04\x0b\n\r\n\x05\x05\x05\x02\0\
    \x02\x12\x04\xbb\x01\x0e\x0f\nZ\n\x04\x05\x05\x02\x01\x12\x04\xbd\x01\
    \x04\x11\x1aL\x20BS_FORCE\x20indicates\x20to\x20force\x20the\x20request\
    \x20regardless\x20of\x20any\x20possible\x20issues\r\n\n\r\n\x05\x05\x05\
    \x02\x01\x01\x12\x04\xbd\x01\x04\x0c\n\r\n\x05\x05\x05\x02\x01\x02\x12\
    \x04\xbd\x01\x0f\x10\nK\n\x02\x04\x08\x12\x06\xc1\x01\0\xd9\x01\x01\x1a=\
    \x20BlockstoreRequest\x20is\x20a\x20message\x20used\x20to\x20control\x20\
    blockstores\r\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc1\x01\x08\x19\nB\n\x04\
    \x04\x08\x02\0\x12\x04\xc3\x01\x04\x1e\x1a4\x20\x20indicates\x20the\x20p\
    articular\x20request\x20type\x20being\x20made\r\n\n\x0f\n\x05\x04\x08\
    \x02\0\x04\x12\x06\xc3\x01\x04\xc1\x01\x1b\n\r\n\x05\x04\x08\x02\0\x06\
    \x12\x04\xc3\x01\x04\r\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc3\x01\x0e\
    \x19\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc3\x01\x1c\x1d\n*\n\x04\x04\
    \x08\x02\x01\x12\x04\xc5\x01\x04#\x1a\x1c\x20optional\x20request\x20sett\
    ings\r\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xc5\x01\x04\x0c\n\r\n\x05\
    \x04\x08\x02\x01\x06\x12\x04\xc5\x01\r\x16\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\xc5\x01\x17\x1e\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xc5\x01!\
    \"\nW\n\x04\x04\x08\x02\x02\x12\x04\xc8\x01\x04\x1d\x1aI\x20cids\x20of\
    \x20blocks\r\n\x20sent\x20by:\x20BS_DELETE,\x20BS_GET,\x20BS_GET_MANY,\
    \x20BS_GET_STATS\r\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xc8\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xc8\x01\r\x13\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\xc8\x01\x14\x18\n\r\n\x05\x04\x08\x02\x02\x03\
    \x12\x04\xc8\x01\x1b\x1c\nG\n\x04\x04\x08\x02\x03\x12\x04\xcb\x01\x04\
    \x1c\x1a9\x20the\x20data\x20we\x20are\x20putting\r\n\x20sent\x20by:\x20B\
    S_PUT,\x20BS_PUT_MANY\r\n\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\xcb\x01\
    \x04\x0c\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xcb\x01\r\x12\n\r\n\x05\
    \x04\x08\x02\x03\x01\x12\x04\xcb\x01\x13\x17\n\r\n\x05\x04\x08\x02\x03\
    \x03\x12\x04\xcb\x01\x1a\x1b\nn\n\x04\x04\x08\x02\x04\x12\x04\xce\x01\
    \x04\x1a\x1a`\x20the\x20cid\x20version\x20to\x20use\x20when\x20construct\
    ing\x20blocks,\x20default\x20is\x20v1\r\n\x20sent\x20by:\x20BS_PUT,\x20B\
    S_PUT_MANY\r\n\n\x0f\n\x05\x04\x08\x02\x04\x04\x12\x06\xce\x01\x04\xcb\
    \x01\x1c\n\r\n\x05\x04\x08\x02\x04\x05\x12\x04\xce\x01\x04\n\n\r\n\x05\
    \x04\x08\x02\x04\x01\x12\x04\xce\x01\x0b\x15\n\r\n\x05\x04\x08\x02\x04\
    \x03\x12\x04\xce\x01\x18\x19\nv\n\x04\x04\x08\x02\x05\x12\x04\xd1\x01\
    \x04\x18\x1ah\x20the\x20hash\x20function\x20to\x20use\x20when\x20constru\
    cting\x20blocks,\x20default\x20is\x20sha2-256\r\n\x20sent\x20by:\x20BS_P\
    UT,\x20BS_PUT_MANY\r\n\n\x0f\n\x05\x04\x08\x02\x05\x04\x12\x06\xd1\x01\
    \x04\xce\x01\x1a\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\xd1\x01\x04\n\n\r\
    \n\x05\x04\x08\x02\x05\x01\x12\x04\xd1\x01\x0b\x13\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\xd1\x01\x16\x17\n\xb3\x02\n\x04\x04\x08\x02\x06\x12\x04\
    \xd6\x01\x04\x15\x1a\xa4\x02\x20reference\x20ID\x20to\x20mark\x20the\x20\
    blocks\x20of\x20this\x20operation\x20with\r\n\x20when\x20sent\x20by\x20B\
    S_PUT,\x20BS_PUT_MANY:\x20only\x20put\x20if\x20the\x20id\x20is\x20not\
    \x20marked\x20on\x20block,\x20otherwise\x20noop\r\n\x20when\x20sent\x20b\
    y\x20BS_GET,\x20BS_GET_MANY:\x20only\x20get\x20if\x20the\x20id\x20is\x20\
    marked\x20on\x20block\r\n\x20when\x20sent\x20by\x20BS_DELETE:\x20only\
    \x20delete\x20if\x20the\x20id\x20is\x20marked\x20on\x20block\r\n\n\x0f\n\
    \x05\x04\x08\x02\x06\x04\x12\x06\xd6\x01\x04\xd1\x01\x18\n\r\n\x05\x04\
    \x08\x02\x06\x05\x12\x04\xd6\x01\x04\n\n\r\n\x05\x04\x08\x02\x06\x01\x12\
    \x04\xd6\x01\x0b\x10\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\xd6\x01\x13\
    \x14\n;\n\x04\x04\x08\x02\x07\x12\x04\xd8\x01\x04\x19\x1a-\x20if\x20refI\
    D\x20is\x20set,\x20allows\x20progressive\x20upload\r\n\n\x0f\n\x05\x04\
    \x08\x02\x07\x04\x12\x06\xd8\x01\x04\xd6\x01\x15\n\r\n\x05\x04\x08\x02\
    \x07\x05\x12\x04\xd8\x01\x04\x08\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\
    \xd8\x01\t\x14\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\xd8\x01\x17\x18\nH\
    \n\x02\x04\t\x12\x06\xdc\x01\0\xe9\x01\x01\x1a:\x20BlockstoreResponse\
    \x20is\x20a\x20response\x20to\x20a\x20BlockstoreRequest\r\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xdc\x01\x08\x1a\nA\n\x04\x04\t\x02\0\x12\x04\xde\x01\
    \x04\x1e\x1a3\x20indicates\x20the\x20particular\x20request\x20type\x20be\
    ing\x20made\r\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xde\x01\x04\xdc\x01\
    \x1c\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xde\x01\x04\r\n\r\n\x05\x04\t\x02\
    \0\x01\x12\x04\xde\x01\x0e\x19\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xde\x01\
    \x1c\x1d\n\x80\x03\n\x04\x04\t\x02\x01\x12\x04\xe8\x01\x04\x1e\x1a\xf1\
    \x02\x20a\x20copy\x20of\x20blocks\x20from\x20the\x20blockstore\r\n\x20se\
    nt\x20by:\x20BS_PUT,\x20BS_PUT_MANY,\x20BS_GET,\x20BS_GET_MANY,\x20BS_GE\
    T_STATS,\x20BS_GET_ALL\r\n\r\n\x20in\x20the\x20case\x20of\x20BS_PUT,\x20\
    and\x20BS_PUT_MANY\x20requests\r\n\x20the\x20data\x20field\x20will\x20be\
    \x20empty\x20as\x20this\x20is\x20only\x20populated\r\n\x20by\x20get\x20r\
    equests\r\n\r\n\x20in\x20the\x20case\x20of\x20BS_GET_STATS\x20only\x20th\
    e\x20cid,\x20and\x20size\x20params\r\n\x20will\x20be\x20filled\x20out,\
    \x20since\x20we\x20are\x20just\x20interested\x20in\x20the\x20size\r\n\n\
    \r\n\x05\x04\t\x02\x01\x04\x12\x04\xe8\x01\x04\x0c\n\r\n\x05\x04\t\x02\
    \x01\x06\x12\x04\xe8\x01\r\x12\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xe8\
    \x01\x13\x19\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xe8\x01\x1c\x1d\n\x0c\n\
    \x02\x04\n\x12\x06\xeb\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xeb\x01\x08\r\n3\n\x04\x04\n\x02\0\x12\x04\xed\x01\x04\x13\x1a%\x20cid\
    \x20is\x20the\x20identifier\x20of\x20the\x20block\r\n\n\x0f\n\x05\x04\n\
    \x02\0\x04\x12\x06\xed\x01\x04\xeb\x01\x0f\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\xed\x01\x04\n\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xed\x01\x0b\x0e\n\r\
    \n\x05\x04\n\x02\0\x03\x12\x04\xed\x01\x11\x12\n9\n\x04\x04\n\x02\x01\
    \x12\x04\xef\x01\x04\x13\x1a+\x20data\x20is\x20the\x20actual\x20contents\
    \x20of\x20the\x20block\r\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xef\x01\
    \x04\xed\x01\x13\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xef\x01\x04\t\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\xef\x01\n\x0e\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\xef\x01\x11\x12\n\x8d\x01\n\x04\x04\n\x02\x02\x12\x04\xf3\x01\
    \x04\x13\x1a\x7f\x20size\x20of\x20the\x20block,\x20only\x20filled\x20out\
    \x20by\x20BS_GET_STATS\r\n\x20since\x20if\x20we\x20just\x20want\x20stats\
    ,\x20we\x20don't\x20want\x20to\x20\r\n\x20retrieve\x20all\x20the\x20data\
    .\r\n\n\x0f\n\x05\x04\n\x02\x02\x04\x12\x06\xf3\x01\x04\xef\x01\x13\n\r\
    \n\x05\x04\n\x02\x02\x05\x12\x04\xf3\x01\x04\t\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xf3\x01\n\x0e\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xf3\x01\
    \x11\x12\nS\n\x02\x05\x06\x12\x06\xf7\x01\0\x86\x02\x01\x1aE\x20DAGREQTY\
    PE\x20indicates\x20the\x20particular\x20DagAPI\x20request\x20being\x20pe\
    rformed\r\n\n\x0b\n\x03\x05\x06\x01\x12\x04\xf7\x01\x05\x0f\n8\n\x04\x05\
    \x06\x02\0\x12\x04\xf9\x01\x04\x10\x1a*\x20DAG_PUT\x20is\x20used\x20to\
    \x20add\x20new\x20IPLD\x20objects\r\n\n\r\n\x05\x05\x06\x02\0\x01\x12\
    \x04\xf9\x01\x04\x0b\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xf9\x01\x0e\x0f\
    \n=\n\x04\x05\x06\x02\x01\x12\x04\xfb\x01\x04\x10\x1a/\x20DAG_GET\x20is\
    \x20used\x20to\x20retrieve\x20IPLD\x20object\x20data\r\n\n\r\n\x05\x05\
    \x06\x02\x01\x01\x12\x04\xfb\x01\x04\x0b\n\r\n\x05\x05\x06\x02\x01\x02\
    \x12\x04\xfb\x01\x0e\x0f\nF\n\x04\x05\x06\x02\x02\x12\x04\xfd\x01\x04\
    \x15\x1a8\x20DAG_NEW_NODE\x20is\x20used\x20to\x20create\x20a\x20new\x20I\
    PLD\x20node\x20object\r\n\n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\xfd\x01\
    \x04\x10\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xfd\x01\x13\x14\nJ\n\x04\
    \x05\x06\x02\x03\x12\x04\xff\x01\x04\x16\x1a<\x20DAG_ADD_LINKS\x20is\x20\
    used\x20to\x20add\x20links\x20to\x20an\x20IPLD\x20node\x20object\r\n\n\r\
    \n\x05\x05\x06\x02\x03\x01\x12\x04\xff\x01\x04\x11\n\r\n\x05\x05\x06\x02\
    \x03\x02\x12\x04\xff\x01\x14\x15\n]\n\x04\x05\x06\x02\x04\x12\x04\x81\
    \x02\x04\x16\x1aO\x20DAG_GET_LINKS\x20is\x20used\x20to\x20retrieve\x20al\
    l\x20links\x20contained\x20in\x20an\x20IPLD\x20node\x20object\r\n\n\r\n\
    \x05\x05\x06\x02\x04\x01\x12\x04\x81\x02\x04\x11\n\r\n\x05\x05\x06\x02\
    \x04\x02\x12\x04\x81\x02\x14\x15\nH\n\x04\x05\x06\x02\x05\x12\x04\x83\
    \x02\x04\x11\x1a:\x20DAG_STAT\x20is\x20used\x20to\x20retrieve\x20ipld.No\
    deStats\x20information\r\n\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\x83\x02\
    \x04\x0c\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\x83\x02\x0f\x10\n5\n\x04\
    \x05\x06\x02\x06\x12\x04\x85\x02\x04\x13\x1a'\x20DAG_REMOVE\x20is\x20the\
    \x20inverse\x20of\x20DAG_PUT\r\n\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\
    \x85\x02\x04\x0e\n\r\n\x05\x05\x06\x02\x06\x02\x12\x04\x85\x02\x11\x12\n\
    B\n\x02\x04\x0b\x12\x06\x89\x02\0\xa7\x02\x01\x1a4\x20Used\x20to\x20subm\
    it\x20a\x20request\x20to\x20Dag\x20or\x20DagStream\x20RPCs\r\n\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\x89\x02\x08\x12\nS\n\x04\x04\x0b\x02\0\x12\x04\
    \x8c\x02\x04\x1f\x1aE\x20indicates\x20the\x20request\x20being\x20perform\
    ed\r\n\x20sent\x20by:\x20all\x20request\x20types\r\n\n\x0f\n\x05\x04\x0b\
    \x02\0\x04\x12\x06\x8c\x02\x04\x89\x02\x14\n\r\n\x05\x04\x0b\x02\0\x06\
    \x12\x04\x8c\x02\x04\x0e\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x8c\x02\x0f\
    \x1a\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8c\x02\x1d\x1e\nN\n\x04\x04\
    \x0b\x02\x01\x12\x04\x8f\x02\x04\x13\x1a@\x20data\x20that\x20we\x20will\
    \x20be\x20storing\r\n\x20sent\x20by:\x20DAG_PUT,\x20DAG_NEW_NODE\r\n\n\
    \x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\x8f\x02\x04\x8c\x02\x1f\n\r\n\x05\
    \x04\x0b\x02\x01\x05\x12\x04\x8f\x02\x04\t\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\x8f\x02\n\x0e\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x8f\x02\x11\
    \x12\nZ\n\x04\x04\x0b\x02\x02\x12\x04\x92\x02\x04\x1e\x1aL\x20the\x20obj\
    ect\x20encoding\x20type\x20(raw,\x20cbor,\x20protobuf,\x20etc...)\r\n\
    \x20sent\x20by:\x20DAG_PUT\r\n\n\x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\
    \x92\x02\x04\x8f\x02\x13\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x92\x02\
    \x04\n\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x92\x02\x0b\x19\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\x92\x02\x1c\x1d\nZ\n\x04\x04\x0b\x02\x03\
    \x12\x04\x95\x02\x04#\x1aL\x20the\x20serialization\x20format\x20(raw,\
    \x20cbor,\x20protobuf,\x20etc...)\r\n\x20sent\x20by:\x20DAG_PUT\r\n\n\
    \x0f\n\x05\x04\x0b\x02\x03\x04\x12\x06\x95\x02\x04\x92\x02\x1e\n\r\n\x05\
    \x04\x0b\x02\x03\x05\x12\x04\x95\x02\x04\n\n\r\n\x05\x04\x0b\x02\x03\x01\
    \x12\x04\x95\x02\x0b\x1e\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x95\x02!\
    \"\ny\n\x04\x04\x0b\x02\x04\x12\x04\x98\x02\x04\x18\x1ak\x20the\x20hash\
    \x20function\x20to\x20to\x20use\x20(sha2-256,\x20sha3-512,\x20etc...)\r\
    \n\x20sent\x20by:\x20DAG_PUT,\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS\r\n\n\
    \x0f\n\x05\x04\x0b\x02\x04\x04\x12\x06\x98\x02\x04\x95\x02#\n\r\n\x05\
    \x04\x0b\x02\x04\x05\x12\x04\x98\x02\x04\n\n\r\n\x05\x04\x0b\x02\x04\x01\
    \x12\x04\x98\x02\x0b\x13\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x98\x02\
    \x16\x17\nO\n\x04\x04\x0b\x02\x05\x12\x04\x9b\x02\x04\x19\x1aA\x20the\
    \x20cid\x20version\x20to\x20use\x20(0,\x201)\r\n\x20sent\x20by:\x20DAG_P\
    UT,\x20DAG_NEW_NODE\r\n\n\x0f\n\x05\x04\x0b\x02\x05\x04\x12\x06\x9b\x02\
    \x04\x98\x02\x18\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x9b\x02\x04\t\n\r\
    \n\x05\x04\x0b\x02\x05\x01\x12\x04\x9b\x02\n\x14\n\r\n\x05\x04\x0b\x02\
    \x05\x03\x12\x04\x9b\x02\x17\x18\n\x84\x01\n\x04\x04\x0b\x02\x06\x12\x04\
    \x9e\x02\x04\x14\x1av\x20the\x20hash\x20of\x20the\x20object\x20we\x20are\
    \x20processing\r\n\x20sent\x20by:\x20DAG_GET,\x20DAG_NEW_NODe,\x20DAG_AD\
    D_LINKS,\x20DAG_GET_LINKS,\x20DAG_REMOVE\r\n\n\x0f\n\x05\x04\x0b\x02\x06\
    \x04\x12\x06\x9e\x02\x04\x9b\x02\x19\n\r\n\x05\x04\x0b\x02\x06\x05\x12\
    \x04\x9e\x02\x04\n\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\x9e\x02\x0b\x0f\
    \n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x9e\x02\x12\x13\nv\n\x04\x04\x0b\
    \x02\x07\x12\x04\xa1\x02\x04\"\x1ah\x20indicates\x20links\x20and\x20thei\
    r\x20names.\x20key\x20=\x20name,\x20value\x20=\x20link\x20hash\r\n\x20se\
    nt\x20by:\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS\r\n\n\x0f\n\x05\x04\x0b\x02\
    \x07\x04\x12\x06\xa1\x02\x04\x9e\x02\x14\n\r\n\x05\x04\x0b\x02\x07\x06\
    \x12\x04\xa1\x02\x04\x17\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\xa1\x02\
    \x18\x1d\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\xa1\x02\x20!\n_\n\x04\x04\
    \x0b\x02\x08\x12\x04\xa4\x02\x04\x15\x1aQ\x20optional\x20reference\x20ID\
    \x20to\x20mark\x20the\x20cid/hash\x20with\r\n\x20sent\x20by:\x20DAG_PUT,\
    \x20DAG_REMOVE\r\n\n\x0f\n\x05\x04\x0b\x02\x08\x04\x12\x06\xa4\x02\x04\
    \xa1\x02\"\n\r\n\x05\x04\x0b\x02\x08\x05\x12\x04\xa4\x02\x04\n\n\r\n\x05\
    \x04\x0b\x02\x08\x01\x12\x04\xa4\x02\x0b\x10\n\r\n\x05\x04\x0b\x02\x08\
    \x03\x12\x04\xa4\x02\x13\x14\n;\n\x04\x04\x0b\x02\t\x12\x04\xa6\x02\x04\
    \x1a\x1a-\x20if\x20refID\x20is\x20set,\x20allows\x20progressive\x20uploa\
    d\r\n\n\x0f\n\x05\x04\x0b\x02\t\x04\x12\x06\xa6\x02\x04\xa4\x02\x15\n\r\
    \n\x05\x04\x0b\x02\t\x05\x12\x04\xa6\x02\x04\x08\n\r\n\x05\x04\x0b\x02\t\
    \x01\x12\x04\xa6\x02\t\x14\n\r\n\x05\x04\x0b\x02\t\x03\x12\x04\xa6\x02\
    \x17\x19\n;\n\x02\x04\x0c\x12\x06\xaa\x02\0\xbd\x02\x01\x1a-\x20Used\x20\
    in\x20response\x20to\x20a\x20Dag\x20or\x20DagStream\x20RPC\r\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\xaa\x02\x08\x13\nS\n\x04\x04\x0c\x02\0\x12\x04\
    \xad\x02\x04\x1f\x1aE\x20indicates\x20the\x20request\x20being\x20perform\
    ed\r\n\x20sent\x20by:\x20all\x20request\x20types\r\n\n\x0f\n\x05\x04\x0c\
    \x02\0\x04\x12\x06\xad\x02\x04\xaa\x02\x15\n\r\n\x05\x04\x0c\x02\0\x06\
    \x12\x04\xad\x02\x04\x0e\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xad\x02\x0f\
    \x1a\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xad\x02\x1d\x1e\n\x82\x01\n\x04\
    \x04\x0c\x02\x01\x12\x04\xb0\x02\x04\x1f\x1at\x20returns\x20the\x20hashe\
    s\x20of\x20newly\x20generated\x20IPLD\x20objects\r\n\x20sent\x20by:\x20D\
    AG_PUT,\x20DAG_NEW_NODE,\x20DAG_ADD_LINKS,\x20DAG_GET_LINKS\r\n\n\r\n\
    \x05\x04\x0c\x02\x01\x04\x12\x04\xb0\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x01\x05\x12\x04\xb0\x02\r\x13\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xb0\
    \x02\x14\x1a\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xb0\x02\x1d\x1e\nP\n\
    \x04\x04\x0c\x02\x02\x12\x04\xb3\x02\x04\x16\x1aB\x20the\x20actual\x20da\
    ta\x20contained\x20by\x20the\x20IPLD\x20object\r\n\x20sent\x20by:\x20DAG\
    _GET\r\n\n\x0f\n\x05\x04\x0c\x02\x02\x04\x12\x06\xb3\x02\x04\xb0\x02\x1f\
    \n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xb3\x02\x04\t\n\r\n\x05\x04\x0c\
    \x02\x02\x01\x12\x04\xb3\x02\n\x11\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\
    \xb3\x02\x14\x15\nX\n\x04\x04\x0c\x02\x03\x12\x04\xb6\x02\x04\x20\x1aJ\
    \x20the\x20links\x20contained\x20within\x20an\x20IPLD\x20node\x20object\
    \r\n\x20sent\x20by:\x20DAG_GET_LINKS\r\n\n\r\n\x05\x04\x0c\x02\x03\x04\
    \x12\x04\xb6\x02\x04\x0c\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\xb6\x02\r\
    \x15\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xb6\x02\x16\x1b\n\r\n\x05\x04\
    \x0c\x02\x03\x03\x12\x04\xb6\x02\x1e\x1f\nX\n\x04\x04\x0c\x02\x04\x12\
    \x04\xb9\x02\x04(\x1aJ\x20maps\x20ipld\x20cids\x20to\x20a\x20ipld.NodeSt\
    at\x20object\x20equivalent\r\n\x20sent\x20by:\x20DAG_STAT\r\n\n\x0f\n\
    \x05\x04\x0c\x02\x04\x04\x12\x06\xb9\x02\x04\xb6\x02\x20\n\r\n\x05\x04\
    \x0c\x02\x04\x06\x12\x04\xb9\x02\x04\x19\n\r\n\x05\x04\x0c\x02\x04\x01\
    \x12\x04\xb9\x02\x1a#\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xb9\x02&'\nR\
    \n\x04\x04\x0c\x02\x05\x12\x04\xbc\x02\x04\x15\x1aD\x20The\x20number\x20\
    of\x20removal\x20operations\x20performed.\r\n\x20sent\x20by:\x20DAG_REMO\
    VE\r\n\n\x0f\n\x05\x04\x0c\x02\x05\x04\x12\x06\xbc\x02\x04\xb9\x02(\n\r\
    \n\x05\x04\x0c\x02\x05\x05\x12\x04\xbc\x02\x04\n\n\r\n\x05\x04\x0c\x02\
    \x05\x01\x12\x04\xbc\x02\x0b\x10\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\
    \xbc\x02\x13\x14\n{\n\x02\x04\r\x12\x06\xc1\x02\0\xcc\x02\x01\x1am\x20IP\
    LDStat\x20is\x20statistics\x20about\x20an\x20individual\x20dag\x20node\r\
    \n\x20it\x20is\x20a\x20protocol\x20buffer\x20wrapper\x20around\x20ipld.N\
    odeStat\r\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc1\x02\x08\x10\n.\n\x04\x04\r\
    \x02\0\x12\x04\xc3\x02\x04\x17\x1a\x20\x20number\x20of\x20links\x20in\
    \x20link\x20table\r\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xc3\x02\x04\
    \xc1\x02\x12\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc3\x02\x04\t\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xc3\x02\n\x12\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \xc3\x02\x15\x16\n.\n\x04\x04\r\x02\x01\x12\x04\xc5\x02\x04\x18\x1a\x20\
    \x20size\x20of\x20the\x20raw,\x20encoded\x20data\r\n\n\x0f\n\x05\x04\r\
    \x02\x01\x04\x12\x06\xc5\x02\x04\xc3\x02\x17\n\r\n\x05\x04\r\x02\x01\x05\
    \x12\x04\xc5\x02\x04\t\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc5\x02\n\x13\
    \n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc5\x02\x16\x17\n*\n\x04\x04\r\x02\
    \x02\x12\x04\xc7\x02\x04\x17\x1a\x1c\x20size\x20of\x20the\x20links\x20se\
    gment\r\n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\xc7\x02\x04\xc5\x02\x18\
    \n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xc7\x02\x04\t\n\r\n\x05\x04\r\x02\
    \x02\x01\x12\x04\xc7\x02\n\x12\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xc7\
    \x02\x15\x16\n=\n\x04\x04\r\x02\x03\x12\x04\xc9\x02\x04\x1d\x1a/\x20cumu\
    lative\x20size\x20of\x20object\x20and\x20its\x20references\r\n\n\x0f\n\
    \x05\x04\r\x02\x03\x04\x12\x06\xc9\x02\x04\xc7\x02\x17\n\r\n\x05\x04\r\
    \x02\x03\x05\x12\x04\xc9\x02\x04\t\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xc9\x02\n\x18\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xc9\x02\x1b\x1c\n)\n\
    \x04\x04\r\x02\x04\x12\x04\xcb\x02\x04\x17\x1a\x1b\x20size\x20of\x20the\
    \x20data\x20segment\r\n\n\x0f\n\x05\x04\r\x02\x04\x04\x12\x06\xcb\x02\
    \x04\xc9\x02\x1d\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xcb\x02\x04\t\n\r\n\
    \x05\x04\r\x02\x04\x01\x12\x04\xcb\x02\n\x12\n\r\n\x05\x04\r\x02\x04\x03\
    \x12\x04\xcb\x02\x15\x16\n'\n\x02\x04\x0e\x12\x06\xcf\x02\0\xd6\x02\x01\
    \x1a\x19\x20An\x20IPFS\x20MerkleDAG\x20Link\r\n\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xcf\x02\x08\x10\n/\n\x04\x04\x0e\x02\0\x12\x04\xd1\x02\x04\x13\
    \x1a!\x20multihash\x20of\x20the\x20target\x20object\r\n\n\x0f\n\x05\x04\
    \x0e\x02\0\x04\x12\x06\xd1\x02\x04\xcf\x02\x12\n\r\n\x05\x04\x0e\x02\0\
    \x05\x12\x04\xd1\x02\x04\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xd1\x02\n\
    \x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xd1\x02\x11\x12\n=\n\x04\x04\
    \x0e\x02\x01\x12\x04\xd3\x02\x04\x14\x1a/\x20utf\x20string\x20name.\x20s\
    hould\x20be\x20unique\x20per\x20object\r\n\n\x0f\n\x05\x04\x0e\x02\x01\
    \x04\x12\x06\xd3\x02\x04\xd1\x02\x13\n\r\n\x05\x04\x0e\x02\x01\x05\x12\
    \x04\xd3\x02\x04\n\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xd3\x02\x0b\x0f\
    \n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xd3\x02\x12\x13\n1\n\x04\x04\x0e\
    \x02\x02\x12\x04\xd5\x02\x04\x14\x1a#\x20cumulative\x20size\x20of\x20tar\
    get\x20object\r\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\xd5\x02\x04\
    \xd3\x02\x14\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xd5\x02\x04\n\n\r\n\
    \x05\x04\x0e\x02\x02\x01\x12\x04\xd5\x02\x0b\x0f\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xd5\x02\x12\x13\n'\n\x02\x04\x0f\x12\x06\xd9\x02\0\xde\
    \x02\x01\x1a\x19\x20An\x20IPFS\x20MerkleDAG\x20Node\r\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xd9\x02\x08\x10\n&\n\x04\x04\x0f\x02\0\x12\x04\xdb\x02\
    \x04\x20\x1a\x18\x20refs\x20to\x20other\x20objects\r\n\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\xdb\x02\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\
    \xdb\x02\r\x15\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xdb\x02\x16\x1b\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\xdb\x02\x1e\x1f\n!\n\x04\x04\x0f\x02\x01\
    \x12\x04\xdd\x02\x04\x13\x1a\x13\x20opaque\x20user\x20data\r\n\n\x0f\n\
    \x05\x04\x0f\x02\x01\x04\x12\x06\xdd\x02\x04\xdb\x02\x20\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xdd\x02\x04\t\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xdd\x02\n\x0e\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xdd\x02\x11\x12\
    \nW\n\x02\x05\x07\x12\x06\xe1\x02\0\xec\x02\x01\x1aI\x20KSREQTYPE\x20ind\
    icates\x20the\x20particular\x20KeystoreAPI\x20request\x20being\x20perfor\
    med\r\n\n\x0b\n\x03\x05\x07\x01\x12\x04\xe1\x02\x05\x0e\nJ\n\x04\x05\x07\
    \x02\0\x12\x04\xe3\x02\x04\x0f\x1a<\x20KS_HAS\x20is\x20used\x20to\x20che\
    ck\x20if\x20the\x20key\x20exists\x20in\x20our\x20keystore\r\n\n\r\n\x05\
    \x05\x07\x02\0\x01\x12\x04\xe3\x02\x04\n\n\r\n\x05\x05\x07\x02\0\x02\x12\
    \x04\xe3\x02\r\x0e\nO\n\x04\x05\x07\x02\x01\x12\x04\xe5\x02\x04\x0f\x1aA\
    \x20KS_GET\x20is\x20used\x20to\x20retrieve\x20private\x20key\x20bytes\
    \x20from\x20our\x20keystore\r\n\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\
    \xe5\x02\x04\n\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\xe5\x02\r\x0e\nJ\n\
    \x04\x05\x07\x02\x02\x12\x04\xe7\x02\x04\x0f\x1a<\x20KS_PUT\x20is\x20use\
    d\x20to\x20store\x20private\x20key\x20bytes\x20in\x20our\x20keystore\r\n\
    \n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xe7\x02\x04\n\n\r\n\x05\x05\x07\
    \x02\x02\x02\x12\x04\xe7\x02\r\x0e\nK\n\x04\x05\x07\x02\x03\x12\x04\xe9\
    \x02\x04\x12\x1a=\x20KS_DELETE\x20is\x20used\x20to\x20delete\x20private\
    \x20keys\x20from\x20our\x20keystore\r\n\n\r\n\x05\x05\x07\x02\x03\x01\
    \x12\x04\xe9\x02\x04\r\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xe9\x02\x10\
    \x11\nO\n\x04\x05\x07\x02\x04\x12\x04\xeb\x02\x04\x10\x1aA\x20KS_LIST\
    \x20is\x20used\x20to\x20list\x20all\x20keys\x20in\x20our\x20keystore\x20\
    by\x20their\x20name\r\n\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xeb\x02\
    \x04\x0b\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\xeb\x02\x0e\x0f\n9\n\x02\
    \x04\x10\x12\x06\xef\x02\0\xf8\x02\x01\x1a+\x20Used\x20to\x20submit\x20a\
    \x20request\x20to\x20Keystore\x20RPC\r\n\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xef\x02\x08\x17\n;\n\x04\x04\x10\x02\0\x12\x04\xf1\x02\x04\x1e\x1a-\x20\
    indicates\x20the\x20request\x20type\x20being\x20performed\r\n\n\x0f\n\
    \x05\x04\x10\x02\0\x04\x12\x06\xf1\x02\x04\xef\x02\x19\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xf1\x02\x04\r\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xf1\
    \x02\x0e\x19\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xf1\x02\x1c\x1d\n`\n\
    \x04\x04\x10\x02\x01\x12\x04\xf4\x02\x04\x14\x1aR\x20name\x20of\x20the\
    \x20key\x20the\x20request\x20is\x20for\r\n\x20sent\x20by:\x20KS_HAS,\x20\
    KS_GET,\x20KS_PUT,\x20KS_DELETE\r\n\n\x0f\n\x05\x04\x10\x02\x01\x04\x12\
    \x06\xf4\x02\x04\xf1\x02\x1e\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xf4\
    \x02\x04\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xf4\x02\x0b\x0f\n\r\n\
    \x05\x04\x10\x02\x01\x03\x12\x04\xf4\x02\x12\x13\n?\n\x04\x04\x10\x02\
    \x02\x12\x04\xf7\x02\x04\x19\x1a1\x20the\x20actual\x20private\x20key\x20\
    bytes\r\n\x20sent\x20by:\x20KS_PUT\r\n\n\x0f\n\x05\x04\x10\x02\x02\x04\
    \x12\x06\xf7\x02\x04\xf4\x02\x14\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\
    \xf7\x02\x04\t\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xf7\x02\n\x14\n\r\n\
    \x05\x04\x10\x02\x02\x03\x12\x04\xf7\x02\x17\x18\n3\n\x02\x04\x11\x12\
    \x06\xfb\x02\0\x87\x03\x01\x1a%\x20Used\x20in\x20response\x20to\x20a\x20\
    Keystore\x20RPC\r\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xfb\x02\x08\x18\n;\n\
    \x04\x04\x11\x02\0\x12\x04\xfd\x02\x04\x1e\x1a-\x20indicates\x20the\x20r\
    equest\x20type\x20being\x20performed\r\n\n\x0f\n\x05\x04\x11\x02\0\x04\
    \x12\x06\xfd\x02\x04\xfb\x02\x1a\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xfd\
    \x02\x04\r\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xfd\x02\x0e\x19\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xfd\x02\x1c\x1d\n8\n\x04\x04\x11\x02\x01\x12\
    \x04\x80\x03\x04\x19\x1a*\x20the\x20private\x20key\x20bytes\r\n\x20sent\
    \x20by:\x20KS_GET\r\n\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\x80\x03\
    \x04\xfd\x02\x1e\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x80\x03\x04\t\n\r\
    \n\x05\x04\x11\x02\x01\x01\x12\x04\x80\x03\n\x14\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\x80\x03\x17\x18\n@\n\x04\x04\x11\x02\x02\x12\x04\x83\
    \x03\x04!\x1a2\x20contains\x20all\x20known\x20key\x20names\r\n\x20sent\
    \x20by:\x20KS_LIST\r\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\x83\x03\x04\
    \x0c\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\x83\x03\r\x13\n\r\n\x05\x04\
    \x11\x02\x02\x01\x12\x04\x83\x03\x14\x1c\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\x83\x03\x1f\x20\nO\n\x04\x04\x11\x02\x03\x12\x04\x86\x03\x04\
    \x11\x1aA\x20indicates\x20if\x20we\x20have\x20the\x20key\x20in\x20our\
    \x20keystore\r\n\x20sent\x20by:\x20KS_HAS\r\n\n\x0f\n\x05\x04\x11\x02\
    \x03\x04\x12\x06\x86\x03\x04\x83\x03!\n\r\n\x05\x04\x11\x02\x03\x05\x12\
    \x04\x86\x03\x04\x08\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x86\x03\t\x0c\
    \n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x86\x03\x0f\x10\n\x0c\n\x02\x04\
    \x12\x12\x06\x89\x03\0\x90\x03\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x89\
    \x03\x08\x16\n(\n\x04\x04\x12\x02\0\x12\x04\x8b\x03\x04\x1d\x1a\x1a\x20c\
    ids\x20to\x20persist\x20locally\r\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\
    \x8b\x03\x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x8b\x03\r\x13\n\r\n\
    \x05\x04\x12\x02\0\x01\x12\x04\x8b\x03\x14\x18\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\x8b\x03\x1b\x1c\n<\n\x04\x04\x12\x02\x01\x12\x04\x8d\x03\
    \x04\x15\x1a.\x20optional\x20reference\x20ID\x20to\x20mark\x20the\x20cid\
    s\x20with\r\n\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\x8d\x03\x04\x8b\
    \x03\x1d\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\x8d\x03\x04\n\n\r\n\x05\
    \x04\x12\x02\x01\x01\x12\x04\x8d\x03\x0b\x10\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\x8d\x03\x13\x14\n;\n\x04\x04\x12\x02\x02\x12\x04\x8f\x03\
    \x04\x19\x1a-\x20if\x20refID\x20is\x20set,\x20allows\x20progressive\x20u\
    pload\r\n\n\x0f\n\x05\x04\x12\x02\x02\x04\x12\x06\x8f\x03\x04\x8d\x03\
    \x15\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\x8f\x03\x04\x08\n\r\n\x05\x04\
    \x12\x02\x02\x01\x12\x04\x8f\x03\t\x14\n\r\n\x05\x04\x12\x02\x02\x03\x12\
    \x04\x8f\x03\x17\x18\n\x0c\n\x02\x04\x13\x12\x06\x92\x03\0\x97\x03\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\x92\x03\x08\x17\nC\n\x04\x04\x13\x02\0\
    \x12\x04\x94\x03\x04!\x1a5\x20key\x20=\x20cid,\x20value\x20=\x20whether\
    \x20or\x20not\x20it\x20was\x20persisted\r\n\n\x0f\n\x05\x04\x13\x02\0\
    \x04\x12\x06\x94\x03\x04\x92\x03\x19\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\
    \x94\x03\x04\x15\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x94\x03\x16\x1c\n\r\
    \n\x05\x04\x13\x02\0\x03\x12\x04\x94\x03\x1f\x20\n:\n\x04\x04\x13\x02\
    \x01\x12\x04\x96\x03\x04#\x1a,\x20key\x20=\x20cid,\x20value\x20=\x20erro\
    r\x20if\x20not\x20persisted\r\n\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\
    \x96\x03\x04\x94\x03!\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\x96\x03\x04\
    \x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x96\x03\x18\x1e\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\x96\x03!\"b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
