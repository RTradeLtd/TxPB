syntax = "proto3";
package pb;
import "util.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";
option (gogoproto.gostring_all) = true;
option (gogoproto.equal_all) = true;
option (gogoproto.verbose_equal_all) = true;
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) =  true;
option (gogoproto.populate_all) = true;
option (gogoproto.testgen_all) = true;
// uncomment to enable bench generation
// option (gogoproto.benchgen_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;


// NodeAPI provide an API to control the underlying custom ipfs node
service NodeAPI {
    // GetPeers returns a message containing a slice of current peers in our peerstore
    rpc GetPeers(Empty) returns (GetPeersResponse) { };
    // Connect is used to connect to remote libp2p peers
    rpc Connect(ConnectRequest) returns (Empty) { };
    // Disconnect is used to disconnect remote libp2p peer connections
    rpc Disconnect(DisconnectRequest) returns (DisconnectResponse) { };
    // IsConnected is used to check if we are connected with a given peer
    rpc IsConnected(IsConnectedRequest) returns (IsConnectedResponse) { };
    // EnableExtras is used to enable a particular extras feature
    rpc EnableExtras(EnableExtrasRequest) returns (Empty) { };
    // DisableExtras is used to disable a particular extras feature
    rpc DisableExtras(DisableExtrasRequest) returns (Empty) { };
    // P2P allows control of generalized p2p streams for tcp/udp based protocol.
    // By using this RPC, we can tunnel traffic similar to ssh tunneling
    // except using libp2p as the transport layer, and and tcp/udp port.
    rpc P2P(P2PRequest) returns (P2PResponse) { };
}

// P2PREQTYPE denotes the particular type of request being used in the p2p rpc
enum P2PREQTYPE {
    // equivalent of ipfs p2p close
    CLOSE = 0;
    // equivalent of ipfs p2p forward
    FORWARD = 1;
    // equivalent of ipfs p2p listen
    LISTEN = 2;
    // equivalent of ipfs p2p ls
    LS = 3;
}

// P2PRequest is a request message holding the details of a particular P2P rpc call
message P2PRequest {
    // indicates the reuqest type
    P2PREQTYPE requestType = 1;  
    // used by: P2PREQTYPE.CLOSE
    bool all = 2;
    // used by: P2PREQTYPE.LS
    bool verbose = 3;
    // used by: P2PREQTYPE.CLOSE, P2PREQTYPE.FORWARD, P2PREQTYPE.LISTEN
    string protocolName = 4;
    // used by: P2PREQTYPE.CLOSE, P2PREQTYPE.FORWARD
    string listenAddress = 5;
    // used by: P2PREQTYPE.CLOSE, P2PREQTYPE.FORWARD
    string targetAddress = 6;
    // used by: P2PREQTYPE.LISTEN
    string remoteAddress = 7;
}

// P2PResponse is a response message sent in response to a P2PRequest message
message P2PResponse {
    P2PREQTYPE requestType = 1;
    // sent by: P2PREQTYPE.LISTEN
    repeated string names = 2;
    // sent by: P2PREQTYPE.CLOSE to indicate the number of connections closed
    int32 connsClosed = 3;
}


// GetPeersResponse is a response to GetPeers containing a slice of peer IDs
message GetPeersResponse {
    // a slice of peer IDs
    repeated string peerIDs = 1;
}

// ConnectRequest is used to connect to libp2p peers
message ConnectRequest {
    // a slice of all multiaddrs we want to connect to
    repeated string multiAddrs = 1;
}

// IsConnectedRequest is used check whether or not we are currently peered with these peers
message IsConnectedRequest {
    // a slice of the peer IDs to examine
    repeated string peerIDs = 1;
}

// IsConnectedResponse is a response to an IsConnectedRequest request
message IsConnectedResponse {
    // a map of the peer ID and a boolean indicating if we are connected with them
    map<string, bool> connected = 1;
}

// DisconnectRequest is used to disconnect a connection to a libp2p peer
message DisconnectRequest {
    // a slice of the peer IDs to disconnect from
    repeated string peerIDs = 1;
}

// DisconnectResponse is a response to a disconnect request
message DisconnectResponse {
    // a map of the peer id, and a custom message indicating success, or why there was a failure
    map<string, StatusMessage> status = 1;
    // StatusMessage is used to contain the status information about a particular disconnection attempt
    message StatusMessage {
        // indicate whether or not we actually disconnected
        bool disconnected = 1;
        // if disconnected is false, the reason why it is false
        string reason = 2;
    }
}

// EXTRASTYPE denotes a particular extras type
enum EXTRASTYPE {
    // IDENTIFY is the identify service
    IDENTIFY = 0;
    // PUBSUB is the libp2p pubsub system
    PUBSUB = 1;
    // DISCOVERY is a libp2p discovery service
    DISCOVERY = 2;
}

// EnableExtrasRequest is used to enable a particular extras feature
message EnableExtrasRequest {
    // extrasFeature denotes the particular extras functionality to enable
    EXTRASTYPE extrasFeature = 1;
}

// DisableExtrasRequest is used to disable a particular extras feature
message DisableExtrasRequest {
    // extrasFeature denotes the particular extras functionality to disable
    EXTRASTYPE extrasFeature = 1;
}