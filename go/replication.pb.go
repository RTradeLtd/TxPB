// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: replication.proto

package pb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Replication message is a signable data structure to represent a replication scheme
type Replication struct {
	// Header must be "rtrade-replication v0..." for development stage, this is a required security header.
	// - Avoid collision from other signed data.
	// - Allow future versions to require different validation rules.
	// Any signer must understand every header tag to sign documents.
	Header string `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// CIDs is the list of contents to replicate.
	// Please use helper functions GetCIDs and AddCIDs for this field
	CidsBytes [][]byte `protobuf:"bytes,2,rep,name=cids_bytes,json=cidsBytes,proto3" json:"cids_bytes,omitempty"`
	// Servers list the candidate severs to replicate to, in the order of preference.
	Servers []*ServerSource `protobuf:"bytes,3,rep,name=servers,proto3" json:"servers,omitempty"`
	// replication_factor is the number of replications desired.
	ReplicationFactor int32 `protobuf:"varint,4,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	// refresh_interval_seconds is the *suggested* number of seconds to wait before checking
	// if a remote server is up. The first check should be random from 0 to refresh_interval_seconds.
	// Each replicator can have it's own max_interval. A sensible default value should be used if it is 0.
	RefreshIntervalSeconds int32 `protobuf:"varint,5,opt,name=refresh_interval_seconds,json=refreshIntervalSeconds,proto3" json:"refresh_interval_seconds,omitempty"`
	// server_down_delay_seconds is the number of seconds to wait after a server is down before the
	// next reserved server is requested to be active. A sensible default value should be used if it is 0.
	ServerDownDelaySeconds int32    `protobuf:"varint,6,opt,name=server_down_delay_seconds,json=serverDownDelaySeconds,proto3" json:"server_down_delay_seconds,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Replication) Reset()         { *m = Replication{} }
func (m *Replication) String() string { return proto.CompactTextString(m) }
func (*Replication) ProtoMessage()    {}
func (*Replication) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{0}
}
func (m *Replication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replication.Merge(m, src)
}
func (m *Replication) XXX_Size() int {
	return m.Size()
}
func (m *Replication) XXX_DiscardUnknown() {
	xxx_messageInfo_Replication.DiscardUnknown(m)
}

var xxx_messageInfo_Replication proto.InternalMessageInfo

func (m *Replication) GetHeader() string {
	if m != nil {
		return m.Header
	}
	return ""
}

func (m *Replication) GetCidsBytes() [][]byte {
	if m != nil {
		return m.CidsBytes
	}
	return nil
}

func (m *Replication) GetServers() []*ServerSource {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Replication) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *Replication) GetRefreshIntervalSeconds() int32 {
	if m != nil {
		return m.RefreshIntervalSeconds
	}
	return 0
}

func (m *Replication) GetServerDownDelaySeconds() int32 {
	if m != nil {
		return m.ServerDownDelaySeconds
	}
	return 0
}

// ServerSource is a list of one or more servers.
// TODO: add field to allow referring to a list of servers from another file.
type ServerSource struct {
	AddrInfo             *AddrInfo `protobuf:"bytes,1,opt,name=addr_info,json=addrInfo,proto3" json:"addr_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ServerSource) Reset()         { *m = ServerSource{} }
func (m *ServerSource) String() string { return proto.CompactTextString(m) }
func (*ServerSource) ProtoMessage()    {}
func (*ServerSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{1}
}
func (m *ServerSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerSource.Merge(m, src)
}
func (m *ServerSource) XXX_Size() int {
	return m.Size()
}
func (m *ServerSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerSource.DiscardUnknown(m)
}

var xxx_messageInfo_ServerSource proto.InternalMessageInfo

func (m *ServerSource) GetAddrInfo() *AddrInfo {
	if m != nil {
		return m.AddrInfo
	}
	return nil
}

// AddrInfo can be used to ID and locate a server (see also libp2p/go-libp2p-core/peer#AddrInfo)
type AddrInfo struct {
	// id_bytes is a libp2p peer identity. It is used to verity the Peer's public key.
	// Please use helper functions GetID and SetID for this field
	IdBytes []byte `protobuf:"bytes,1,opt,name=id_bytes,json=idBytes,proto3" json:"id_bytes,omitempty"`
	// addrBytes are bytes of Multiaddr for locating this peer.
	// Please use helper functions GetMultiAddrs, and SetMultiAddrs for this field.
	AddrsBytes [][]byte `protobuf:"bytes,2,rep,name=addrs_bytes,json=addrsBytes,proto3" json:"addrs_bytes,omitempty"`
	// grpc port for replication protocol. will be optional once grpc is integrated into multistream.
	GrpcPort             int32    `protobuf:"varint,3,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddrInfo) Reset()         { *m = AddrInfo{} }
func (m *AddrInfo) String() string { return proto.CompactTextString(m) }
func (*AddrInfo) ProtoMessage()    {}
func (*AddrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{2}
}
func (m *AddrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrInfo.Merge(m, src)
}
func (m *AddrInfo) XXX_Size() int {
	return m.Size()
}
func (m *AddrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AddrInfo proto.InternalMessageInfo

func (m *AddrInfo) GetIdBytes() []byte {
	if m != nil {
		return m.IdBytes
	}
	return nil
}

func (m *AddrInfo) GetAddrsBytes() [][]byte {
	if m != nil {
		return m.AddrsBytes
	}
	return nil
}

func (m *AddrInfo) GetGrpcPort() int32 {
	if m != nil {
		return m.GrpcPort
	}
	return 0
}

type Subscription struct {
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	AuthorIdBytes []byte `protobuf:"bytes,2,opt,name=author_id_bytes,json=authorIdBytes,proto3" json:"author_id_bytes,omitempty"`
	//if true, remove this Subscription.
	//For replicator.Add, deactive this replication.
	//For replicator.WaitForUpdates, stop reporting updates.
	Remove               bool     `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Subscription) Reset()         { *m = Subscription{} }
func (m *Subscription) String() string { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()    {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{3}
}
func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(m, src)
}
func (m *Subscription) XXX_Size() int {
	return m.Size()
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *Subscription) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Subscription) GetAuthorIdBytes() []byte {
	if m != nil {
		return m.AuthorIdBytes
	}
	return nil
}

func (m *Subscription) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

type ReplicationStatus struct {
	//ok report success for action submitted
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	//is_active report if the replication is currently active on this server
	IsActive bool `protobuf:"varint,2,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	//current_version is the highest version this replicator/server has locally.
	CurrentVersion int64 `protobuf:"varint,3,opt,name=current_version,json=currentVersion,proto3" json:"current_version,omitempty"`
	//target_version is the highest version this replicator/server knows about and can verify to exist.
	TargetVersion        int64    `protobuf:"varint,4,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationStatus) Reset()         { *m = ReplicationStatus{} }
func (m *ReplicationStatus) String() string { return proto.CompactTextString(m) }
func (*ReplicationStatus) ProtoMessage()    {}
func (*ReplicationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{4}
}
func (m *ReplicationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicationStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationStatus.Merge(m, src)
}
func (m *ReplicationStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationStatus proto.InternalMessageInfo

func (m *ReplicationStatus) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *ReplicationStatus) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ReplicationStatus) GetCurrentVersion() int64 {
	if m != nil {
		return m.CurrentVersion
	}
	return 0
}

func (m *ReplicationStatus) GetTargetVersion() int64 {
	if m != nil {
		return m.TargetVersion
	}
	return 0
}

type SubscriptionUpdate struct {
	//strictly increasing version number
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	//replication file is in bytes for signing
	ReplicationBytes []byte `protobuf:"bytes,2,opt,name=replication_bytes,json=replicationBytes,proto3" json:"replication_bytes,omitempty"`
	//signature signs the Subscription and above data in length delimited form in the order topic|author|version|replication
	Signature            []byte   `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionUpdate) Reset()         { *m = SubscriptionUpdate{} }
func (m *SubscriptionUpdate) String() string { return proto.CompactTextString(m) }
func (*SubscriptionUpdate) ProtoMessage()    {}
func (*SubscriptionUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{5}
}
func (m *SubscriptionUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionUpdate.Merge(m, src)
}
func (m *SubscriptionUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionUpdate proto.InternalMessageInfo

func (m *SubscriptionUpdate) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SubscriptionUpdate) GetReplicationBytes() []byte {
	if m != nil {
		return m.ReplicationBytes
	}
	return nil
}

func (m *SubscriptionUpdate) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type SignedSubscription struct {
	SubPart              *Subscription       `protobuf:"bytes,1,opt,name=sub_part,json=subPart,proto3" json:"sub_part,omitempty"`
	UpdatePart           *SubscriptionUpdate `protobuf:"bytes,2,opt,name=update_part,json=updatePart,proto3" json:"update_part,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SignedSubscription) Reset()         { *m = SignedSubscription{} }
func (m *SignedSubscription) String() string { return proto.CompactTextString(m) }
func (*SignedSubscription) ProtoMessage()    {}
func (*SignedSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed0454e9e09fb71a, []int{6}
}
func (m *SignedSubscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedSubscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedSubscription.Merge(m, src)
}
func (m *SignedSubscription) XXX_Size() int {
	return m.Size()
}
func (m *SignedSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_SignedSubscription proto.InternalMessageInfo

func (m *SignedSubscription) GetSubPart() *Subscription {
	if m != nil {
		return m.SubPart
	}
	return nil
}

func (m *SignedSubscription) GetUpdatePart() *SubscriptionUpdate {
	if m != nil {
		return m.UpdatePart
	}
	return nil
}

func init() {
	proto.RegisterType((*Replication)(nil), "pb.Replication")
	proto.RegisterType((*ServerSource)(nil), "pb.ServerSource")
	proto.RegisterType((*AddrInfo)(nil), "pb.AddrInfo")
	proto.RegisterType((*Subscription)(nil), "pb.Subscription")
	proto.RegisterType((*ReplicationStatus)(nil), "pb.ReplicationStatus")
	proto.RegisterType((*SubscriptionUpdate)(nil), "pb.SubscriptionUpdate")
	proto.RegisterType((*SignedSubscription)(nil), "pb.SignedSubscription")
}

func init() { proto.RegisterFile("replication.proto", fileDescriptor_ed0454e9e09fb71a) }

var fileDescriptor_ed0454e9e09fb71a = []byte{
	// 622 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd4, 0x3c,
	0x14, 0x55, 0x92, 0x76, 0x26, 0x73, 0x27, 0xfd, 0xb3, 0xbe, 0x8e, 0xd2, 0x0f, 0x28, 0xa3, 0x48,
	0xc0, 0x40, 0x45, 0x55, 0xb5, 0x0b, 0xe8, 0x72, 0xaa, 0x0a, 0xd4, 0x5d, 0xe5, 0x08, 0xb6, 0x91,
	0x13, 0x7b, 0xa6, 0x56, 0xdb, 0x38, 0xb2, 0x9d, 0xa9, 0xca, 0x53, 0xb0, 0xe0, 0xa1, 0x58, 0xf2,
	0x08, 0xa8, 0xcf, 0xc1, 0x02, 0xc5, 0xf6, 0xb4, 0x19, 0x86, 0x2e, 0xd8, 0xe5, 0x9e, 0x7b, 0x4e,
	0xee, 0xf1, 0xb9, 0x96, 0x61, 0x4b, 0xb2, 0xea, 0x8a, 0x17, 0x44, 0x73, 0x51, 0xee, 0x57, 0x52,
	0x68, 0x81, 0xfc, 0x2a, 0x4f, 0xbe, 0xf9, 0xd0, 0xc7, 0x0f, 0x1d, 0x34, 0x80, 0xce, 0x05, 0x23,
	0x94, 0xc9, 0xd8, 0x1b, 0x7a, 0xa3, 0x1e, 0x76, 0x15, 0x7a, 0x06, 0x50, 0x70, 0xaa, 0xb2, 0xfc,
	0x56, 0x33, 0x15, 0xfb, 0xc3, 0x60, 0x14, 0xe1, 0x5e, 0x83, 0x9c, 0x34, 0x00, 0x7a, 0x03, 0x5d,
	0xc5, 0xe4, 0x8c, 0x49, 0x15, 0x07, 0xc3, 0x60, 0xd4, 0x3f, 0xdc, 0xdc, 0xaf, 0xf2, 0xfd, 0xd4,
	0x40, 0xa9, 0xa8, 0x65, 0xc1, 0xf0, 0x9c, 0x80, 0xde, 0x02, 0x6a, 0x79, 0xc9, 0x26, 0xa4, 0xd0,
	0x42, 0xc6, 0x2b, 0x43, 0x6f, 0xb4, 0x8a, 0xdb, 0x2e, 0x3f, 0x98, 0x06, 0x7a, 0x0f, 0xb1, 0x64,
	0x13, 0xc9, 0xd4, 0x45, 0xc6, 0x4b, 0xcd, 0xe4, 0x8c, 0x5c, 0x65, 0x8a, 0x15, 0xa2, 0xa4, 0x2a,
	0x5e, 0x35, 0xa2, 0x81, 0xeb, 0x9f, 0xb9, 0x76, 0x6a, 0xbb, 0xe8, 0x18, 0x76, 0xec, 0xcc, 0x8c,
	0x8a, 0x9b, 0x32, 0xa3, 0xec, 0x8a, 0xdc, 0xde, 0x4b, 0x3b, 0x56, 0x6a, 0x09, 0xa7, 0xe2, 0xa6,
	0x3c, 0x6d, 0xda, 0x4e, 0x9a, 0x1c, 0x43, 0xd4, 0x36, 0x8f, 0x5e, 0x43, 0x8f, 0x50, 0x2a, 0x33,
	0x5e, 0x4e, 0x84, 0x49, 0xa6, 0x7f, 0x18, 0x35, 0x27, 0x1c, 0x53, 0x2a, 0xcf, 0xca, 0x89, 0xc0,
	0x21, 0x71, 0x5f, 0x49, 0x01, 0xe1, 0x1c, 0x45, 0x3b, 0x10, 0x72, 0xea, 0x32, 0x6b, 0x54, 0x11,
	0xee, 0x72, 0x6a, 0x13, 0x7b, 0x0e, 0xfd, 0x46, 0xb2, 0x98, 0x28, 0x18, 0xc8, 0x12, 0x9e, 0x40,
	0x6f, 0x2a, 0xab, 0x22, 0xab, 0x84, 0xd4, 0x71, 0x60, 0xdc, 0x86, 0x0d, 0x70, 0x2e, 0xa4, 0x4e,
	0x28, 0x44, 0x69, 0x9d, 0xab, 0x42, 0xf2, 0xca, 0xac, 0xed, 0x3f, 0x58, 0xd5, 0xa2, 0xe2, 0x85,
	0xdb, 0x9a, 0x2d, 0xd0, 0x4b, 0xd8, 0x20, 0xb5, 0xbe, 0x10, 0x32, 0xbb, 0x77, 0xe1, 0x1b, 0x17,
	0x6b, 0x16, 0x3e, 0x73, 0x5e, 0x06, 0xd0, 0x91, 0xec, 0x5a, 0xcc, 0x98, 0x99, 0x13, 0x62, 0x57,
	0x25, 0x5f, 0x3d, 0xd8, 0x6a, 0x5d, 0x8e, 0x54, 0x13, 0x5d, 0x2b, 0xb4, 0x0e, 0xbe, 0xb8, 0x34,
	0x83, 0x42, 0xec, 0x8b, 0xcb, 0xc6, 0x28, 0x57, 0x19, 0x29, 0x34, 0x9f, 0x31, 0xf3, 0xff, 0x10,
	0x87, 0x5c, 0x8d, 0x4d, 0x8d, 0x5e, 0xc1, 0x46, 0x51, 0x4b, 0xc9, 0x4a, 0x9d, 0x35, 0xcb, 0xe7,
	0xa2, 0x34, 0x33, 0x02, 0xbc, 0xee, 0xe0, 0xcf, 0x16, 0x45, 0x2f, 0x60, 0x5d, 0x13, 0x39, 0x65,
	0x0f, 0xbc, 0x15, 0xc3, 0x5b, 0xb3, 0xa8, 0xa3, 0x25, 0xb7, 0x80, 0xda, 0x07, 0xff, 0x54, 0x51,
	0xa2, 0x19, 0x8a, 0xa1, 0x3b, 0x57, 0x79, 0x46, 0x35, 0x2f, 0xd1, 0xde, 0xc2, 0xc5, 0x5f, 0x08,
	0x61, 0xb3, 0xd5, 0xb0, 0x39, 0x3c, 0x85, 0x9e, 0xe2, 0xd3, 0x92, 0xe8, 0x5a, 0xda, 0x28, 0x22,
	0xfc, 0x00, 0x24, 0x5f, 0x00, 0xa5, 0x7c, 0x5a, 0x32, 0xba, 0x90, 0xfc, 0x1e, 0x84, 0xaa, 0xce,
	0xb3, 0x8a, 0x48, 0xed, 0x2e, 0x86, 0xbd, 0xfa, 0x2d, 0x0e, 0xee, 0xaa, 0x3a, 0x3f, 0x27, 0x52,
	0xa3, 0x77, 0xd0, 0xaf, 0x8d, 0x63, 0xcb, 0xf7, 0x0d, 0x7f, 0xf0, 0x27, 0xdf, 0x1e, 0x0a, 0x83,
	0xa5, 0x36, 0xc2, 0xc3, 0x5f, 0x1e, 0xc0, 0xdc, 0xae, 0x90, 0xe8, 0x00, 0x82, 0x31, 0xa5, 0x68,
	0x69, 0xd2, 0xff, 0xdb, 0x0d, 0xb2, 0xb4, 0xb2, 0x03, 0x0f, 0x1d, 0x41, 0xc7, 0xad, 0xef, 0x1f,
	0x44, 0x63, 0xd8, 0xfe, 0xc8, 0xf4, 0x5f, 0xf2, 0x5e, 0xfe, 0xc7, 0x23, 0x87, 0x40, 0xa7, 0xb0,
	0x95, 0xd6, 0xf9, 0x35, 0xd7, 0x0b, 0x8f, 0x8c, 0x21, 0x2f, 0x65, 0xf9, 0xa8, 0x91, 0x93, 0xe8,
	0xfb, 0xdd, 0xae, 0xf7, 0xe3, 0x6e, 0xd7, 0xfb, 0x79, 0xb7, 0xeb, 0xe5, 0x1d, 0xf3, 0x7c, 0x1d,
	0xfd, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xb7, 0xf0, 0x26, 0x7f, 0xd3, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReplicatorClient is the client API for Replicator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReplicatorClient interface {
	// Add is used to add a replication to this server, changing it's status from reserved to active.
	Add(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Replicator_AddClient, error)
	// Status returns an updating stream of the replication status on the server.
	Status(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Replicator_StatusClient, error)
	// GetSubscriptionUpdate returns the latest version of subscribed replication
	GetSubscriptionUpdate(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*SubscriptionUpdate, error)
	// SubmitReplication is used by client agents to start replications, after they
	// have uploaded the files and retrieved the cid, and collected servers to replicate too.
	SubmitReplication(ctx context.Context, in *SignedSubscription, opts ...grpc.CallOption) (Replicator_SubmitReplicationClient, error)
}

type replicatorClient struct {
	cc *grpc.ClientConn
}

func NewReplicatorClient(cc *grpc.ClientConn) ReplicatorClient {
	return &replicatorClient{cc}
}

func (c *replicatorClient) Add(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Replicator_AddClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replicator_serviceDesc.Streams[0], "/pb.replicator/Add", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicatorAddClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Replicator_AddClient interface {
	Recv() (*ReplicationStatus, error)
	grpc.ClientStream
}

type replicatorAddClient struct {
	grpc.ClientStream
}

func (x *replicatorAddClient) Recv() (*ReplicationStatus, error) {
	m := new(ReplicationStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicatorClient) Status(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (Replicator_StatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replicator_serviceDesc.Streams[1], "/pb.replicator/Status", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicatorStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Replicator_StatusClient interface {
	Recv() (*ReplicationStatus, error)
	grpc.ClientStream
}

type replicatorStatusClient struct {
	grpc.ClientStream
}

func (x *replicatorStatusClient) Recv() (*ReplicationStatus, error) {
	m := new(ReplicationStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicatorClient) GetSubscriptionUpdate(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*SubscriptionUpdate, error) {
	out := new(SubscriptionUpdate)
	err := c.cc.Invoke(ctx, "/pb.replicator/GetSubscriptionUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicatorClient) SubmitReplication(ctx context.Context, in *SignedSubscription, opts ...grpc.CallOption) (Replicator_SubmitReplicationClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replicator_serviceDesc.Streams[2], "/pb.replicator/SubmitReplication", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicatorSubmitReplicationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Replicator_SubmitReplicationClient interface {
	Recv() (*ReplicationStatus, error)
	grpc.ClientStream
}

type replicatorSubmitReplicationClient struct {
	grpc.ClientStream
}

func (x *replicatorSubmitReplicationClient) Recv() (*ReplicationStatus, error) {
	m := new(ReplicationStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ReplicatorServer is the server API for Replicator service.
type ReplicatorServer interface {
	// Add is used to add a replication to this server, changing it's status from reserved to active.
	Add(*Subscription, Replicator_AddServer) error
	// Status returns an updating stream of the replication status on the server.
	Status(*Subscription, Replicator_StatusServer) error
	// GetSubscriptionUpdate returns the latest version of subscribed replication
	GetSubscriptionUpdate(context.Context, *Subscription) (*SubscriptionUpdate, error)
	// SubmitReplication is used by client agents to start replications, after they
	// have uploaded the files and retrieved the cid, and collected servers to replicate too.
	SubmitReplication(*SignedSubscription, Replicator_SubmitReplicationServer) error
}

// UnimplementedReplicatorServer can be embedded to have forward compatible implementations.
type UnimplementedReplicatorServer struct {
}

func (*UnimplementedReplicatorServer) Add(req *Subscription, srv Replicator_AddServer) error {
	return status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (*UnimplementedReplicatorServer) Status(req *Subscription, srv Replicator_StatusServer) error {
	return status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedReplicatorServer) GetSubscriptionUpdate(ctx context.Context, req *Subscription) (*SubscriptionUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscriptionUpdate not implemented")
}
func (*UnimplementedReplicatorServer) SubmitReplication(req *SignedSubscription, srv Replicator_SubmitReplicationServer) error {
	return status.Errorf(codes.Unimplemented, "method SubmitReplication not implemented")
}

func RegisterReplicatorServer(s *grpc.Server, srv ReplicatorServer) {
	s.RegisterService(&_Replicator_serviceDesc, srv)
}

func _Replicator_Add_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicatorServer).Add(m, &replicatorAddServer{stream})
}

type Replicator_AddServer interface {
	Send(*ReplicationStatus) error
	grpc.ServerStream
}

type replicatorAddServer struct {
	grpc.ServerStream
}

func (x *replicatorAddServer) Send(m *ReplicationStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Replicator_Status_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicatorServer).Status(m, &replicatorStatusServer{stream})
}

type Replicator_StatusServer interface {
	Send(*ReplicationStatus) error
	grpc.ServerStream
}

type replicatorStatusServer struct {
	grpc.ServerStream
}

func (x *replicatorStatusServer) Send(m *ReplicationStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Replicator_GetSubscriptionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicatorServer).GetSubscriptionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.replicator/GetSubscriptionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicatorServer).GetSubscriptionUpdate(ctx, req.(*Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Replicator_SubmitReplication_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SignedSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicatorServer).SubmitReplication(m, &replicatorSubmitReplicationServer{stream})
}

type Replicator_SubmitReplicationServer interface {
	Send(*ReplicationStatus) error
	grpc.ServerStream
}

type replicatorSubmitReplicationServer struct {
	grpc.ServerStream
}

func (x *replicatorSubmitReplicationServer) Send(m *ReplicationStatus) error {
	return x.ServerStream.SendMsg(m)
}

var _Replicator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.replicator",
	HandlerType: (*ReplicatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubscriptionUpdate",
			Handler:    _Replicator_GetSubscriptionUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Add",
			Handler:       _Replicator_Add_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Status",
			Handler:       _Replicator_Status_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubmitReplication",
			Handler:       _Replicator_SubmitReplication_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "replication.proto",
}

func (m *Replication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServerDownDelaySeconds != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.ServerDownDelaySeconds))
		i--
		dAtA[i] = 0x30
	}
	if m.RefreshIntervalSeconds != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.RefreshIntervalSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Servers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReplication(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CidsBytes) > 0 {
		for iNdEx := len(m.CidsBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidsBytes[iNdEx])
			copy(dAtA[i:], m.CidsBytes[iNdEx])
			i = encodeVarintReplication(dAtA, i, uint64(len(m.CidsBytes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AddrInfo != nil {
		{
			size, err := m.AddrInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReplication(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GrpcPort != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.GrpcPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AddrsBytes) > 0 {
		for iNdEx := len(m.AddrsBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddrsBytes[iNdEx])
			copy(dAtA[i:], m.AddrsBytes[iNdEx])
			i = encodeVarintReplication(dAtA, i, uint64(len(m.AddrsBytes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IdBytes) > 0 {
		i -= len(m.IdBytes)
		copy(dAtA[i:], m.IdBytes)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.IdBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.AuthorIdBytes) > 0 {
		i -= len(m.AuthorIdBytes)
		copy(dAtA[i:], m.AuthorIdBytes)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.AuthorIdBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetVersion != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.TargetVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentVersion != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.CurrentVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReplicationBytes) > 0 {
		i -= len(m.ReplicationBytes)
		copy(dAtA[i:], m.ReplicationBytes)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.ReplicationBytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignedSubscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedSubscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpdatePart != nil {
		{
			size, err := m.UpdatePart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReplication(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SubPart != nil {
		{
			size, err := m.SubPart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReplication(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReplication(dAtA []byte, offset int, v uint64) int {
	offset -= sovReplication(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Replication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if len(m.CidsBytes) > 0 {
		for _, b := range m.CidsBytes {
			l = len(b)
			n += 1 + l + sovReplication(uint64(l))
		}
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovReplication(uint64(l))
		}
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovReplication(uint64(m.ReplicationFactor))
	}
	if m.RefreshIntervalSeconds != 0 {
		n += 1 + sovReplication(uint64(m.RefreshIntervalSeconds))
	}
	if m.ServerDownDelaySeconds != 0 {
		n += 1 + sovReplication(uint64(m.ServerDownDelaySeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddrInfo != nil {
		l = m.AddrInfo.Size()
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IdBytes)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if len(m.AddrsBytes) > 0 {
		for _, b := range m.AddrsBytes {
			l = len(b)
			n += 1 + l + sovReplication(uint64(l))
		}
	}
	if m.GrpcPort != 0 {
		n += 1 + sovReplication(uint64(m.GrpcPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	l = len(m.AuthorIdBytes)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.Remove {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	if m.IsActive {
		n += 2
	}
	if m.CurrentVersion != 0 {
		n += 1 + sovReplication(uint64(m.CurrentVersion))
	}
	if m.TargetVersion != 0 {
		n += 1 + sovReplication(uint64(m.TargetVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovReplication(uint64(m.Version))
	}
	l = len(m.ReplicationBytes)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignedSubscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubPart != nil {
		l = m.SubPart.Size()
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.UpdatePart != nil {
		l = m.UpdatePart.Size()
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovReplication(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReplication(x uint64) (n int) {
	return sovReplication(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Replication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidsBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidsBytes = append(m.CidsBytes, make([]byte, postIndex-iNdEx))
			copy(m.CidsBytes[len(m.CidsBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &ServerSource{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshIntervalSeconds", wireType)
			}
			m.RefreshIntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshIntervalSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDownDelaySeconds", wireType)
			}
			m.ServerDownDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerDownDelaySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddrInfo == nil {
				m.AddrInfo = &AddrInfo{}
			}
			if err := m.AddrInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdBytes = append(m.IdBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.IdBytes == nil {
				m.IdBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrsBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrsBytes = append(m.AddrsBytes, make([]byte, postIndex-iNdEx))
			copy(m.AddrsBytes[len(m.AddrsBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcPort", wireType)
			}
			m.GrpcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorIdBytes = append(m.AuthorIdBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorIdBytes == nil {
				m.AuthorIdBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentVersion", wireType)
			}
			m.CurrentVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetVersion", wireType)
			}
			m.TargetVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicationBytes = append(m.ReplicationBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplicationBytes == nil {
				m.ReplicationBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedSubscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedSubscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubPart == nil {
				m.SubPart = &Subscription{}
			}
			if err := m.SubPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePart == nil {
				m.UpdatePart = &SubscriptionUpdate{}
			}
			if err := m.UpdatePart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReplication(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReplication
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReplication
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReplication
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReplication        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReplication          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReplication = fmt.Errorf("proto: unexpected end of group")
)
