// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: file.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UploadRequest is used to upload data as a UnixFS object
type UploadRequest struct {
	// blob is a single chunk of data
	Blob *Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob,omitempty"`
	// options allows setting the options for this upload, only valid in the first message of a stream
	Options *UploadOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{0}
}
func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

func (m *UploadRequest) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *UploadRequest) GetOptions() *UploadOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// UploadOptions allows controlling the parameters of a file upload
type UploadOptions struct {
	// specifies the multihash function to use
	MultiHash string `protobuf:"bytes,1,opt,name=multiHash,proto3" json:"multiHash,omitempty"`
	// specifies the dag layout (balanced, tricklet)
	Layout string `protobuf:"bytes,2,opt,name=layout,proto3" json:"layout,omitempty"`
	// specifies the chunker type (rabin, default, etc...)
	Chunker string `protobuf:"bytes,3,opt,name=chunker,proto3" json:"chunker,omitempty"`
	// optional reference ID to tag the file with. If set, the same reference ID must be used for deletion
	RefID string `protobuf:"bytes,4,opt,name=refID,proto3" json:"refID,omitempty"`
	// if refID is set, allows progressive upload
	Progressive bool `protobuf:"varint,5,opt,name=progressive,proto3" json:"progressive,omitempty"`
	// if refID is set, remove the any existing uploads with same refID
	Replace bool `protobuf:"varint,6,opt,name=replace,proto3" json:"replace,omitempty"`
}

func (m *UploadOptions) Reset()         { *m = UploadOptions{} }
func (m *UploadOptions) String() string { return proto.CompactTextString(m) }
func (*UploadOptions) ProtoMessage()    {}
func (*UploadOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{1}
}
func (m *UploadOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadOptions.Merge(m, src)
}
func (m *UploadOptions) XXX_Size() int {
	return m.Size()
}
func (m *UploadOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadOptions.DiscardUnknown(m)
}

var xxx_messageInfo_UploadOptions proto.InternalMessageInfo

func (m *UploadOptions) GetMultiHash() string {
	if m != nil {
		return m.MultiHash
	}
	return ""
}

func (m *UploadOptions) GetLayout() string {
	if m != nil {
		return m.Layout
	}
	return ""
}

func (m *UploadOptions) GetChunker() string {
	if m != nil {
		return m.Chunker
	}
	return ""
}

func (m *UploadOptions) GetRefID() string {
	if m != nil {
		return m.RefID
	}
	return ""
}

func (m *UploadOptions) GetProgressive() bool {
	if m != nil {
		return m.Progressive
	}
	return false
}

func (m *UploadOptions) GetReplace() bool {
	if m != nil {
		return m.Replace
	}
	return false
}

// DownloadRequest is used to download a UnixFS object
// although it can in theory be used with other type of objects
// there may be some undefined behavior
type DownloadRequest struct {
	// hash is the ipfs hash/cid (content identifier) of the data to download
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// chunkSize specifies the size of chunks to be sent to the client
	// it allows us to efficiently control incoming data amounts which
	// is useful on machines with low-memory
	ChunkSize int32 `protobuf:"varint,2,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
	// Range start and end mirrors developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range.
	// If both is none zero, only data within range is requested.
	// The unit of range is always in bytes.
	// If used, please check the returned range values in blobs to make sure this feature is supported.
	RangeStart uint64 `protobuf:"varint,3,opt,name=rangeStart,proto3" json:"rangeStart,omitempty"`
	RangeEnd   uint64 `protobuf:"varint,4,opt,name=rangeEnd,proto3" json:"rangeEnd,omitempty"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{2}
}
func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *DownloadRequest) GetChunkSize() int32 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *DownloadRequest) GetRangeStart() uint64 {
	if m != nil {
		return m.RangeStart
	}
	return 0
}

func (m *DownloadRequest) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

// DownloadResponse contains the response to a download request
// which allows the gRPC server to stream blobs to the client
type DownloadResponse struct {
	// blob is a single chunk of data
	Blob *Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob,omitempty"`
}

func (m *DownloadResponse) Reset()         { *m = DownloadResponse{} }
func (m *DownloadResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadResponse) ProtoMessage()    {}
func (*DownloadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{3}
}
func (m *DownloadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadResponse.Merge(m, src)
}
func (m *DownloadResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadResponse proto.InternalMessageInfo

func (m *DownloadResponse) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

// Blob is a chunk of binary data
type Blob struct {
	// content is the actual binary data contained in this message
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Range start and end mirrors developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range.
	// If both is zero, the blobs streams contents of the file from start to finish.
	// The unit of range is always in bytes.
	// Currently, DownloadResponse support blob range.
	RangeStart uint64 `protobuf:"varint,2,opt,name=rangeStart,proto3" json:"rangeStart,omitempty"`
	RangeEnd   uint64 `protobuf:"varint,3,opt,name=rangeEnd,proto3" json:"rangeEnd,omitempty"`
}

func (m *Blob) Reset()         { *m = Blob{} }
func (m *Blob) String() string { return proto.CompactTextString(m) }
func (*Blob) ProtoMessage()    {}
func (*Blob) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{4}
}
func (m *Blob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Blob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Blob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Blob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Blob.Merge(m, src)
}
func (m *Blob) XXX_Size() int {
	return m.Size()
}
func (m *Blob) XXX_DiscardUnknown() {
	xxx_messageInfo_Blob.DiscardUnknown(m)
}

var xxx_messageInfo_Blob proto.InternalMessageInfo

func (m *Blob) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Blob) GetRangeStart() uint64 {
	if m != nil {
		return m.RangeStart
	}
	return 0
}

func (m *Blob) GetRangeEnd() uint64 {
	if m != nil {
		return m.RangeEnd
	}
	return 0
}

// UploadRequest is used to decrease the reference count on UnixFS objects
type RemoveRequest struct {
	// refIDs is a map of reference IDs to hash/cid of objects to remove those reference counts
	RefIDs map[string]string `protobuf:"bytes,1,rep,name=refIDs,proto3" json:"refIDs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RemoveRequest) Reset()         { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()    {}
func (*RemoveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{5}
}
func (m *RemoveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveRequest.Merge(m, src)
}
func (m *RemoveRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveRequest proto.InternalMessageInfo

func (m *RemoveRequest) GetRefIDs() map[string]string {
	if m != nil {
		return m.RefIDs
	}
	return nil
}

// RemoveResponse contains the response to a remove request
type RemoveResponse struct {
	// The number of removal operations performed.
	// A missing count is because the refID to hash pair was already removed or was never added
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RemoveResponse) Reset()         { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()    {}
func (*RemoveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{6}
}
func (m *RemoveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResponse.Merge(m, src)
}
func (m *RemoveResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResponse proto.InternalMessageInfo

func (m *RemoveResponse) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*UploadRequest)(nil), "pb.UploadRequest")
	proto.RegisterType((*UploadOptions)(nil), "pb.UploadOptions")
	proto.RegisterType((*DownloadRequest)(nil), "pb.DownloadRequest")
	proto.RegisterType((*DownloadResponse)(nil), "pb.DownloadResponse")
	proto.RegisterType((*Blob)(nil), "pb.Blob")
	proto.RegisterType((*RemoveRequest)(nil), "pb.RemoveRequest")
	proto.RegisterMapType((map[string]string)(nil), "pb.RemoveRequest.RefIDsEntry")
	proto.RegisterType((*RemoveResponse)(nil), "pb.RemoveResponse")
}

func init() { proto.RegisterFile("file.proto", fileDescriptor_9188e3b7e55e1162) }

var fileDescriptor_9188e3b7e55e1162 = []byte{
	// 515 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0xcf, 0x6e, 0xd3, 0x4e,
	0x18, 0xcc, 0x26, 0xce, 0xbf, 0x2f, 0xed, 0xaf, 0xfd, 0x2d, 0x11, 0xb2, 0xac, 0x62, 0x45, 0x3e,
	0xa0, 0x48, 0x48, 0x51, 0x15, 0xa8, 0x04, 0x48, 0x1c, 0xa8, 0x5a, 0x44, 0x4f, 0x54, 0x5b, 0x71,
	0x41, 0x5c, 0xec, 0x74, 0xdb, 0x58, 0xdd, 0x7a, 0xcd, 0x7a, 0x1d, 0x14, 0x2e, 0x88, 0x37, 0xe0,
	0x55, 0x38, 0xf0, 0x0e, 0x1c, 0x7b, 0xe4, 0x88, 0x92, 0x17, 0x41, 0xfb, 0xd9, 0x8b, 0x9d, 0x1c,
	0x7a, 0xf3, 0xcc, 0x37, 0x3b, 0x3b, 0x3b, 0xbb, 0x06, 0xb8, 0x8a, 0x05, 0x9f, 0xa4, 0x4a, 0x6a,
	0x49, 0x9b, 0x69, 0xe4, 0x41, 0xae, 0x63, 0x51, 0xe0, 0xe0, 0x03, 0xec, 0xbe, 0x4f, 0x85, 0x0c,
	0x2f, 0x19, 0xff, 0x94, 0xf3, 0x4c, 0xd3, 0x03, 0x70, 0x22, 0x21, 0x23, 0x97, 0x8c, 0xc8, 0x78,
	0x30, 0xed, 0x4d, 0xd2, 0x68, 0x72, 0x2c, 0x64, 0xc4, 0x90, 0xa5, 0x4f, 0xa0, 0x2b, 0x53, 0x1d,
	0xcb, 0x24, 0x73, 0x9b, 0x28, 0xf8, 0xdf, 0x08, 0x0a, 0x87, 0x77, 0xc5, 0x80, 0x59, 0x45, 0xf0,
	0x83, 0x58, 0xf3, 0x72, 0x44, 0x0f, 0xa0, 0x7f, 0x9b, 0x0b, 0x1d, 0xbf, 0x0d, 0xb3, 0x39, 0xee,
	0xd0, 0x67, 0x15, 0x41, 0x1f, 0x42, 0x47, 0x84, 0x4b, 0x99, 0x6b, 0xf4, 0xee, 0xb3, 0x12, 0x51,
	0x17, 0xba, 0xb3, 0x79, 0x9e, 0xdc, 0x70, 0xe5, 0xb6, 0x70, 0x60, 0x21, 0x1d, 0x42, 0x5b, 0xf1,
	0xab, 0xb3, 0x13, 0xd7, 0x41, 0xbe, 0x00, 0x74, 0x04, 0x83, 0x54, 0xc9, 0x6b, 0xc5, 0xb3, 0x2c,
	0x5e, 0x70, 0xb7, 0x3d, 0x22, 0xe3, 0x1e, 0xab, 0x53, 0xc6, 0x51, 0xf1, 0x54, 0x84, 0x33, 0xee,
	0x76, 0x70, 0x6a, 0x61, 0xf0, 0x15, 0xf6, 0x4e, 0xe4, 0xe7, 0xa4, 0xde, 0x08, 0x05, 0x67, 0x5e,
	0xe5, 0xc5, 0x6f, 0x73, 0x10, 0xcc, 0x70, 0x11, 0x7f, 0xe1, 0x98, 0xb6, 0xcd, 0x2a, 0x82, 0xfa,
	0x00, 0x2a, 0x4c, 0xae, 0xf9, 0x85, 0x0e, 0x95, 0xc6, 0xcc, 0x0e, 0xab, 0x31, 0xd4, 0x83, 0x1e,
	0xa2, 0xd3, 0xe4, 0x12, 0x93, 0x3b, 0xec, 0x1f, 0x0e, 0x0e, 0x61, 0xbf, 0x0a, 0x90, 0xa5, 0x32,
	0xc9, 0xf8, 0xfd, 0x77, 0x12, 0x7c, 0x04, 0xc7, 0x20, 0xac, 0x49, 0x26, 0x9a, 0x27, 0x1a, 0x85,
	0x3b, 0xcc, 0xc2, 0xad, 0x3c, 0xcd, 0x7b, 0xf3, 0xb4, 0xb6, 0xf2, 0x7c, 0x23, 0xb0, 0xcb, 0xf8,
	0xad, 0x5c, 0x70, 0xdb, 0xc7, 0x11, 0x74, 0xb0, 0xe7, 0xcc, 0x25, 0xa3, 0xd6, 0x78, 0x30, 0x7d,
	0x64, 0xf2, 0x6c, 0x48, 0x26, 0x0c, 0xe7, 0xa7, 0x89, 0x56, 0x4b, 0x56, 0x8a, 0xbd, 0x17, 0x30,
	0xa8, 0xd1, 0x74, 0x1f, 0x5a, 0x37, 0x7c, 0x59, 0x96, 0x6a, 0x3e, 0xcd, 0x65, 0x2e, 0x42, 0x91,
	0xf3, 0xf2, 0xf6, 0x0b, 0xf0, 0xb2, 0xf9, 0x9c, 0x04, 0x8f, 0xe1, 0x3f, 0xeb, 0x5f, 0x36, 0x32,
	0x84, 0xf6, 0x4c, 0xe6, 0xe5, 0x49, 0x1d, 0x56, 0x80, 0xe9, 0x4f, 0x02, 0xdd, 0x37, 0xb1, 0xe0,
	0xaf, 0xcf, 0xcf, 0xe8, 0x33, 0x80, 0xe2, 0xed, 0x19, 0x82, 0xd6, 0x9e, 0x69, 0x99, 0xd1, 0xdb,
	0x33, 0xd4, 0x79, 0xae, 0xad, 0x67, 0xd0, 0x18, 0x13, 0xfa, 0x0a, 0x76, 0x6c, 0xfb, 0xb8, 0xee,
	0x81, 0x11, 0x6d, 0x3d, 0x08, 0x6f, 0xb8, 0x49, 0xda, 0xe5, 0x87, 0x84, 0x1e, 0x01, 0x14, 0x41,
	0xab, 0x4d, 0x37, 0x8a, 0xf1, 0x68, 0x9d, 0xb2, 0x0b, 0x8f, 0xdd, 0x5f, 0x2b, 0x9f, 0xdc, 0xad,
	0x7c, 0xf2, 0x67, 0xe5, 0x93, 0xef, 0x6b, 0xbf, 0x71, 0xb7, 0xf6, 0x1b, 0xbf, 0xd7, 0x7e, 0x23,
	0xea, 0xe0, 0x5f, 0xfa, 0xf4, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x31, 0x98, 0x8c, 0x90, 0xc3,
	0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileAPIClient is the client API for FileAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileAPIClient interface {
	// UploadFile allows uploading a file as a UnixFS object (equivalent to ipfs pin add)
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileAPI_UploadFileClient, error)
	// DownloadFile allows downloading a UnixFS object (equivalent to ipfs get)
	DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileAPI_DownloadFileClient, error)
	// RemoveFile allows removing a UnixFS object or decrease it's reference counter (equivalent to ipfs pin rm)
	RemoveFile(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
}

type fileAPIClient struct {
	cc *grpc.ClientConn
}

func NewFileAPIClient(cc *grpc.ClientConn) FileAPIClient {
	return &fileAPIClient{cc}
}

func (c *fileAPIClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileAPI_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileAPI_serviceDesc.Streams[0], "/pb.FileAPI/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileAPIUploadFileClient{stream}
	return x, nil
}

type FileAPI_UploadFileClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*PutResponse, error)
	grpc.ClientStream
}

type fileAPIUploadFileClient struct {
	grpc.ClientStream
}

func (x *fileAPIUploadFileClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileAPIUploadFileClient) CloseAndRecv() (*PutResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileAPIClient) DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileAPI_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileAPI_serviceDesc.Streams[1], "/pb.FileAPI/DownloadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileAPIDownloadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileAPI_DownloadFileClient interface {
	Recv() (*DownloadResponse, error)
	grpc.ClientStream
}

type fileAPIDownloadFileClient struct {
	grpc.ClientStream
}

func (x *fileAPIDownloadFileClient) Recv() (*DownloadResponse, error) {
	m := new(DownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileAPIClient) RemoveFile(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/pb.FileAPI/RemoveFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileAPIServer is the server API for FileAPI service.
type FileAPIServer interface {
	// UploadFile allows uploading a file as a UnixFS object (equivalent to ipfs pin add)
	UploadFile(FileAPI_UploadFileServer) error
	// DownloadFile allows downloading a UnixFS object (equivalent to ipfs get)
	DownloadFile(*DownloadRequest, FileAPI_DownloadFileServer) error
	// RemoveFile allows removing a UnixFS object or decrease it's reference counter (equivalent to ipfs pin rm)
	RemoveFile(context.Context, *RemoveRequest) (*RemoveResponse, error)
}

// UnimplementedFileAPIServer can be embedded to have forward compatible implementations.
type UnimplementedFileAPIServer struct {
}

func (*UnimplementedFileAPIServer) UploadFile(srv FileAPI_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (*UnimplementedFileAPIServer) DownloadFile(req *DownloadRequest, srv FileAPI_DownloadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (*UnimplementedFileAPIServer) RemoveFile(ctx context.Context, req *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFile not implemented")
}

func RegisterFileAPIServer(s *grpc.Server, srv FileAPIServer) {
	s.RegisterService(&_FileAPI_serviceDesc, srv)
}

func _FileAPI_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileAPIServer).UploadFile(&fileAPIUploadFileServer{stream})
}

type FileAPI_UploadFileServer interface {
	SendAndClose(*PutResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type fileAPIUploadFileServer struct {
	grpc.ServerStream
}

func (x *fileAPIUploadFileServer) SendAndClose(m *PutResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileAPIUploadFileServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileAPI_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileAPIServer).DownloadFile(m, &fileAPIDownloadFileServer{stream})
}

type FileAPI_DownloadFileServer interface {
	Send(*DownloadResponse) error
	grpc.ServerStream
}

type fileAPIDownloadFileServer struct {
	grpc.ServerStream
}

func (x *fileAPIDownloadFileServer) Send(m *DownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _FileAPI_RemoveFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileAPIServer).RemoveFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileAPI/RemoveFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileAPIServer).RemoveFile(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.FileAPI",
	HandlerType: (*FileAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoveFile",
			Handler:    _FileAPI_RemoveFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _FileAPI_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _FileAPI_DownloadFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "file.proto",
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFile(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Blob != nil {
		{
			size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFile(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Replace {
		i--
		if m.Replace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Progressive {
		i--
		if m.Progressive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RefID) > 0 {
		i -= len(m.RefID)
		copy(dAtA[i:], m.RefID)
		i = encodeVarintFile(dAtA, i, uint64(len(m.RefID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Chunker) > 0 {
		i -= len(m.Chunker)
		copy(dAtA[i:], m.Chunker)
		i = encodeVarintFile(dAtA, i, uint64(len(m.Chunker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Layout) > 0 {
		i -= len(m.Layout)
		copy(dAtA[i:], m.Layout)
		i = encodeVarintFile(dAtA, i, uint64(len(m.Layout)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MultiHash) > 0 {
		i -= len(m.MultiHash)
		copy(dAtA[i:], m.MultiHash)
		i = encodeVarintFile(dAtA, i, uint64(len(m.MultiHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeEnd != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.RangeEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.RangeStart != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.RangeStart))
		i--
		dAtA[i] = 0x18
	}
	if m.ChunkSize != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.ChunkSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintFile(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Blob != nil {
		{
			size, err := m.Blob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFile(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Blob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Blob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Blob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeEnd != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.RangeEnd))
		i--
		dAtA[i] = 0x18
	}
	if m.RangeStart != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.RangeStart))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintFile(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefIDs) > 0 {
		for k := range m.RefIDs {
			v := m.RefIDs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFile(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFile(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFile(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintFile(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFile(dAtA []byte, offset int, v uint64) int {
	offset -= sovFile(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Blob != nil {
		l = m.Blob.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	return n
}

func (m *UploadOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultiHash)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	l = len(m.Layout)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	l = len(m.Chunker)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	l = len(m.RefID)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.Progressive {
		n += 2
	}
	if m.Replace {
		n += 2
	}
	return n
}

func (m *DownloadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovFile(uint64(m.ChunkSize))
	}
	if m.RangeStart != 0 {
		n += 1 + sovFile(uint64(m.RangeStart))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovFile(uint64(m.RangeEnd))
	}
	return n
}

func (m *DownloadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Blob != nil {
		l = m.Blob.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	return n
}

func (m *Blob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.RangeStart != 0 {
		n += 1 + sovFile(uint64(m.RangeStart))
	}
	if m.RangeEnd != 0 {
		n += 1 + sovFile(uint64(m.RangeEnd))
	}
	return n
}

func (m *RemoveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RefIDs) > 0 {
		for k, v := range m.RefIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFile(uint64(len(k))) + 1 + len(v) + sovFile(uint64(len(v)))
			n += mapEntrySize + 1 + sovFile(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RemoveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovFile(uint64(m.Count))
	}
	return n
}

func sovFile(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFile(x uint64) (n int) {
	return sovFile(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Blob == nil {
				m.Blob = &Blob{}
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &UploadOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progressive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Progressive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replace = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStart", wireType)
			}
			m.RangeStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Blob == nil {
				m.Blob = &Blob{}
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Blob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStart", wireType)
			}
			m.RangeStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			m.RangeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefIDs == nil {
				m.RefIDs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFile
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFile
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFile
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFile
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFile
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFile
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFile(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFile
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RefIDs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFile(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFile
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFile
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFile
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFile
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFile        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFile          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFile = fmt.Errorf("proto: unexpected end of group")
)
