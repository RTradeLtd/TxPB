// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: file.proto

package pb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// UploadRequest is used to upload data as a UnixFS object
type UploadRequest struct {
	// blob is a single chunk of data
	Blob *Blob `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob,omitempty"`
	// options allows setting the optoins for this upload
	Options              *UploadOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UploadRequest) Reset()      { *m = UploadRequest{} }
func (*UploadRequest) ProtoMessage() {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{0}
}
func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

func (m *UploadRequest) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *UploadRequest) GetOptions() *UploadOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// UploadOptions allows controlling the parameters of a file upload
type UploadOptions struct {
	// specifes the multihash function to use
	MultiHash string `protobuf:"bytes,1,opt,name=multiHash,proto3" json:"multiHash,omitempty"`
	// specifies the dag layout (balanced, tricklet)
	Layout string `protobuf:"bytes,2,opt,name=layout,proto3" json:"layout,omitempty"`
	// specifies the chunker type (rabin, default, etc...)
	Chunker              string   `protobuf:"bytes,3,opt,name=chunker,proto3" json:"chunker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadOptions) Reset()      { *m = UploadOptions{} }
func (*UploadOptions) ProtoMessage() {}
func (*UploadOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{1}
}
func (m *UploadOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadOptions.Merge(m, src)
}
func (m *UploadOptions) XXX_Size() int {
	return m.Size()
}
func (m *UploadOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadOptions.DiscardUnknown(m)
}

var xxx_messageInfo_UploadOptions proto.InternalMessageInfo

func (m *UploadOptions) GetMultiHash() string {
	if m != nil {
		return m.MultiHash
	}
	return ""
}

func (m *UploadOptions) GetLayout() string {
	if m != nil {
		return m.Layout
	}
	return ""
}

func (m *UploadOptions) GetChunker() string {
	if m != nil {
		return m.Chunker
	}
	return ""
}

// DownloadRequest is used to download a UnixFS object
// although it can in theory be used with other type of objects
// there may be some undefined behavior
type DownloadRequest struct {
	// hash is the ipfs hash/cid (content identifier) of the data to download
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// chunkSize specifies the size of chunks to be sent to the client
	// it allows us to efficiently control incoming data amounts which
	// is useful on machines with low-memory
	ChunkSize            int32    `protobuf:"varint,2,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadRequest) Reset()      { *m = DownloadRequest{} }
func (*DownloadRequest) ProtoMessage() {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{2}
}
func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *DownloadRequest) GetChunkSize() int32 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

// DownloadResponse contains the response to a download request
// which allows the gRPC server to stream blobs to the client
type DownloadResponse struct {
	// blob is a single chunk of data
	Blob                 *Blob    `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadResponse) Reset()      { *m = DownloadResponse{} }
func (*DownloadResponse) ProtoMessage() {}
func (*DownloadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{3}
}
func (m *DownloadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadResponse.Merge(m, src)
}
func (m *DownloadResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadResponse proto.InternalMessageInfo

func (m *DownloadResponse) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

// Blob is a chunk of binary data
type Blob struct {
	// content is the actual binary data contained in this message
	Content              []byte   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Blob) Reset()      { *m = Blob{} }
func (*Blob) ProtoMessage() {}
func (*Blob) Descriptor() ([]byte, []int) {
	return fileDescriptor_9188e3b7e55e1162, []int{4}
}
func (m *Blob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Blob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Blob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Blob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Blob.Merge(m, src)
}
func (m *Blob) XXX_Size() int {
	return m.Size()
}
func (m *Blob) XXX_DiscardUnknown() {
	xxx_messageInfo_Blob.DiscardUnknown(m)
}

var xxx_messageInfo_Blob proto.InternalMessageInfo

func (m *Blob) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func init() {
	proto.RegisterType((*UploadRequest)(nil), "pb.UploadRequest")
	proto.RegisterType((*UploadOptions)(nil), "pb.UploadOptions")
	proto.RegisterType((*DownloadRequest)(nil), "pb.DownloadRequest")
	proto.RegisterType((*DownloadResponse)(nil), "pb.DownloadResponse")
	proto.RegisterType((*Blob)(nil), "pb.Blob")
}

func init() { proto.RegisterFile("file.proto", fileDescriptor_9188e3b7e55e1162) }

var fileDescriptor_9188e3b7e55e1162 = []byte{
	// 374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0xb1, 0x4e, 0xe3, 0x40,
	0x10, 0xcd, 0xe6, 0x72, 0xc9, 0x65, 0x2e, 0xa7, 0xdc, 0xed, 0x9d, 0x4e, 0x96, 0x15, 0xad, 0x22,
	0x57, 0x91, 0x4e, 0xe7, 0x44, 0xb9, 0x6b, 0x29, 0x08, 0x08, 0x41, 0x45, 0x64, 0x44, 0x43, 0x83,
	0xb2, 0x61, 0x13, 0x5b, 0x6c, 0xbc, 0x26, 0xde, 0x15, 0x82, 0x02, 0xf1, 0x39, 0x7c, 0x02, 0x9f,
	0x40, 0x49, 0x49, 0x19, 0xfb, 0x0b, 0x28, 0x29, 0x91, 0xc7, 0xb1, 0x1c, 0x28, 0xe8, 0xe6, 0xbd,
	0x79, 0xf3, 0xe6, 0xed, 0x68, 0x01, 0x66, 0x81, 0x14, 0x6e, 0xb4, 0x54, 0x5a, 0xd1, 0x6a, 0xc4,
	0x6d, 0x30, 0x3a, 0x90, 0x39, 0xb6, 0xff, 0xce, 0x03, 0xed, 0x1b, 0xee, 0x4e, 0xd5, 0xa2, 0x3f,
	0x57, 0x73, 0xd5, 0x47, 0x9a, 0x9b, 0x19, 0x22, 0x04, 0x58, 0xe5, 0x72, 0xe7, 0x04, 0xbe, 0x1d,
	0x47, 0x52, 0x4d, 0xce, 0x3c, 0x71, 0x61, 0x44, 0xac, 0x69, 0x07, 0x6a, 0x5c, 0x2a, 0x6e, 0x91,
	0x2e, 0xe9, 0x7d, 0x1d, 0x7e, 0x71, 0x23, 0xee, 0x8e, 0xa4, 0xe2, 0x1e, 0xb2, 0xf4, 0x0f, 0x34,
	0x54, 0xa4, 0x03, 0x15, 0xc6, 0x56, 0x15, 0x05, 0x3f, 0x32, 0x41, 0xee, 0x70, 0x98, 0x37, 0xbc,
	0x42, 0xe1, 0x9c, 0x16, 0xde, 0xeb, 0x0e, 0xed, 0x40, 0x73, 0x61, 0xa4, 0x0e, 0xf6, 0x27, 0xb1,
	0x8f, 0x0b, 0x9a, 0x5e, 0x49, 0xd0, 0xdf, 0x50, 0x97, 0x93, 0x2b, 0x65, 0x34, 0x5a, 0x37, 0xbd,
	0x35, 0xa2, 0x16, 0x34, 0xa6, 0xbe, 0x09, 0xcf, 0xc5, 0xd2, 0xfa, 0x84, 0x8d, 0x02, 0x3a, 0x3b,
	0xd0, 0xde, 0x55, 0x97, 0xe1, 0x66, 0x7c, 0x0a, 0x35, 0xbf, 0x74, 0xc7, 0x3a, 0x5b, 0x8b, 0x13,
	0x47, 0xc1, 0xb5, 0x40, 0xef, 0xcf, 0x5e, 0x49, 0x38, 0x03, 0xf8, 0x5e, 0x9a, 0xc4, 0x91, 0x0a,
	0x63, 0xf1, 0xf1, 0x11, 0x9c, 0x2e, 0xd4, 0x32, 0x84, 0xc1, 0x54, 0xa8, 0x45, 0xa8, 0x51, 0xd8,
	0xf2, 0x0a, 0x38, 0xbc, 0x81, 0xc6, 0x5e, 0x20, 0xc5, 0xf6, 0xf8, 0x80, 0xfe, 0x07, 0xc8, 0x8f,
	0x90, 0x11, 0x74, 0xe3, 0x5c, 0xeb, 0xc4, 0x76, 0x3b, 0xa3, 0xc6, 0x46, 0x17, 0xcb, 0x9d, 0x4a,
	0x8f, 0xd0, 0x2d, 0x68, 0x15, 0xa1, 0x70, 0xee, 0x67, 0x26, 0x7a, 0xf7, 0x56, 0xfb, 0xd7, 0x5b,
	0xb2, 0x18, 0x1f, 0x90, 0x51, 0xef, 0x29, 0x61, 0x95, 0x55, 0xc2, 0xc8, 0x73, 0xc2, 0xc8, 0x4b,
	0xc2, 0xc8, 0x6d, 0xca, 0xc8, 0x5d, 0xca, 0xc8, 0x7d, 0xca, 0xc8, 0x43, 0xca, 0xc8, 0x63, 0xca,
	0xc8, 0x2a, 0x65, 0x84, 0xd7, 0xf1, 0x1b, 0xfc, 0x7b, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x71, 0x13,
	0xd0, 0xd2, 0x53, 0x02, 0x00, 0x00,
}

func (this *UploadRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UploadRequest)
	if !ok {
		that2, ok := that.(UploadRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UploadRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UploadRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UploadRequest but is not nil && this == nil")
	}
	if !this.Blob.Equal(that1.Blob) {
		return fmt.Errorf("Blob this(%v) Not Equal that(%v)", this.Blob, that1.Blob)
	}
	if !this.Options.Equal(that1.Options) {
		return fmt.Errorf("Options this(%v) Not Equal that(%v)", this.Options, that1.Options)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *UploadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadRequest)
	if !ok {
		that2, ok := that.(UploadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Blob.Equal(that1.Blob) {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UploadOptions) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UploadOptions)
	if !ok {
		that2, ok := that.(UploadOptions)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UploadOptions")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UploadOptions but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UploadOptions but is not nil && this == nil")
	}
	if this.MultiHash != that1.MultiHash {
		return fmt.Errorf("MultiHash this(%v) Not Equal that(%v)", this.MultiHash, that1.MultiHash)
	}
	if this.Layout != that1.Layout {
		return fmt.Errorf("Layout this(%v) Not Equal that(%v)", this.Layout, that1.Layout)
	}
	if this.Chunker != that1.Chunker {
		return fmt.Errorf("Chunker this(%v) Not Equal that(%v)", this.Chunker, that1.Chunker)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *UploadOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadOptions)
	if !ok {
		that2, ok := that.(UploadOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MultiHash != that1.MultiHash {
		return false
	}
	if this.Layout != that1.Layout {
		return false
	}
	if this.Chunker != that1.Chunker {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DownloadRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DownloadRequest)
	if !ok {
		that2, ok := that.(DownloadRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DownloadRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DownloadRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DownloadRequest but is not nil && this == nil")
	}
	if this.Hash != that1.Hash {
		return fmt.Errorf("Hash this(%v) Not Equal that(%v)", this.Hash, that1.Hash)
	}
	if this.ChunkSize != that1.ChunkSize {
		return fmt.Errorf("ChunkSize this(%v) Not Equal that(%v)", this.ChunkSize, that1.ChunkSize)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *DownloadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DownloadRequest)
	if !ok {
		that2, ok := that.(DownloadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DownloadResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DownloadResponse)
	if !ok {
		that2, ok := that.(DownloadResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DownloadResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DownloadResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DownloadResponse but is not nil && this == nil")
	}
	if !this.Blob.Equal(that1.Blob) {
		return fmt.Errorf("Blob this(%v) Not Equal that(%v)", this.Blob, that1.Blob)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *DownloadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DownloadResponse)
	if !ok {
		that2, ok := that.(DownloadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Blob.Equal(that1.Blob) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Blob) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Blob)
	if !ok {
		that2, ok := that.(Blob)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Blob")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Blob but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Blob but is not nil && this == nil")
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return fmt.Errorf("Content this(%v) Not Equal that(%v)", this.Content, that1.Content)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Blob) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Blob)
	if !ok {
		that2, ok := that.(Blob)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UploadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.UploadRequest{")
	if this.Blob != nil {
		s = append(s, "Blob: "+fmt.Sprintf("%#v", this.Blob)+",\n")
	}
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.UploadOptions{")
	s = append(s, "MultiHash: "+fmt.Sprintf("%#v", this.MultiHash)+",\n")
	s = append(s, "Layout: "+fmt.Sprintf("%#v", this.Layout)+",\n")
	s = append(s, "Chunker: "+fmt.Sprintf("%#v", this.Chunker)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DownloadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.DownloadRequest{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DownloadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.DownloadResponse{")
	if this.Blob != nil {
		s = append(s, "Blob: "+fmt.Sprintf("%#v", this.Blob)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Blob) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.Blob{")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringFile(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileAPIClient is the client API for FileAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileAPIClient interface {
	// UploadFile allows uploading a file as a UnixFS object (equivalent to ipfs add)
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileAPI_UploadFileClient, error)
	// DownloadFile allows downloading a UnixFS object (equivalent to ipfs get)
	DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileAPI_DownloadFileClient, error)
}

type fileAPIClient struct {
	cc *grpc.ClientConn
}

func NewFileAPIClient(cc *grpc.ClientConn) FileAPIClient {
	return &fileAPIClient{cc}
}

func (c *fileAPIClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileAPI_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileAPI_serviceDesc.Streams[0], "/pb.FileAPI/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileAPIUploadFileClient{stream}
	return x, nil
}

type FileAPI_UploadFileClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*PutResponse, error)
	grpc.ClientStream
}

type fileAPIUploadFileClient struct {
	grpc.ClientStream
}

func (x *fileAPIUploadFileClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileAPIUploadFileClient) CloseAndRecv() (*PutResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileAPIClient) DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileAPI_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileAPI_serviceDesc.Streams[1], "/pb.FileAPI/DownloadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileAPIDownloadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileAPI_DownloadFileClient interface {
	Recv() (*DownloadResponse, error)
	grpc.ClientStream
}

type fileAPIDownloadFileClient struct {
	grpc.ClientStream
}

func (x *fileAPIDownloadFileClient) Recv() (*DownloadResponse, error) {
	m := new(DownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileAPIServer is the server API for FileAPI service.
type FileAPIServer interface {
	// UploadFile allows uploading a file as a UnixFS object (equivalent to ipfs add)
	UploadFile(FileAPI_UploadFileServer) error
	// DownloadFile allows downloading a UnixFS object (equivalent to ipfs get)
	DownloadFile(*DownloadRequest, FileAPI_DownloadFileServer) error
}

func RegisterFileAPIServer(s *grpc.Server, srv FileAPIServer) {
	s.RegisterService(&_FileAPI_serviceDesc, srv)
}

func _FileAPI_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileAPIServer).UploadFile(&fileAPIUploadFileServer{stream})
}

type FileAPI_UploadFileServer interface {
	SendAndClose(*PutResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type fileAPIUploadFileServer struct {
	grpc.ServerStream
}

func (x *fileAPIUploadFileServer) SendAndClose(m *PutResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileAPIUploadFileServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileAPI_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileAPIServer).DownloadFile(m, &fileAPIDownloadFileServer{stream})
}

type FileAPI_DownloadFileServer interface {
	Send(*DownloadResponse) error
	grpc.ServerStream
}

type fileAPIDownloadFileServer struct {
	grpc.ServerStream
}

func (x *fileAPIDownloadFileServer) Send(m *DownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _FileAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.FileAPI",
	HandlerType: (*FileAPIServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _FileAPI_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _FileAPI_DownloadFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "file.proto",
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Blob != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFile(dAtA, i, uint64(m.Blob.Size()))
		n1, err := m.Blob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Options != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFile(dAtA, i, uint64(m.Options.Size()))
		n2, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MultiHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFile(dAtA, i, uint64(len(m.MultiHash)))
		i += copy(dAtA[i:], m.MultiHash)
	}
	if len(m.Layout) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFile(dAtA, i, uint64(len(m.Layout)))
		i += copy(dAtA[i:], m.Layout)
	}
	if len(m.Chunker) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFile(dAtA, i, uint64(len(m.Chunker)))
		i += copy(dAtA[i:], m.Chunker)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFile(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFile(dAtA, i, uint64(m.ChunkSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DownloadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Blob != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFile(dAtA, i, uint64(m.Blob.Size()))
		n3, err := m.Blob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Blob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Blob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFile(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintFile(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedUploadRequest(r randyFile, easy bool) *UploadRequest {
	this := &UploadRequest{}
	if r.Intn(10) != 0 {
		this.Blob = NewPopulatedBlob(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Options = NewPopulatedUploadOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFile(r, 3)
	}
	return this
}

func NewPopulatedUploadOptions(r randyFile, easy bool) *UploadOptions {
	this := &UploadOptions{}
	this.MultiHash = string(randStringFile(r))
	this.Layout = string(randStringFile(r))
	this.Chunker = string(randStringFile(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFile(r, 4)
	}
	return this
}

func NewPopulatedDownloadRequest(r randyFile, easy bool) *DownloadRequest {
	this := &DownloadRequest{}
	this.Hash = string(randStringFile(r))
	this.ChunkSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChunkSize *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFile(r, 3)
	}
	return this
}

func NewPopulatedDownloadResponse(r randyFile, easy bool) *DownloadResponse {
	this := &DownloadResponse{}
	if r.Intn(10) != 0 {
		this.Blob = NewPopulatedBlob(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFile(r, 2)
	}
	return this
}

func NewPopulatedBlob(r randyFile, easy bool) *Blob {
	this := &Blob{}
	v1 := r.Intn(100)
	this.Content = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Content[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedFile(r, 2)
	}
	return this
}

type randyFile interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneFile(r randyFile) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringFile(r randyFile) string {
	v2 := r.Intn(100)
	tmps := make([]rune, v2)
	for i := 0; i < v2; i++ {
		tmps[i] = randUTF8RuneFile(r)
	}
	return string(tmps)
}
func randUnrecognizedFile(r randyFile, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldFile(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldFile(dAtA []byte, r randyFile, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateFile(dAtA, uint64(key))
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		dAtA = encodeVarintPopulateFile(dAtA, uint64(v3))
	case 1:
		dAtA = encodeVarintPopulateFile(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateFile(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateFile(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateFile(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateFile(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *UploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Blob != nil {
		l = m.Blob.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultiHash)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	l = len(m.Layout)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	l = len(m.Chunker)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovFile(uint64(m.ChunkSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Blob != nil {
		l = m.Blob.Size()
		n += 1 + l + sovFile(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Blob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovFile(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFile(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFile(x uint64) (n int) {
	return sovFile(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UploadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadRequest{`,
		`Blob:` + strings.Replace(fmt.Sprintf("%v", this.Blob), "Blob", "Blob", 1) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "UploadOptions", "UploadOptions", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadOptions{`,
		`MultiHash:` + fmt.Sprintf("%v", this.MultiHash) + `,`,
		`Layout:` + fmt.Sprintf("%v", this.Layout) + `,`,
		`Chunker:` + fmt.Sprintf("%v", this.Chunker) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DownloadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DownloadRequest{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DownloadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DownloadResponse{`,
		`Blob:` + strings.Replace(fmt.Sprintf("%v", this.Blob), "Blob", "Blob", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Blob) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Blob{`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringFile(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Blob == nil {
				m.Blob = &Blob{}
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &UploadOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Blob == nil {
				m.Blob = &Blob{}
			}
			if err := m.Blob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Blob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFile
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFile
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFile(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFile
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFile
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFile
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFile
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFile(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFile
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFile = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFile   = fmt.Errorf("proto: integer overflow")
)
